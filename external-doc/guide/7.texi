@comment *********************************************************************
@comment ** 7. PROCEDURE DIVISION                                           **
@comment *********************************************************************
@newchapter{7,PROCEDURE DIVISION}
@diagram{PROCEDURE DIVISION,PD-Overview-Info,PD-Overview-TeX,None}
@p The PROCEDURE DIVISION of any GnuCOBOL program marks the point where all executable code is written.
@menu
* 7.1:  PROCEDURE DIVISION USING.
* 7.2:  PROCEDURE DIVISION CHAINING.
* 7.3:  PROCEDURE DIVISION RETURNING.
* 7.4:  PROCEDURE DIVISION Sections and Paragraphs.
* 7.5:  DECLARATIVES.
* 7.6: Common Clauses on Executable Statements.
@detailmenu
*   7.6.1: AT END + NOT AT END.
*   7.6.2: CORRESPONDING.
*   7.6.3: INVALID KEY + NOT INVALID KEY.
*   7.6.4: ON EXCEPTION + NOT ON EXCEPTION.
*   7.6.5: ON OVERFLOW + NOT ON OVERFLOW.
*   7.6.6: ON SIZE ERROR + NOT ON SIZE ERROR.
*   7.6.7: ROUNDED.
@end detailmenu
* 7.7: Special Registers.
* 7.8: GnuCOBOL Statements.
@end menu
@comment *********************************************************************
@comment ** 7.1 PROCEDURE DIVISION USING                                    **
@comment *********************************************************************
@page
@newsection{7.1,PROCEDURE DIVISION USING}
@diagram{PROCEDURE DIVISION Subprogram-Argument,PD-USING,PD-USING,None}@p The @syntax{USING} clause defines the arguments that will be passed to a GnuCOBOL program which is serving as a subprogram.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY} and @syntax{IS} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words have no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntaxidx{USING} clause should only be used on the procedure division header of subprograms (subroutines or user-defined functions).
@p @item The calling program will pass zero or more data items, known as arguments, to this subprogram --- there must be exactly as many @term{identifier-1} data items specified on the USING clause as the maximum number of arguments the subprogram will ever be passed.
@p @item If a subprogram does not expect any arguments, it should not have a @syntax{USING} clause specified on it's procedure division header.
@p @item The order in which arguments are defined on the @syntax{USING} clause must correspond to the order in which those arguments will be passed to the subprogram by the calling program.
@p @item The identifiers specified on the @syntax{USING} clause must be defined in the linkage section of the subprogram.  No storage is actually allocated for those identifiers in the subprogram as the actual storage for them will exist in the calling program.
@p @item A GnuCOBOL subprogram expects that all arguments to it will be one of two things:
@itemize @bullet
@p @item The memory address of the actual data item (allocated in the calling program) that is being passed to the subprogram.
@p @item A numeric, full-word, binary value (i.e. @syntaxrefalt{USAGE BINARY-LONG,USAGE}) which is the actual argument being passed to the subprogram.
@end itemize
@* In the case of the former, the @syntax{USING} clause on the procedure division header should describe the argument via the @syntaxidx{BY REFERENCE} clause --- in the latter case, a @syntaxidx{BY VALUE} specification should be coded.  This allows the code generated by the compiler to properly reference the subprogram arguments at run-time.
@p @item @syntax{BY REFERENCE} is the assumed default for the first @syntax{USING} argument should no @syntax{BY} clause be specified for it.  Subsequent arguments will assume the @syntax{BY} specification of the argument prior to them should they lack a @syntax{BY} clause of their own.
@p @item Changes made by a subprogram to the value of an argument specified on the @syntax{USING} clause will "be visible" to the calling program only if @syntax{BY REFERENCE} was explicitly specified or implicitly assumed for the argument on the subprogram's procedure division header @i{and} the argument was passed to the subprogram @syntax{BY REFERENCE} by the calling program.  @xref{Subprogram Arguments}, for additional information on the mechanics of how arguments are passed to subprograms.
@p @item The optional @syntax{SIZE} clause allows you to specify the number of bytes a @syntax{BY VALUE} argument will occupy, with @syntax{SIZE DEFAULT} specifying 4 bytes (this is the default if no @syntax{SIZE} clause is used), @syntax{SIZE AUTO} specifying the size of the argument in the calling program and @syntax{SIZE @term{integer-1}} specifying a specific byte count.
@p @item The optional @syntax{UNSIGNED} keyword, legal only if @syntax{SIZE AUTO} or @syntax{SIZE @term{integer-1}} are coded, will add the "unsigned" attribute to the argument's specification in the C-language function header code generated for the subprogram.  While not of any benefit when the calling program is a GnuCOBOL program, this can improve compatibility with a C-language calling program.
@p @item The @syntaxidx{OPTIONAL} keyword, legal only on @syntax{BY REFERENCE} arguments, allows calling programs to code @syntaxidx{OMITTED} for that corresponding argument when they call this subprogram.  @xref{CALL}. for additional information on this feature.
@end enumerate
@comment *********************************************************************
@comment ** 7.2 PROCEDURE DIVISION CHAINING                                 **
@comment *********************************************************************
@page
@newsection{7.2,PROCEDURE DIVISION CHAINING}
@diagram{PROCEDURE DIVISION Main-Program-Argument,PD-CHAINING,PD-CHAINING,None}@p The @syntax{CHAINING} term provides one mechanism a programmer may use to retrieve command-line arguments passed to a program at execution time.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item @syntax{PROCEDURE DIVISION CHAINING} may only be coded in a main program (that is, the first program executed when a compiled GnuCOBOL compilation unit is executed).  It cannot be used in any form of subprogram.
@p @item The @syntax{CHAINING} clause defines arguments that will be passed to a main program from the operating system.  The argument identifiers specified on the CHAINING clause will be populated by character strings comprised of the parameters specified to the program on the command line that executed it, as follows:
@enumerate A
@p @item When a GnuCOBOL program is executed from a command-line, the complete command line text will be broken into a series of "tokens", where each token is identified as being a word separated from the others in the command text by at least one space.  For example, if the command line was @code{/usr/local/myprog THIS IS A TEST}, there will be five tokens identified by the operating system --- "/usr/local/myprog", "THIS", "IS", "A" and "TEST".
@p @item Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes.  For example, there are only three tokens generated from the command line @code{C:\Pgms\myprog.exe "THIS IS A" TEST} --- "C:\Pgms\myprog.exe", "THIS IS A" and "TEST".  When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token's value.
@p @item Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the "CHAINING" arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.
@p @item If there are more tokens than there are arguments, the excess tokens will be discarded.
@p @item If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the @syntaxrefalt{INITIALIZE @term{identifier-1},INITIALIZE} statement were executed.
@p @item All identifiers specified on the CHAINING clause should be defined as PIC X, PIC A, group items (which are treated implicitly as PIC X) or as PIC 9 USAGE DISPLAY.  The use of USAGE BINARY (or the like) data items as CHAINING arguments is not recommended as all command-line tokens will be retained in their original character form as they are moved into the argument data items.
@p @item If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in.  Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.
@p @item If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner.  unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with "0" characters from the systems native character set.
@p This behaviour when the argument is defined as @syntax{PIC 9} may be unacceptable, as an argument defined as @syntax{PIC 9(3)} but passed in a value of "1" from the command line will receive a value of "100", not "001".  Consider defining "numeric" command line arguments as @syntax{PIC X} and then using the @intrinsicref{NUMVAL} function to determine the proper numeric value.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.3 PROCEDURE DIVISION RETURNING                                **
@comment *********************************************************************
@page
@newsection{7.3,PROCEDURE DIVISION RETURNING}
@diagram{PROCEDURE DIVISION RETURNING,PD-RETURNING,PD-RETURNING,None}@p The RETURNING clause on the PROCEDURE DIVISION header documents that the subprogram in which the clause appears will be returning a numeric value back to the program that called it.
@comment Semantic Specifications:
@enumerate
@p @item The @syntax{RETURNING} clause is optional within a subroutine, as not all subroutines return a value to their caller.
@p @item The @syntax{RETURNING} clause is mandatory within a user-defined function, as all such must return a numeric result.
@p @item The @term{identifier-1} data item should be defined as a USAGE BINARY-LONG data item.
@p @item Main programs that wish to "pass back" a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the @syntax{RETURN-CODE} special register.
@p @item This is not the only mechanism that a subprogram may use to pass a value back to it's caller.  Other possibilities are:
@enumerate A
@p @item The subprogram may modify any argument that is specified as "BY REFERENCE" on it's PROCEDURE DIVISION header.  Whether the calling program can actually "see" any modifications depends upon how the calling program passed the argument to the subprogram.  @xref{CALL}, for more information.
@p @item A data item with the @syntaxref{GLOBAL} attribute specified in it's description in the calling program is automatically visible to and updatable by a subprogram nested with the calling program.  @xref{Independent vs Contained vs Nested Subprograms}, for more information on subprogram nesting.
@p @item A data item defined with the @syntaxref{EXTERNAL} attribute in a subprogram and the calling program (same name in both programs) is automatically visible to and updatable by both programs, even if those programs are compiled separately from one  another.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.4 PROCEDURE DIVISION Sections and Paragraphs                  **
@comment *********************************************************************
@page
@newsection{7.4,PROCEDURE DIVISION Sections and Paragraphs}@p The procedure division is the only one of the COBOL divisions that allows you to create your own sections and paragraphs.  These are collectively referred to as @define{Procedures}, and the names you create for those sections and paragraphs are called @define{Procedure Names}.@p Procedure names are optional in the procedure division and --- when used --- are named entirely according to the needs and whims of the programmer.
@p Procedure names may be up to thirty one (31) characters long and may consist of letters, numbers, dashes and underscores.  A procedure name may neither begin nor end with a dash (-) or underscore (_) character.  This means that "Main", "0100-Read-Transaction" and "17" are all perfectly valid procedure names.
@p There are three circumstances under which the use of certain GnuCOBOL statements or options will require the specification of procedures.  These situations are:
@enumerate
@p @item When @syntaxref{DECLARATIVES} are specified.
@p @item When the @statementref{ENTRY} is being used.
@p @item When any procedure division statement that references procedures is used.  These statements are:
@itemize @bullet
@p @item @syntax{ALTER @term{procedure-name}}
@p @item @syntax{GO TO @term{procedure-name}}
@p @item @syntax{MERGE @dots{} OUTPUT PROCEDURE @term{procedure-name}}
@p @item @syntax{PERFORM @term{procedure-name}}
@p @item @syntax{SORT @dots{} INPUT PROCEDURE @term{procedure-name}} and/or @syntax{SORT @dots{} INPUT PROCEDURE @term{procedure-name}}
@end itemize
@end enumerate
@comment *********************************************************************
@comment ** 7.5 DECLARATIVES                                                **
@comment *********************************************************************
@page
@newsection{7.5,DECLARATIVES}
@diagram{DECLARATIVES,PD-DECLARATIVES,PD-DECLARATIVES,PD-DECLARATIVES}@p The @syntax{DECLARATIVES} area of the procedure division allows the programmer to define a series of "trap" procedures (referred to as declarative procedures) capable of intercepting certain events that may occur at program execution time.  The syntax diagram above shows the format of a single such procedure.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{FOR}, @syntax{ON}, @syntax{PROCEDURE} and @syntax{STANDARD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item @syntax{EC} and @syntax{EXCEPTION CONDITION} are interchangeable.
@comment Semantic Specifications:
@p @item The declaratives area may contain any number of declarative procedures, but no two declarative procedures should be coded to trap the same event.
@p @item The following points apply to the @syntaxidx{USE BEFORE REPORTING} clause:
@enumerate A
@p @item @term{identifier-2} must be a report group.
@p @item At run-time, the declaratives procedure will be executed prior to the processing of the specified report group's presentation; within the procedure you may take either of the following actions:
@itemize @bullet
@p @item You may adjust the value(s) of any items referenced in @syntaxref{SUM} or @syntaxref{SOURCE} clauses in the report group.
@p @item You may execute the @syntaxref{SUPPRESS} statement to squelch the presentation of the specified report group altogether.  Note that you will be suppressing this one specific instance of that group's presentation and not all of them.
@end itemize
@end enumerate
@item The following points apply to the @syntaxidx{USE FOR DEBUGGING} clause:
@enumerate A
@p @item This clause allows you to define a declarative procedure that will be invoked whenever@dots{}
@itemize @bullet
@p @item @dots{}@term{identifier-1} is referenced on any statement.
@p @item @dots{}@term{procedure-name-1} is executed.
@p @item @dots{}any procedure is executed (@syntax{ALL PROCEDURES}).
@end itemize
@item A @syntax{USE FOR DEBUGGING} declarative procedure will be ignored at @i{compilation} time unless @syntax{WITH DEBUGGING MODE} is specified in the @syntaxref{SOURCE-COMPUTER} paragraph.  Neither the compiler's @switchidx{-fdebugging-line} nor @switchidx{-debug} will activate this feature.
@p @item Any @syntax{USE FOR DEBUGGING} declarative procedures will be ignored at @i{execution} time unless the @envvarruntimeref{COB_SET_DEBUG} has been set to a value of "Y", "y" or "1".
@p @item The typical use of a @syntax{USE FOR DEBUGGING} declarative procedure is to display the @register{DEBUG-ITEM}, which will be implicitly and automatically created in your program for you if @syntax{WITH DEBUGGING MODE} is active.
@p The structure of DEBUG-ITEM will be as follows:
@p @example
01  DEBUG-ITEM.
    05 DEBUG-LINE      PIC X(6).
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-NAME      PIC X(31).
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-1     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-2     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-3     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-CONTENTS  PIC X(31).
@end example
@* where@dots{}
@table @asis
@p @item @syntax{DEBUG-LINE}
@dots{} is the program line number of the statement that triggered the declaratives procedure.
@p @item @syntax{DEBUG-NAME}
@dots{} is the procedure name or identifier name that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-1}
@dots{} is the first subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-2}
@dots{} is the second subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-3}
@dots{} is the third subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-CONTENTS}
@dots{} is a (brief) statement of the manner in which the procedure that triggered the declaratives procedure was executed or the first 31 characters of the value of the identifier whose reference triggered the declaratives procedure (the value after the statement was executed).
@end table
@end enumerate
@item The @syntaxidx{USE AFTER STANDARD ERROR PROCEDURE} clause defines a declarative procedure invoked any time a failure is encountered with the specified I/O type (or against the specified file(s)).
@p @item The @syntaxref{GLOBAL} option, if used, allows a declarative procedure to be used across the program containing the @statement{USE} and any subprograms nested within that program.
@p @item Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.
@end enumerate
@comment *********************************************************************
@comment ** 7.6 Common Clauses on Executable Statements                    **
@comment *********************************************************************
@newsection{7.6,Common Clauses on Executable Statements}
@menu
* 7.6.1: AT END + NOT AT END.
* 7.6.2: CORRESPONDING.
* 7.6.3: INVALID KEY + NOT INVALID KEY.
* 7.6.4: ON EXCEPTION + NOT ON EXCEPTION.
* 7.6.5: ON OVERFLOW + NOT ON OVERFLOW.
* 7.6.6: ON SIZE ERROR + NOT ON SIZE ERROR.
* 7.6.7: ROUNDED.
@end menu
@comment *********************************************************************
@comment ** 7.6.1 AT END + NOT AT END                                      **
@comment *********************************************************************
@newsubsection{7.6.1,AT END + NOT AT END}
@diagram{AT END,PD-AT-END,PD-AT-END,None}@p @syntax{AT END} clauses may be specified on @syntaxref{READ}, @syntaxref{RETURN}, @syntaxref{SEARCH} and @syntaxref{SEARCH ALL} statements.
@enumerate
@p @item The following points pertain to the use of these clauses on @syntaxref{READ} and @syntaxref{RETURN} statements:
@enumerate A
@p @item The @syntax{AT END} clause will --- if present --- cause @term{imperative-statement-1} (@pxref{Imperative Statement}) to be executed if the statement fails due to a file status of 10 (end-of-file).  @xref{File Status Codes}, for a list of possible File Status codes.
@p An @syntax{AT END} clause @i{will not detect other non-zero file-status values}.
@p Use a @syntaxref{DECLARATIVES} routine or an explicitly-declared file status field tested after the @syntax{READ} or @syntax{RETURN} to detect error conditions other than end-of-file.
@p @item A @syntax{NOT AT END} clause will cause @term{imperative-statement-2} to be executed if the @syntax{READ} or @syntax{RETURN} attempt is successful.
@end enumerate
@item The following points pertain to the use of these clauses on @syntaxref{SEARCH} and @syntaxref{SEARCH ALL} statements:
@enumerate A
@p @item An @syntax{AT END} clause detects and handles the case where either form of table search has failed to locate an entry that satisfies the search conditions being used.
@p @item The @syntax{NOT AT END} clause is not allowed on either form of table search.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.6.2 CORRESPONDING                                            **
@comment *********************************************************************
@page
@newsubsection{7.6.2,CORRESPONDING}Three GnuCOBOL statements --- @syntaxrefalt{ADD,ADD CORRESPONDING}, @syntaxrefalt{MOVE,MOVE CORRESPONDING} and @syntaxrefalt{SUBTRACT,SUBTRACT CORRESPONDING} support the use of a @syntax{CORRESPONDING} option:
@verbatim
ADD CORRESPONDING group-item-1 TO group-item-2
MOVE CORRESPONDING group-item-1 TO group-item-2
SUBTRACT CORRESPONDING group-item-1 FROM group-item-2
@end verbatim
@* This option allows one or more data items within one group item (@term{group-item-1} --- the first named on the statement) to be paired with correspondingly-named (hence the name) in a second group item (@term{group-item-2} --- the second named on the statement).  The contents of @term{group-item-1} will remain unaffected by the statement while one or more data items within @term{group-item-2} will be changed.
@p In order for @term{data-item-1}, defined subordinate to group item @term{group-item-1} to be a "corresponding" match to @term{data-item-2} which is subordinate to @term{group-item-2}, each of the following must be true:
@enumerate
@p @item Both @term{data-item-1} and @term{data-item-2} must have the same name, and that name may not explicitly or implicitly be @syntax{FILLER}.
@p @item Both @term{data-item-1} and @term{data-item-2}@dots{}
@enumerate A
@p @item @dots{}must exist at the same relative structural "depth" of definition within @term{group-item-1} and @term{group-item-2}, respectively
@p @item @dots{}and all "parent" data items defined within each group item must have identical (but non-@syntax{FILLER}) names.
@end enumerate
@item When used with a @syntax{MOVE} verb@dots{}
@enumerate A
@p @item @dots{}one of @term{data-item-1} or @term{data-item-2} (but not both) is allowed to be a group item
@p @item @dots{}and it must be valid to move @term{data-item-1} TO @term{data-item-2}.
@end enumerate
@item When used with @syntax{ADD} or @syntax{SUBTRACT} verbs, both @term{data-item-1} and @term{data-item-2} must be numeric, elementary, unedited items.
@p @item  Neither @term{data-item-1} nor @term{data-item-2} may be a @syntaxref{REDEFINES} or @syntaxref{RENAMES} of another data item.
@p @item  Neither @term{data-item-1} nor @term{data-item-2} may have an @syntaxref{OCCURS} clause, although either may contain subordinate data items that @i{do} have an @syntax{OCCURS} clause (assuming rule 3a applies)
@end enumerate
@* Observe the definitions of data items "Q" and "Y"@dots{}
@p @example
01  Q.                           01  Y.
    03 X.                            02 A         PIC X(1).
       05 A         PIC 9(1).        02 G1.
       05 G1.                           03 G2.
          10 G2.                           04 B   PIC X(1).
             15 B   PIC X(1).        02 C         PIC X(1).
       05 C.                         02 G3.
          10 FILLER PIC X(1).           03 G5.
       05 G3.                              04 D   PIC X(1).
          10 G4.                        03 G6     PIC X(1).
             15 D   PIC X(1).        02 E         PIC 9(1).
       05 E         PIC X(1).        02 F         PIC X(1).
       05 F         REDEFINES V1     02 G         PIC X(4).
                    PIC X(1).        02 H         OCCURS 4 TIMES
       05 G.                                      PIC X(1).
          10 G6     OCCURS 4 TIMES   66 I         RENAMES E.
                    PIC X(1).        02 J.
       05 H         PIC X(4).           03 K.
       05 I         PIC 9(1).              04 L.
       05 J.                                  05 M.
          10 K.
             15 M   PIC X(1).
@end example
@* The following are the valid CORRESPONDING matches, assuming the statement @syntax{MOVE CORRESPONDING X TO Y} is being executed (there are no valid corresponding matches for @syntax{ADD CORRESPONDING} or @syntax{SUBTRACT CORRESPONDING} because every potential match up violates rule #4):
@p @center A, B, C, G
@p The following are the CORRESPONDING match ups that passed rule #1 (but failed on another rule), and the reasons why they failed.
@p @multitable @columnfractions .1 .9
@headitem Data Item @tab Failure Reason
@item @syntax{D} @tab Fails due to rule #2b
@item @syntax{E} @tab Fails due to rule #3b
@item @syntax{F} @tab Fails due to rule #5
@item @syntax{G1} @tab Fails due to rule #3a
@item @syntax{G2} @tab Fails due to rule #3a
@item @syntax{G3} @tab Fails due to rule #3a
@item @syntax{G4} @tab Fails due to rule #1
@item @syntax{G5} @tab Fails due to rule #1
@item @syntax{G6} @tab Fails due to rule #6
@item @syntax{H} @tab Fails due to rule #6
@item @syntax{I} @tab Fails due to rule #5
@item @syntax{J} @tab Fails due to rule #3a
@item @syntax{K} @tab Fails due to rule #3a
@item @syntax{L} @tab Fails due to rule #1
@item @syntax{M} @tab Fails due to rule #2a
@end multitable
@comment *********************************************************************
@comment ** 7.6.3 INVALID KEY + NOT INVALID KEY                            **
@comment *********************************************************************
@newsubsection{7.6.3,INVALID KEY + NOT INVALID KEY}
@diagram{INVALID KEY,PD-INVALID-KEY,PD-INVALID-KEY,None}@p @syntax{INVALID KEY} clauses may be specified on @syntaxref{DELETE}, @syntaxrefalt{READ,Random READ}, @syntaxref{REWRITE}, @syntaxref{START} and @syntaxref{WRITE} statements.
@p Specification of an @syntax{INVALID KEY} clause will allow your program to trap an I/O failure condition (with an I/O error code in the file's @syntaxrefalt{FILE-STATUS,SELECT} field) that has occurred due to a record-not-found condition and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).
@p An optional @syntaxidx{NOT INVALID KEY} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 7.6.4 ON EXCEPTION + NOT ON EXCEPTION                          **
@comment *********************************************************************
@newsubsection{7.6.4,ON EXCEPTION + NOT ON EXCEPTION}
@diagram{ON EXCEPTION,PD-ON-EXCEPTION,PD-ON-EXCEPTION,None}@p @syntax{EXCEPTION} clauses may be specified on @syntaxref{ACCEPT}, @syntaxref{CALL} and @syntaxref{DISPLAY} statements.
@p Specification of an exception clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2).  The program may also be terminated, depending upon the type and severity of the error.
@p An optional @syntaxidx{NOT ON EXCEPTION} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 7.6.5 ON OVERFLOW + NOT ON OVERFLOW                            **
@comment *********************************************************************
@newsubsection{7.6.5,ON OVERFLOW + NOT ON OVERFLOW}
@diagram{ON OVERFLOW,PD-ON-OVERFLOW,PD-ON-OVERFLOW,None}@p @syntax{OVERFLOW} clauses may be specified on @syntaxref{CALL}, @syntaxref{STRING} and @syntaxref{UNSTRING} statements.
@p An @syntax{ON OVERFLOW} clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2).  The program may also be terminated, depending upon the type and severity of the error.
@p An optional @syntaxidx{NOT ON OVERFLOW} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 7.6.6 ON SIZE ERROR + NOT ON SIZE ERROR                        **
@comment *********************************************************************
@newsubsection{7.6.6,ON SIZE ERROR + NOT ON SIZE ERROR}
@diagram{ON SIZE ERROR,PD-ON-SIZE-ERROR,PD-ON-SIZE-ERROR,None}@p @syntax{SIZE ERROR} clauses may be included on @syntaxref{ADD}, @syntaxref{COMPUTE}, @syntaxref{DIVIDE}, @syntaxref{MULTIPLY} and @syntaxref{SUBTRACT} statements.
@p Including an @syntax{ON SIZE ERROR} clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  Field size overflow conditions occur silently, usually without any runtime messages being generated, even though such events rarely lend themselves to generating correct results.  Division by zero errors, when no @syntax{ON SIZE ERROR} clause exists, will produce an error message (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2) and will also abort the program.
@p An optional @syntaxidx{NOT ON SIZE ERROR} clause will cause @term{imperative-statement-2} to be executed if the arithmetic statement's execution was successful.
@comment *********************************************************************
@comment ** 7.6.7 ROUNDED                                                  **
@comment *********************************************************************
@newsubsection{7.6.7,ROUNDED}
@diagram{ROUNDED,PD-ROUNDED,PD-ROUNDED,None}@p GnuCOBOL provides for control over the final rounding process applied to the receiving fields on all arithmetic verbs.  Each of the arithmetic statements (@syntaxref{ADD}, @syntaxref{COMPUTE}, @syntaxref{DIVIDE}, @syntaxref{MULTIPLY} and @syntaxref{SUBTRACT}) statements allow an optional @syntax{ROUNDED} clause to be applied to each receiving data item.
@p The following rules apply to the rounding behaviour induced by this clause.
@enumerate
@p @item Rounding only applies when the result being saved to a receiving field with a @syntax{ROUNDED} clause is a non-integer value.
@p @item Absence of a @syntax{ROUNDED} clause is the same as specifying @syntax{ROUNDED MODE IS TRUNCATION}.
@p @item Use of a @syntax{ROUNDED} clause without a @syntax{MODE} specification is the same as specifying @syntax{ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO}.
@end enumerate
@* The behaviour of the eight different rounding modes is defined in the following table.  Note that a "@dots{}" indicates the last digit repeats.  The examples assume an integer receiving field.
@p @table @asis
@item @syntax{AWAY-FROM-ZERO}
@p Rounding is to the nearest value of larger magnitude.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -4 @tab +3.499@dots{} @result{} +4
@item -2.500 @result{} -3 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -3 @tab +2.499@dots{} @result{} +3
@end multitable
@item @syntax{NEAREST-AWAY-FROM-ZERO}
@p Rounding is to the nearest value (larger or smaller). If two values are equally near, the value with the larger absolute value is selected.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -3 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{NEAREST-EVEN}
@p Rounding is to the nearest value (larger or smaller).  If two values are equally near, the value whose rightmost digit is @i{even} is selected. This mode is sometimes called "Banker's rounding".
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{NEAREST-TOWARD-ZERO}
@p Rounding is to the nearest value (larger or smaller).  If two values are equally near, the value with the smaller absolute value is selected.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -3 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{PROHIBITED}
@p No rounding is performed.  If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the @syntaxrefalt{ACCEPT,ACCEPT FROM Runtime-Info} statement) and the results of the operation are undefined.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} Undefined @tab +3.510 @result{} Undefined
@item -3.500 @result{} Undefined @tab +3.500 @result{} Undefined
@item -3.499@dots{} @result{} Undefined @tab +3.499@dots{} @result{} Undefined
@item -2.500 @result{} Undefined @tab +2.500 @result{} Undefined
@item -2.499@dots{} @result{} Undefined @tab +2.499@dots{} @result{} Undefined
@end multitable
@item @syntax{TOWARD-GREATER}
@p Rounding is toward the nearest value whose algebraic value is larger.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -3 @tab +3.510 @result{} +4
@item -3.500 @result{} -3 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +4
@item -2.500 @result{} -2 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +3
@end multitable
@item @syntax{TOWARD-LESSER}
@p Rounding is toward the nearest value whose algebraic value is smaller.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +3
@item -3.500 @result{} -4 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -4 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -3 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -3 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{TRUNCATION}
@p Rounding is to the nearest value whose magnitude is smaller.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -3 @tab +3.510 @result{} +3
@item -3.500 @result{} -3 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@end table
@comment *********************************************************************
@comment ** 7.7 Special Registers                                          **
@comment *********************************************************************
@page
@newsection{7.7,Special Registers}GnuCOBOL, like other COBOL dialects, includes a number of data items that are automatically available to a programmer without the need to actually define them in the data division.  COBOL refers to such items as registers or special registers.  The special registers available to a GnuCOBOL program are as follows:
@table @asis
@p @item @syntax{COB-CRT-STATUS}
@p PIC 9(4) --- This is the default data item allocated for use by the @statementrefalt{ACCEPT @term{screen-data-item},ACCEPT screen-data-item}, if no @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} clause was specified..
@p @item @syntax{DEBUG-ITEM}
@p Group Item --- A group item in which debugging information generated by a @syntax{USE FOR DEBUGGING} section in the declaratives area of the procedure division will place information documenting why the @syntax{USE FOR DEBUGGING} procedure was invoked.  Consult the @syntaxref{DECLARATIVES} documentation for information on the structure of this register.
@p @item @syntax{LINAGE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each selected file having a @syntaxrefalt{LINAGE,File/Sort-Description} clause.  If there are multiple files whose file descriptions have @syntax{LINAGE} clauses, any explicit references to this register will require qualification (using @syntax{OF file-name}).  The value of this register will be the current logical line number within the page body.  The value of this register cannot be modified.
@p @item @syntax{LINE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each report defined in the program (via an @syntaxrefalt{RD,REPORT SECTION}).  If there are multiple reports, any explicit references to this register not made in the report section will require qualification (@syntax{OF report-name}).  The value of this register will be the current logical line number on the current page.  The value of this register cannot be modified.
@p @item @syntax{NUMBER-OF-CALL-PARAMETERS}
@p BINARY-LONG SIGNED --- This register contains the number of arguments passed to a subroutine --- the same value that would be returned by the @subpgmref{C$NARG}.  Its value will be zero when referenced in a main program.  This register, when referenced from within a user-defined function, returns a value of one (1) if the function has any number of arguments and a zero if it has no arguments.
@p @item @syntax{PAGE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each report having an @syntaxrefalt{RD,REPORT SECTION}.  If there are multiple such reports, any explicit references to this register not made in the report section will require qualification ( @syntax{OF report-name}).  The value of this register will be the current report page number.  The value of this register cannot be modified.
@p @item @syntax{RETURN-CODE}
@p BINARY-LONG SIGNED --- This register provides a numeric data item into which a subroutine may @syntaxref{MOVE} a value (which will then be available to the calling program) prior to transferring control back to the program that called it, or into which a main program may @syntax{MOVE} a value before returning control to the operating system.  Many built-in subroutines will return a value using this register.  These values are --- by convention --- used to signify success (usually with a value of 0) or failure (usually with a non-zero value) of the process the program was attempting to perform.  This register may also be modified by a subprogram as a result of that subprogram's use of the @syntaxrefalt{RETURNING,PROCEDURE DIVISION RETURNING} clause.
@p @item @syntax{SORT-RETURN}
@p BINARY-LONG SIGNED --- This register is used to report the success/fail status of a @syntaxref{RELEASE} or @syntaxref{RETURN} statement.  A value of 0 is reported on success.  A value of 16 denotes failure.  An @syntaxrefalt{AT END,AT END + NOT AT END} condition on a @syntax{RETURN} is not considered a failure.
@p @item @syntax{WHEN-COMPILED}
@p PIC X(16) --- This register contains the date and time the program was compiled in the format "mm/dd/yyhh.mm.ss".  Note that only a two-digit year is provided.
@comment *   1.3.21: LENGTH OF.
@comment *********************************************************************
@comment ** 1.3.21 LENGTH OF                                                **
@comment *********************************************************************
@comment @newsubsection{1.3.21,LENGTH OF}
@page
@diagram{LENGTH OF,PD-LENGTH-OF,PD-LENGTH-OF,None}
@p Alphanumeric literals and identifiers may optionally be prefixed with the @syntax{LENGTH OF} clause.  The compile-time value generated by this clause will be the number of bytes in the alphanumeric literal or the defined size (in bytes) of the identifier.
@enumerate
@p @item The reserved word @syntax{OF} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p Here is an example.  The following two GnuCOBOL statements both display the same result (27):
@p @example
01  Demo-Identifier          PIC X(27).
...
    DISPLAY LENGTH OF "This is a LENGTH OF Example"
    DISPLAY LENGTH OF Demo-Identifier
@end example
@item The @syntax{LENGTH OF} clause on a literal or identifier reference may generally be used anywhere a numeric literal might be specified, with the following exceptions:
@itemize @bullet
@p @item As part of the @syntax{FROM} clause of a @syntaxref{WRITE} or @statementref{RELEASE}.
@p @item As part of the @syntax{TIMES} clause of a @statementref{PERFORM}.
@end itemize
@end enumerate
@end table
@comment *********************************************************************
@comment ** 7.8 GnuCOBOL Statements                                       **
@comment *********************************************************************
@page
@newsection{7.8,GnuCOBOL Statements}
@menu
* 7.8.1:  ACCEPT
@detailmenu
*   7.8.1.1: ACCEPT FROM CONSOLE
*   7.8.1.2: ACCEPT FROM COMMAND-LINE
*   7.8.1.3: ACCEPT FROM ENVIRONMENT
*   7.8.1.4: ACCEPT screen-data-item
*   7.8.1.5: ACCEPT FROM DATE/TIME
*   7.8.1.6: ACCEPT FROM Screen-Info
*   7.8.1.7: ACCEPT FROM Runtime-Info
*   7.8.1.8: ACCEPT OMITTED
*   7.8.1.9: ACCEPT FROM EXCEPTION-STATUS
@end detailmenu
* 7.8.2:  ADD
@detailmenu
*   7.8.2.1: ADD TO
*   7.8.2.2: ADD GIVING
*   7.8.2.3: ADD CORRESPONDING
@end detailmenu
* 7.8.3:  ALLOCATE
* 7.8.4:  ALTER
* 7.8.5:  CALL
* 7.8.6:  CANCEL
* 7.8.7:  CLOSE
* 7.8.8:  COMMIT
* 7.8.9:  COMPUTE
* 7.8.10: CONTINUE
* 7.8.11: DELETE
* 7.8.12: DISPLAY
@detailmenu
*   7.8.12.1: DISPLAY UPON device
*   7.8.12.2: DISPLAY UPON COMMAND-LINE
*   7.8.12.3: DISPLAY UPON ENVIRONMENT-NAME
*   7.8.12.4: DISPLAY screen-data-item
@end detailmenu
* 7.8.13: DIVIDE
@detailmenu
*   7.8.13.1: DIVIDE INTO
*   7.8.13.2: DIVIDE INTO GIVING
*   7.8.13.3: DIVIDE BY GIVING
@end detailmenu
* 7.8.14: ENTRY
* 7.8.15: EVALUATE
* 7.8.16: EXIT
* 7.8.17: FREE
* 7.8.18: GENERATE
* 7.8.19: GOBACK
* 7.8.20: GO TO
@detailmenu
*   7.8.20.1: Simple GO TO
*   7.8.20.2: GO TO DEPENDING ON
@end detailmenu
* 7.8.21: IF
* 7.8.22: INITIALIZE
* 7.8.23: INITIATE
* 7.8.24: INSPECT
* 7.8.25: MERGE
* 7.8.26: MOVE
@detailmenu
*   7.8.26.1: Simple MOVE
*   7.8.26.2: MOVE CORRESPONDING
@end detailmenu
* 7.8.27: MULTIPLY
@detailmenu
*   7.8.27.1: MULTIPLY BY
*   7.8.27.2: MULTIPLY GIVING
@end detailmenu
* 7.8.28: OPEN
* 7.8.29: PERFORM
@detailmenu
*   7.8.29.1: Procedural PERFORM
*   7.8.29.2: Inline PERFORM
@end detailmenu
* 7.8.30: READ
@detailmenu
*   7.8.30.1: Sequential READ
*   7.8.30.2: Random READ
@end detailmenu
* 7.8.31: READY TRACE
* 7.8.32: RELEASE
* 7.8.33: RESET TRACE
* 7.8.34: RETURN
* 7.8.35: REWRITE
* 7.8.36: ROLLBACK
* 7.8.37: SEARCH
* 7.8.38: SEARCH ALL
* 7.8.39: SET
@detailmenu
*   7.8.39.1: SET ENVIRONMENT
*   7.8.39.2: SET Program-Pointer
*   7.8.39.3: SET ADDRESS
*   7.8.39.4: SET Index
*   7.8.39.5: SET UP/DOWN
*   7.8.39.6: SET Condition Name
*   7.8.39.7: SET Switch
*   7.8.39.8: SET ATTRIBUTE
*   7.8.39.9: SET LAST EXCEPTION
@end detailmenu
* 7.8.40: SORT
@detailmenu
*   7.8.40.1: File-Based SORT
*   7.8.40.2: Table SORT
@end detailmenu
* 7.8.41: START
* 7.8.42: STOP
* 7.8.43: STRING
* 7.8.44: SUBTRACT
@detailmenu
*   7.8.44.1: SUBTRACT FROM
*   7.8.44.2: SUBTRACT GIVING
*   7.8.44.3: SUBTRACT CORRESPONDING
@end detailmenu
* 7.8.45: SUPPRESS
* 7.8.46: TERMINATE
* 7.8.47: TRANSFORM
* 7.8.48: UNLOCK
* 7.8.49: UNSTRING
* 7.8.50: WRITE
@end menu
@comment *********************************************************************
@comment ** 7.8.1 ACCEPT                                                   **
@comment *********************************************************************
@newsubsection{7.8.1,ACCEPT}
@menu
* 7.8.1.1: ACCEPT FROM CONSOLE
* 7.8.1.2: ACCEPT FROM COMMAND-LINE
* 7.8.1.3: ACCEPT FROM ENVIRONMENT
* 7.8.1.4: ACCEPT screen-data-item
* 7.8.1.5: ACCEPT FROM DATE/TIME
* 7.8.1.6: ACCEPT FROM Screen-Info
* 7.8.1.7: ACCEPT FROM Runtime-Info
* 7.8.1.8: ACCEPT OMITTED
* 7.8.1.9: ACCEPT FROM EXCEPTION-STATUS
@end menu
@comment *********************************************************************
@comment ** 7.8.1.1 ACCEPT FROM CONSOLE                                    **
@comment *********************************************************************
@newunit{7.8.1.1,ACCEPT FROM CONSOLE}
@diagram{ACCEPT FROM CONSOLE,PD-ACCEPT-1,PD-ACCEPT-1,None}@p This format of the @statement{ACCEPT} is used to read a value from the console window or the standard input device and store it into a data item (@term{identifier-1}).
@enumerate
@comment Syntactical Specifications:
@p @item If no @syntax{FROM} clause is specified, @syntax{FROM CONSOLE} is assumed.
@comment Semantic Specifications:
@p @item The specified @term{mnemonic-name-1} must either be one of the built-in device names @syntax{CONSOLE}, @syntax{STDIN}, @syntax{SYSIN} or @syntax{SYSIPT}, or a user-defined (@pxref{SPECIAL-NAMES}) mnemonic name @i{attached} to one of those four device names.
@p @item Input will be read either from the console window (@syntax{CONSOLE}) or from the system-standard input (pipe 0 = @syntax{STDIN}, @syntax{SYSIN} or @syntax{SYSIPT}) and will be saved in @term{identifier-1}.
@p @item If @term{identifier-1} is a numeric data item, the character value read from the console or standard-input device will be parsed according to the rules for input to the @intrinsicref{NUMVAL}, except that none of the trailing sign formats are honoured.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.2 ACCEPT FROM COMMAND-LINE                               **
@comment *********************************************************************
@page
@newunit{7.8.1.2,ACCEPT FROM COMMAND-LINE}
@diagram{ACCEPT FROM COMMAND-LINE,PD-ACCEPT-2,PD-ACCEPT-2,None}@p This format of the @statement{ACCEPT} is used to retrieve information from the programs command-line.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item When you accept from the @syntaxidx{COMMAND-LINE} option, you will retrieve the entire set of arguments entered on the command line that executed the program, exactly as they were specified.  Parsing that returned data into its meaningful information will be your responsibility.
@p @item By accepting from @syntaxidx{ARGUMENT-NUMBER}, you will be asking the GnuCOBOL run-time system to parse the arguments from the command-line and return the number of arguments found.  Parsing will be conducted according to the following rules:
@enumerate A
@p @item Arguments will be separated by treating spaces and/or tab characters as the delimiters between arguments.  The number of such delimiters separating two non-blank argument values is irrelevant.
@p @item Strings enclosed in double-quote characters (") will be treated as a single argument, regardless of how many spaces or tab characters (if any) might be embedded within those quotation characters.
@p @item On Windows systems, single-quote, or apostrophe characters (') will be treated just like any other data character and will NOT delineate argument strings.
@end enumerate
@item By accepting from @syntaxidx{ARGUMENT-VALUE}, you will be asking the GnuCOBOL run-time system to parse the arguments from the command-line and return the "current" argument.  You specify which argument number is "current" via the @syntax{ARGUMENT-NUMBER} option on the @statementrefalt{DISPLAY,DISPLAY UPON COMMAND-LINE}.  Parsing of arguments will be conducted according to the rules set forth above.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to retrieve an @syntax{ARGUMENT-VALUE}.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.3 ACCEPT FROM ENVIRONMENT                                **
@comment *********************************************************************
@page
@newunit{7.8.1.3,ACCEPT FROM ENVIRONMENT}
@diagram{ACCEPT FROM ENVIRONMENT,PD-ACCEPT-3,PD-ACCEPT-3,None}@p This format of the @statement{ACCEPT} is used to retrieve environment variable values.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item By accepting from @syntaxidx{ENVIRONMENT-VALUE}, you will be asking the GnuCOBOL run-time system to retrieve the value of the environment variable whose name is currently in the @syntaxidx{ENVIRONMENT-NAME} register.  A value may be placed into the @syntax{ENVIRONMENT-NAME} register using the @syntax{ENVIRONMENT-NAME} option of the @statementrefalt{DISPLAY,DISPLAY UPON ENVIRONMENT-NAME}.
@p @item A simpler approach to retrieving an environment variables value is to use the @syntaxidx{ENVIRONMENT} option, where you specify the environment variable whose value is to be retrieved right on the @syntax{ACCEPT} statement itself.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to an attempt to retrieve the value of a non-existent environment variable or the successful retrieval of an environment variable's value, respectively.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.4 ACCEPT screen-data-item                                **
@comment *********************************************************************
@page
@newunit{7.8.1.4,ACCEPT screen-data-item}
@diagram{ACCEPT screen-data-item,PD-ACCEPT-4,PD-ACCEPT-4,PD-ACCEPT-4}@p This format of the @statement{ACCEPT} is used to retrieve data from a formatted console window screen.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{IS}, @syntax{NUMBER} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{COLUMN}, @syntax{COL} and @syntax{POSITION} are interchangeable.
@p @item The reserved words @syntax{TIMEOUT} and @syntax{TIME-OUT} are interchangeable.
@comment Semantic Specifications:
@p @item If @term{identifier-1} is defined in the @syntaxref{SCREEN SECTION}, any @syntax{AT}, @term{Attribute-Specification}, @syntax{LOWER}, @syntax{UPPER} or @syntax{SCROLL} clauses will be ignored.  In these cases, an implied @syntaxrefalt{DISPLAY,DISPLAY screen-data-item} of @term{identifier-1} will occur before input is accepted.  Coding an explicit @syntax{DISPLAY identifier-1} before an @syntax{ACCEPT identifier-1} is redundant and will incur the performance penalty of painting the screen contents twice.
@p @item The various @syntax{AT} clauses provide a means of positioning the cursor to a specific spot on the screen before the screen is read.  One or the other (but not both) may be used, as follows:
@enumerate A
@p @item The @syntax{LINE} and @syntax{COLUMN} clauses provide one mechanism for specifying the line and column position to which the cursor will be positioned before allowing the user to enter data.  In the absence of one or the other, a value of 1 will be assumed for the one that is missing.  The author's personal preference, however, is to explicitly code both.
@p @item The @term{literal-3} or @term{identifier-4} value, if specified, must be a four- or six-digit value with the 1st half of the number indicating the line where the cursor should be positioned and the second half indicating the column.  You may code only one of each clause on any @syntax{ACCEPT}.
@end enumerate
@item @syntax{WITH} options (including the various individual @term{Attribute-Specifications}) should be coded only once.
@p @item The following @term{Attribute-Specification} clauses are allowed on the @syntax{ACCEPT} statement --- these are the same as those allowed for @syntax{SCREEN SECTION} data items.  A particular @term{Attribute-Specification} may be used only once in any @syntax{ACCEPT}:
@itemize @bullet
@p @item @syntaxref{AUTO}, @syntaxref{AUTO-SKIP}, @syntaxref{AUTOTERMINATE}, @syntax{TAB}
@p @item @syntaxref{BACKGROUND-COLOR}
@p @item @syntaxref{BEEP}, @syntaxref{BELL}
@p @item @syntaxref{BLINK}
@p @item @syntaxref{FOREGROUND-COLOR}
@p @item @syntaxref{FULL}, @syntaxref{LENGTH-CHECK}
@p @item @syntaxref{HIGHLIGHT}
@p @item @syntaxref{LEFTLINE}
@p @item @syntaxref{LOWLIGHT}
@p @item @syntaxref{OVERLINE}
@p @item @syntaxref{PROMPT}
@p @item @syntaxref{PROTECTED}
@p @item @syntaxref{REQUIRED}, @syntaxref{EMPTY-CHECK}
@p @item @syntaxref{REVERSE-VIDEO}
@p @item @syntaxref{SECURE}, @syntaxref{NO-ECHO}
@p @item @syntaxref{UNDERLINE}
@end itemize
@item The @syntaxidx{SCROLL} option will cause the entire contents of the screen to be scrolled @syntax{UP} or @syntax{DOWN} by the specified number of lines before any value is displayed on the screen.  It is syntactically allowable to specify a @syntax{SCROLL UP} clause as well as a @syntax{SCROLL DOWN} clause.  In such an instance, it is the last one specified that will be honoured.  If no @syntax{LINES} specification is made, @syntax{1 LINE} will be assumed.
@p @item The @syntaxidx{TIMEOUT} option will cause the @syntax{ACCEPT} to wait no more than the specified number of seconds for input.  The wait count may be specified as a positive integer or a numeric data item with a positive value.
@p @item This format of the @syntax{ACCEPT} statement will be terminated by any of the following events:
@enumerate A
@p @item When the 'Enter' key is pressed.
@p @item Expiration of the @syntax{TIMEOUT} timer --- this will be treated as if the Enter key had been pressed with no data being entered.
@p @item When a function key (Fn) is pressed.
@p @item The pressing of the PgUp or PgDn keys, if the @envvarruntimeref{COB_SCREEN_EXCEPTIONS} is set to any non-blank value.
@p @item The pressing of the Esc key if @i{both} the @envvarruntime{COB_SCREEN_ESC} as well as @envvarruntime{COB_SCREEN_EXCEPTIONS} are set to any non-blank value.
@p @item The pressing of the Up-arrow, Down-Arrow or PrtSc (Print Screen) keys.  These keys are not detectable on Windows systems, however.
@end enumerate
@item The following apply when @term{identifier-1} is defined in the @syntax{SCREEN SECTION}:
@enumerate A
@p @item Alphanumeric data entered into @term{identifier-1} or any screen data item subordinate to it @i{must} be consistent with the @syntaxref{PICTURE} clause of that item.  This will be enforced at runtime by the @syntax{ACCEPT} statement.
@p @item If @term{identifier-1} or any screen data item subordinate to it are defined as numeric, entered data must be acceptable as @intrinsicref{NUMVAL} input (no decimal points are allowed, however).  The value stored into the screen data item will be as if the input were passed to that function.
@p @item If @term{identifier-1} or any screen data item subordinate to it are defined as numeric edited, entered data must be acceptable as @intrinsicref{NUMVAL-C} input (again, no decimal points are allowed).  The value stored into the screen data item will be as if the input were passed to that function.
@end enumerate
@item The following apply when @term{identifier-1} is @i{not} defined in the @syntax{SCREEN SECTION}:
@enumerate A
@p @item Alphanumeric data entered into @term{identifier-1} @i{should} be consistent with the @syntaxref{PICTURE} clause of that item, although that will not be enforced by the @syntax{ACCEPT} statement.  You may use @syntaxref{Class Conditions} after the data is accepted to enforce the data type.
@p @item If @term{identifier-1} is defined as numeric, entered data must be acceptable as @intrinsicref{NUMVAL} input (no decimal points are allowed, however).  The value stored into @term{identifier-1} will be as if the input were passed to that function.
@p @item If @term{identifier-1} is defined as numeric edited, entered data must be acceptable as @intrinsicref{NUMVAL-C} input (again, no decimal points are allowed).  The value stored into @term{identifier-1} will be as if the input were passed to that function.
@end enumerate
@item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of the screen I/O attempt.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@p After this format of the @syntax{ACCEPT} statement is executed, the program's @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} identifier will be populated with one of the following:
@p @anchoridx{CRT STATUS Codes}
@multitable @columnfractions .15 .85
@headitem Code @tab Meaning
@item 0000 @tab ENTER key pressed
@item 1001--1064 @tab F1--F64, respectively, were pressed
@item 2001 @tab PgUp was pressed
@item 2002 @tab PgDn,was pressed
@item 2003 @tab Up Arrow was pressed
@item 2004 @tab Down-Arrow was pressed
@item 2005 @tab Esc was pressed
@item 2006 @tab PrtSc (Print Screen) was pressed
@item 2007 @tab Tab
@item 2008 @tab Back Tab
@item 2009 @tab Key Left
@item 2010 @tab Key Right
@item 8000 @tab NO Field
@item 8001 @tab Time Out
@item 9000 @tab Fatal
@item 9001 @tab Max Field
@end multitable
@item The actual key pressed to generate a function key (Fn) will depend on the type of terminal device you're using (PC, Macintosh, VT100, etc.) and what type of enhanced display driver was configured with the version of GnuCOBOL you're using.  For example, on a GnuCOBOL build for a Windows PC using MinGW and PDCurses, F1-F12 are the actual F-keys on the PC keyboard, F13-F24 are entered by shifting the F-keys, F25-F36 are entered by holding Ctrl while pressing an F-key and F37-F48 are entered by holding Alt while pressing an F-key.  On the other hand, a GnuCOBOL implementation built for Windows using Cygwin and NCurses treats the PCs F1-F12 keys as the actual F1-F12, while shifted F-keys will enter F11-F20.  With Cygwin/NCurses, Ctrl- and Alt-modified F-keys aren't recognized.  Neither are Shift-F11 or Shift-F12.
@p @item Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings.  Windows Cygwin/NCurses builds recognize numeric keypad inputs properly.  Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.
@item The optional @syntax{EXCEPTION-STATUS} clause may be used to detect exceptions from a prior arithmetic verb such as COMPUTE to recover any errors produced. These are recovered using the function @syntax{EXCEPTION-STATUS}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.5 ACCEPT FROM DATE/TIME                                  **
@comment *********************************************************************
@page
@newunit{7.8.1.5,ACCEPT FROM DATE/TIME}
@diagram{ACCEPT FROM DATE/TIME,PD-ACCEPT-5,PD-ACCEPT-5,None}@p This format of the @statement{ACCEPT} is used to retrieve the current system date, time or current day of the week and store it into a data item.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The data retrieved from the system and the format in which it is structured will vary, as follows:
@multitable @columnfractions .3 .5 .2
@p @headitem Syntax @tab Data Retrieved @tab Format
@item @syntax{DATE} @tab Current date in Gregorian form @tab yymmdd
@item @syntax{DATE YYYYMMDD} @tab Current date in Gregorian form @tab yyyymmdd
@item @syntax{DAY} @tab Current date in Julian form @tab yyddd
@item @syntax{DAY YYYYDDD} @tab Current date in Julian form @tab yyyyddd
@item @syntax{TIME} @tab Time, including hundredths of a second (nn) @tab hhmmssnn
@end multitable
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.6 ACCEPT FROM Screen-Info                                **
@comment *********************************************************************
@page
@newunit{7.8.1.6,ACCEPT FROM Screen-Info}
@diagram{ACCEPT FROM Screen-Info,PD-ACCEPT-6,PD-ACCEPT-6,None}@p This format of the @statement{ACCEPT} is used to retrieve information about the console window or about the user's interactions with it.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{LINES} and @syntax{LINE-NUMBER} are interchangeable.
@p @item The reserved words @syntax{COLS} and @syntax{COLUMNS} are interchangeable.
@comment Semantic Specifications:
@p @item The following points pertain to the use of the @syntaxidx{LINES} and @syntaxidx{COLUMNS} options:
@enumerate A
@p @item The @syntaxidx{LINES} and @syntaxidx{COLUMNS} options will retrieve the respective components of the size of the console display.
@p @item When the console is running in a windowed environment, this will be the sizing of the window in which the program is executing, in terms of horizontal (@syntax{COLUMNS}) or vertical (@syntax{LINES}) character counts --- not pixels.
@p @item When the system is not running a windowing environment, the physical console screen attributes will be returned.
@p @item Values of 0 will be returned if GnuCOBOL was not generated to include screen I/O.
@p @item See the documentation on the @subpgmref{CBL_GET_SCR_SIZE} for another way to retrieve this information.
@end enumerate
@item The @syntaxidx{ESCAPE KEY} option may be used after the @statementref{ACCEPT FROM Screen-Info} has executed.  The result returned will be the four-digit @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} identifier value.  @xref{CRT STATUS Codes}, for the specific code values.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.7 ACCEPT FROM Runtime-Info                               **
@comment *********************************************************************
@page
@newunit{7.8.1.7,ACCEPT FROM Runtime-Info}
@diagram{ACCEPT FROM Runtime-Info,PD-ACCEPT-7,PD-ACCEPT-7,None}@p This format of the @statement{ACCEPT} is used to retrieve run-time information such as the most-recent error exception code and the current user's user name.
@enumerate
@comment Syntactical Specifications:
@p @item The following points pertain to the use of the @syntaxidx{EXCEPTION STATUS} option:
@enumerate A
@p @item @term{identifier-1} must be defined as a @syntax{PIC X(4)} item.
@p @item @xref{Error Exception Codes}, for a complete list of the exception codes and their meanings.
@p @item An alternative to the use of @syntax{ACCEPT FROM Runtime-Info} is to use the @intrinsicref{EXCEPTION-STATUS}.
@end enumerate
@item The following points pertain to the use of the @syntaxidx{USER NAME} option:
@enumerate A
@p @item The returned result is the userid that was used to login to the system with, and not any actual first and/or last name of the user in question (unless, of course, that is the information used as a logon id).
@p @item @term{identifier-1} should be defined large enough to receive the longest user-name on the system.
@p @item If insufficient space is allocated, the returned value will be truncated.
@p @item If excess space is allocated, the returned value will be padded with spaces (to the right).
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.8 ACCEPT OMITTED                                         **
@comment *********************************************************************
@page
@newunit{7.8.1.8,ACCEPT OMITTED}
@diagram{ACCEPT OMITTED,PD-ACCEPT-8,PD-ACCEPT-8,None}@p This format of the @statement{ACCEPT} will wait for a keyboard event that terminates input; function keys, or Enter/Return, among others. CRT STATUS (COB-CRT-STATUS @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} if not explicitly defined) is set with the keycode, listed in copy/screenio.cpy. It also handles a few other keycode terminations not normally used to complete an extended accept.
@enumerate
@comment Syntactical Specifications:
@p @item The following are examples of keycodes that can be used:
@verbatim
COB-SCR-INSERT
COB-SCR-DELETE
COB-SCR-BACKSPACE
COB-SCR-KEY-HOME
COB-SCR-KEY-END
@end verbatim
@p @item You can used extended attributes, useful for setting timeouts or positioning.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.1.9 ACCEPT FROM EXCEPTION-STATUS                           **
@comment *********************************************************************
@page
@newunit{7.8.1.9,ACCEPT FROM EXCEPTION-STATUS}
@diagram{ACCEPT FROM EXCEPTION-STATUS,PD-ACCEPT-9,PD-ACCEPT-9,None}@p This format of the @statement{ACCEPT} will receive the status for any exceptions resulting from a previous valid verb.
@enumerate
@comment Syntactical Specifications:
@p @item The following is an example of usage:
@verbatim
 In WS:
 01  exception-status  pic 9(4).
..
 In PD:

 ACCEPT unexpected-rounding  FROM EXCEPTION-STATUS
 IF unexpected-rounding NOT EQUAL "0000" THEN
    DISPLAY "Unexpected rounding. Code " unexpected-rounding
             UPON SYSERR
 END-IF
@end verbatim
@end enumerate
@comment *********************************************************************
@comment ** 7.8.2 ADD                                                      **
@comment *********************************************************************
@page
@newsubsection{7.8.2,ADD}
@menu
* 7.8.2.1: ADD TO
* 7.8.2.2: ADD GIVING
* 7.8.2.3: ADD CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 7.8.2.1 ADD TO                                                 **
@comment *********************************************************************
@newunit{7.8.2.1,ADD TO}
@diagram{ADD TO,PD-ADD-1,PD-ADD-1,None}@p This format of the @statement{ADD} generates an intermediate arithmetic sum of the values of all @term{identifier-1} and @term{literal-1}) items. The value of each @term{identifier-2} will be replaced, in turn, by the sum of that @term{identifier-2}s value and the intermediate sum.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while @term{literal-1} must be a numeric literal.
@p @item An @term{identifier-1} data item may also be coded as an @term{identifier-2} --- note, however, that the value of such a data item will therefore be included @i{twice} in the result.
@comment Semantic Specifications:
@p @item The contents of each @term{identifier-1} will remain unchanged by this statement.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.2.2 ADD GIVING                                             **
@comment *********************************************************************
@page
@newunit{7.8.2.2,ADD GIVING}
@diagram{ADD GIVING,PD-ADD-2,PD-ADD-2,None}@p This format of the @syntax{ADD} statement generates the arithmetic sum of the values of all @term{identifier-1}, @term{literal-1}) and @term{identifier-2} (if any) items and then saves that sum to each @term{identifier-3}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while @term{literal-1} must be a numeric literal; @term{identifier-3} may be either a numeric or numeric edited data item.
@p @item An @term{identifier-1} or @term{identifier-2} data item may be used as an @term{identifier-3}, if desired.
@comment Semantic Specifications:
@p @item The contents of each @term{identifier-1} and @term{identifier-2} will remain unchanged by this statement, unless they happen to also be specified as an @term{identifier-3}.
@p @item The current value in each @term{identifier-3} at the start of the statement's execution is irrelevant, since the contents of each @term{identifier-3} will simply be replaced with the computed sum.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-3} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.2.3 ADD CORRESPONDING                                      **
@comment *********************************************************************
@page
@newunit{7.8.2.3,ADD CORRESPONDING}
@diagram{ADD CORRESPONDING,PD-ADD-3,PD-ADD-3,None}@p This format of the @statement{ADD} generates code equivalent to individual @syntaxref{ADD TO} statements for corresponding matches of data items found subordinate to the two identifiers.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for information on how corresponding matches will be found between @term{identifier-1} and @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-3} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.3 ALLOCATE                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.3,ALLOCATE}
@diagram{ALLOCATE,PD-ALLOCATE,PD-ALLOCATE,None}@p The @syntax{ALLOCATE} statement is used to dynamically allocate memory at run-time.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{INITIALIZED} and @syntax{INITIALISED} are interchangeable.
@p @item Both @term{identifier-1} and @syntax{RETURNING @term{identifier-2}} may not be specified in the same statement.
@comment Semantic Specifications:
@p @item If used, @term{expression-1} must be an arithmetic expression with a non-zero positive integer value.
@p @item If used, @term{identifier-1} should be an 01-level item defined in working-storage or local-storage with the @syntaxref{BASED} attribute.  It may be an 01 item defined in the linkage section without the @syntax{BASED} attribute, but using such a data item is not recommended.
@p @item If used, @term{identifier-2} should be a @syntaxrefalt{POINTER,USAGE} data item.
@p @item The optional @syntaxidx{RETURNING} clause will return the address of the allocated memory block into the specified @syntax{USAGE POINTER} @term{identifier-2} data item.  When this option is used, knowledge of the originally-requested size of the allocated memory block will be retained by the program in case a @syntaxref{FREE} statement is ever issued against @term{identifier-2}.
@p @item When the @term{identifier-1} option is used in conjunction with @syntaxidx{INITIALIZED} (or it's internationalized alternative @syntax{INITIALISED}), the allocated memory block will be initialized as if an @syntaxrefalt{INITIALIZE @term{identifier-1} WITH FILLER ALL TO VALUE THEN TO DEFAULT,INITIALIZE} were executed.
@p @item When the @syntax{@term{expression-1} CHARACTERS} option is used, @syntax{INITIALIZED} will initialize the allocated memory block to binary zeros.  If @syntax{INITIALIZED} is not used, the initial contents of allocated memory will be left to whatever rules of memory allocation are in effect for the operating system the program is running under.
@p @item There are two basic ways in which this statement is used.  The simplest is:
@p @example
ALLOCATE My-01-Item
@end example
@* With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the @syntax{BASED} attribute) will be allocated.  The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.
@p A second (and equivalent) approach is:
@p @example
ALLOCATE LENGTH OF My-01-Item CHARACTERS RETURNING The-Pointer
SET ADDRESS OF My-01-Item TO The-Pointer
@end example
@item Referencing a @syntax{BASED} data item either before its storage has been allocated or after its storage has been released (via the @statement{FREE}) will lead to "unpredictable results".  That's how reference manuals and standards specifications talk about this situation.  In the author's experience, the results are all too predictable --- the program aborts from an attempt to reference an unallocated area of memory.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.4 ALTER                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.4,ALTER}
@diagram{ALTER,PD-ALTER,PD-ALTER,None}@p The @statement{ALTER} was used in the early years of the COBOL language to edit the object code of a program @strong{at execution time}, changing a @syntaxrefalt{GO TO,Simple GO TO} statement to branch to a spot in the program different than where the @syntax{GO TO} statement was originally compiled for.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{PROCEED} and @syntax{TO} (the one @i{after} @syntax{PROCEED}) are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item @term{procedure-name-1} must contain only a single statement, and that statement must be a simple @syntax{GO TO}.
@comment Semantic Specifications:
@p @item The effect of this statement will be as if the generated machine-language code for the @syntax{GO TO} statement in @term{procedure-name-1} is changed so that the @syntax{GO TO} statement now transfers control to @term{procedure-name-2}, rather than to whatever procedure name was specified in the program source code.
@p @item Support for the @syntax{ALTER} verb has been added to GnuCOBOL for the purpose of enabling GnuCOBOL to pass those National Institute of Standards and Technology (NIST) tests for the COBOL programming language that require support for @syntax{ALTER}.
@p @item Because of the catastrophic effect this statement has on program readability and therefore the programmer's ability to debug problems with program logic, the use of @syntax{ALTER} in new programs is @strong{STRONGLY} discouraged.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.5 CALL                                                     **
@comment *********************************************************************
@page
@newsubsection{7.8.5,CALL}
@diagram{CALL,PD-CALL,PD-CALL,None}
@diagram{CALL Argument,PD-CALL-Arg,PD-CALL-Arg,None}@p The @statement{CALL} is used to transfer control to a subroutine.  @xref{Sub-Programming}, for the specifics of using subprograms with GnuCOBOL programs.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{EXCEPTION} and @syntax{OVERFLOW} are interchangeable.
@p @item The reserved words @syntax{GIVING} and @syntax{RETURNING} are interchangeable.
@comment Semantic Specifications:
@p @item The expectation is that the subroutine will eventually return control back to the calling program, at which point the CALLing program will resume execution starting with the statement immediately following the @syntax{CALL}.  Subprograms are not required to return to their callers, however, and are free to halt program execution if they wish.
@p @item The @term{mnemonic-name-1} / @syntaxidx{STATIC} / @syntaxidx{STDCALL} option, if used, affects the linkage conventions that will be used to the subroutine being called, as follows:
@enumerate A
@p @item The @syntax{STATIC} option will cause the linkage to the subroutine to be performed in such a way as to require the subroutine to be statically-linked with the calling program.  Note that this enables static-linking to be used on a subroutine-by-subroutine selective basis.
@p @item The @syntax{STDCALL} option allows system-standard calling conventions (as opposed to GnuCOBOL calling conventions) to be used when calling a subroutine.  The definition of what constitutes "system standard" may vary from operating system to operating system.  Use of this requires special knowledge about the linkage requirements of subroutines you are intending to @syntax{CALL}.  Subroutines written in GnuCOBOL do not need this option.
@p @item The @term{mnemonic-name-1} option allows a custom-defined calling convention to be used.  Such mnemonic names are defined using the @syntaxrefalt{CALL-CONVENTION,SPECIAL-NAMES} clause.  That clause associates a decimal integer value with @term{mnemonic-name-1} such that the individual bits set on or off in the binary equivalent of the integer affect linkage to the subroutine as described in the following chart.  Those rows of the chart marked with a "No" in the "Supported" column represent bit positions (switch settings) in the integer value that are currently accepted (to provide compatibility to other COBOL implementations) if coded, but are otherwise unsupported.
@p Note that bit 0 is the right-most bit in the binary value.
@p @multitable @columnfractions .05 .15 .4 .4
@headitem Bit @tab Supported @tab Meaning if 0 @tab Meaning if 1
@item 0 @tab No @tab Arguments will be passed in right-to-left sequence @tab Arguments will be passed in left-to-right sequence.
@item
@item 1 @tab No @tab The calling program will flush processed arguments from the argument stack.@tab The called program (subroutine) will flush processed arguments from the argument stack.
@item
@item 2 @tab Yes @tab The @registerrefalt{RETURN-CODE,Special Registers} will be updated in addition to any @syntax{RETURNING} or @syntax{GIVING} data item. @tab The @registertext{RETURN-CODE} will not be updated (but any @syntax{RETURNING} or @syntax{GIVING} data item still will).
@item
@item 3 @tab Yes @tab If CALL "literal" is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.  @tab If CALL "literal" is used, the subroutine can only be located and linked with the calling program at compilation time.
@item
@item 4 @tab No @tab OS/2 "OPTLINK" conventions will not be used to CALL the subprogram. @tab OS/2 "OPTLINK" conventions will be used to CALL the subprogram.
@item
@item 5 @tab No @tab Windows 16-bit "thunking" will not be in effect. @tab Windows 16-bit "thunking" will be used to call the subroutine as a DLL.
@item
@item 6 @tab Yes @tab The STDCALL convention will not be used. @tab The STDCALL convention, required to use the Microsoft Win32 API,  will be used.
@end multitable
@* Using the @syntax{STDCALL} option on a @syntax{CALL} statement is equivalent to using @syntax{CALL-CONVENTION 8} (only bit 3 set).
@p Using the @syntax{STATIC} option on a @syntax{CALL} statement is equivalent to using @syntax{CALL CONVENTION 64} (only bit 6 set).
@end enumerate
@item The value of @term{literal-1} or @term{identifier-1} is the entry-point of the subprogram you wish to call.
@p @item When you call a subroutine using @term{identifier-1}, you are forcing the runtime system to call a dynamically-loadable subprogram.  The contents of @term{identifier-1} will be the entry-point name within that module.  If this is the @i{first} call to any entry-point within the module being made at run-time, the contents of @term{identifier-1} must be the primary entry-point name of the module (which must also match the filename, minus any OS-mandated extension) of the executable file comprising the module).
@p @item You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing.  This is accomplished through the use of the @envvarruntimeref{COB_PRE_LOAD}.  If used, this will only pre-load those modules invoked via @syntax{CALL @term{literal-1}}, as the runtime contents of @term{identifier-1} cannot be predicted.
@p @item If the subprogram being called is a GnuCOBOL program, and if that program had the @syntaxrefalt{INITIAL,IDENTIFICATION DIVISION} attribute specified on its @syntax{PROGRAM-ID} clause, all of the subprogram's data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.
@p This [re]-initialization behaviour will @i{always} apply to any subprogram's local-storage (if any), regardless of the use (or not) of @syntax{INITIAL}.
@p @item The @syntaxidx{USING} clause defines a list of arguments that may be passed from the calling program to the subprogram.  The manner in which any given argument is passed to the subroutine depends upon the @syntax{BY} clause (if any) coded (or implied) for that argument, as follows:
@enumerate A
@p @item @syntaxidx{BY REFERENCE} passes the @i{address} of the argument to the subprogram.  If the subprogram changes the contents of that argument, the change will be "visible" to the calling program.
@p @item @syntaxidx{BY CONTENT} passes the @i{address} of a @i{copy} of the argument to the subprogram.  If the subprogram changes the value of such an argument, the change only affects the copy back in the calling program, not the original version.
@p @item @syntaxidx{BY VALUE} passes the @i{actual numeric value} of the literal or identifiers contents as the argument.  This feature exists to provide compatibility with C, C++ and other languages and would not normally be used when calling GnuCOBOL subprograms.  Only numeric literals or numeric data items should be passed in this manner.
@p @item If an argument lacks a @syntax{BY} clause, the most-recently encountered @syntax{BY} specification on that @syntax{CALL} statement will be assumed.  If the first argument specified on a @syntax{CALL} lacks a @syntax{BY} clause, @syntax{BY REFERENCE} will be assumed.
@end enumerate
@item No more than 251 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it.  If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the @syntax{COB_MAX_FIELD_PARAMS} in the @syntax{call.c} file (found in the @syntax{libcob} folder) as well as the last shown '#if MAX_CALL_FIELD_PARAMS' statement before you run @syntax{make} to build the compiler and run-time library.
@p @item The @syntaxidx{RETURNING} clause allows you to specify a numeric data item into which the subroutine should return a numeric value.  If you use this clause on the @syntax{CALL}, the subroutine should include a @syntaxrefalt{RETURNING,PROCEDURE DIVISION RETURNING} clause on its procedure division header.  Of course, a subroutine may pass a value of any kind back in any argument passed @syntax{BY REFERENCE}.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses (or @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} --- they are interchangeable) may be used to detect and react to the failure or success, respectively, of an attempt to @syntax{CALL} the subroutine.  Failure, in this context, is defined as the inability to either locate or load the object code of the subroutine at execution time.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.6 CANCEL                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.6,CANCEL}
@diagram{CANCEL,PD-CANCEL,PD-CANCEL,None}@p The @statement{CANCEL} unloads the dynamically-loadable subprogram module containing the entry-point specified as @term{literal-1} or @term{identifier-1} from memory.
@enumerate
@p @item If a dynamically-loadable module unloaded by the @statement{CANCEL} is subsequently re-executed, all data division storage for that module will once again be in it's initial state.
@p @item Whether the @statement{CANCEL} actually physically unloads a dynamically-loaded module or simply marks it as logically-unloaded depends on the use and value of the @envvarruntimeref{COB_PHYSICAL_CANCEL}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.7 CLOSE                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.7,CLOSE}
@diagram{CLOSE,PD-CLOSE,PD-CLOSE,PD-CLOSE}@p The @statement{CLOSE} terminates the program's access to the specified file(s).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{FOR} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{REEL} and @syntax{UNIT} are interchangeable.
@comment Semantic Specifications:
@p @item The @syntax{CLOSE} statement may only be executed against files that have been successfully opened.
@p @item A successful @syntax{CLOSE} will write any remaining unwritten record buffers to the file (similar to an @statementref{UNLOCK}) and release any file locks for the file, regardless of open mode.  A closed file will then be no longer available for subsequent I/O statements until it is once again OPENED.
@p @item When a @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{LINE ADVANCING} file is closed, a final delimiter sequence will be written to the file to signal the termination point of the final data record in the file.  This will only be necessary if the final record written to the file was written with the @syntaxrefalt{AFTER ADVANCING,WRITE} option.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.8 COMMIT                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.8,COMMIT}
@diagram{COMMIT,PD-COMMIT,PD-COMMIT,None}@p The @statement{COMMIT} performs an @syntax{UNLOCK} against every currently-open file, but does not close any of the files.
@p See the @statementref{UNLOCK} for additional details.
@comment *********************************************************************
@comment ** 7.8.9 COMPUTE                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.9,COMPUTE}
@diagram{COMPUTE,PD-COMPUTE,PD-COMPUTE,None}@p The @statement{COMPUTE} provides a means of easily performing complex arithmetic operations with a single statement, instead of using cumbersome and possibly confusing sequences of @syntax{ADD}, @syntax{SUBTRACT}, @syntax{MULTIPLY} and @syntax{DIVIDE} statements.  @syntax{COMPUTE} also allows the use of exponentiation --- an arithmetic operation for which no other statement exists in COBOL.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved word @syntax{EQUAL} is interchangeable with the use of @syntax{=}.
@comment Semantic Specifications:
@p @item Each @term{identifier-1} must be a numeric or numeric-edited data item.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-1} will control how non-integer results will be saved.
@p @item @xref{Arithmetic Expressions}, for more information on arithmetic expressions.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined either as having an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point or attempting to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.10 CONTINUE                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.10,CONTINUE}
@diagram{CONTINUE,PD-CONTINUE,PD-CONTINUE,None}@p The @statement{CONTINUE} is a no-operation statement that may be coded anywhere an imperative statement (@pxref{Imperative Statement}) may be coded.
@enumerate
@p @item The @syntax{CONTINUE} statement has no effect on the execution of the program.
@p @item This statement (perhaps in combination with an appropriate comment or two) makes a convenient "place holder" --- particularly in @syntaxrefalt{ELSE,IF} or @syntaxrefalt{WHEN,EVALUATE} clauses where no code is currently expected to be needed, but a place for code to handle the conditions in question is to be reserved in case it's ever needed.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.11 DELETE                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.11,DELETE}
@diagram{DELETE,PD-DELETE,PD-DELETE,None}@p The @statement{DELETE} logically deletes a record from a COBOL file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{KEY} and @syntax{RECORD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntax{ORGANIZATION} of @term{file-name-1} cannot be @syntaxref{ORGANIZATION LINE SEQUENTIAL}.
@p @item The @term{file-name-1} file cannot be a sort/merge work file (a file described using a @syntaxrefalt{SD,File/Sort-Description}).
@p @item For files in the @syntax{SEQUENTIAL} access mode, the last input-output statement executed against @term{file-name-1} prior to the execution of the @syntax{DELETE} statement must have been a successfully executed sequential-format @statementrefalt{READ,Sequential READ}.  That @syntax{READ} will therefore identify the record to be deleted.
@p @item If @term{file-name-1} is a @syntax{RELATIVE} file whose @syntaxrefalt{ACCESS MODE,ORGANIZATION RELATIVE} is either @syntax{RANDOM} or @syntax{DYNAMIC}, the record to be deleted is the one whose relative record number is currently the value of the field specified as the files @syntaxidx{RELATIVE KEY} in it's @statement{SELECT}.
@p @item If @term{file-name-1} is an @syntax{INDEXED} file whose @syntaxrefalt{ACCESS MODE,ORGANIZATION INDEXED} is @syntax{RANDOM} or @syntax{DYNAMIC}, the record to be deleted is the one whose primary key is currently the value of the field specified as the @syntaxidx{RECORD KEY} in the file's @syntax{SELECT} statement.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, of an attempt to delete a record.  @xref{INVALID KEY + NOT INVALID KEY}, for additional information.
@p @item No @syntax{INVALID KEY} or @syntax{NOT INVALID KEY} clause may be specified for a file who's @syntax{ACCESS MODE IS SEQUENTIAL}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.12 DISPLAY                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.12,DISPLAY}
@menu
* 7.8.12.1: DISPLAY UPON device
* 7.8.12.2: DISPLAY UPON COMMAND-LINE
* 7.8.12.3: DISPLAY UPON ENVIRONMENT-NAME
* 7.8.12.4: DISPLAY screen-data-item
@end menu
@comment *********************************************************************
@comment ** 7.8.12.1 DISPLAY UPON device                                   **
@comment *********************************************************************
@newunit{7.8.12.1,DISPLAY UPON device}
@diagram{DISPLAY UPON device,PD-DISPLAY-1,PD-DISPLAY-1,None}@p This format of the @statement{DISPLAY} displays the specified identifier contents and/or literal values on the system output device specified via the @syntax{UPON} clause.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{ON} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item If no @syntaxidx{UPON} clause is specified, @syntax{UPON CONSOLE} will be assumed.  If the @syntax{UPON} clause @i{is} specified, @term{mnemonic-name-1} must be one of the built-in output device names @syntax{CONSOLE}, @syntax{PRINTER}, @syntax{STDERR}, @syntax{STDOUT}, @syntax{SYSERR}, @syntax{SYSLIST}, @syntax{SYSLST} or @syntax{SYSOUT} or a mnemonic name assigned to one of those devices via the @syntaxref{SPECIAL-NAMES} paragraph.
@p When displaying upon the @syntax{STDERR} or @syntax{SYSERR} devices or to a @term{mnemonic-name-1} attached to one of those two devices, the output will be written to output pipe #2, which will normally cause the output to appear in the console output window.  You may, if desired, redirect that output to a file by appending @syntax{2> filename} to the end of the command that executes the program.  This applies to both Windows (any type) or Unix versions of GnuCOBOL.
@p When displaying upon the @syntax{CONSOLE}, @syntax{PRINTER}, @syntax{STDOUT}, @syntax{SYSLIST}, @syntax{SYSLST} or @syntax{SYSOUT} devices or to a @term{mnemonic-name-1} attached to one of them, the output will be written to output pipe #1, which will normally cause the output to appear in the console output window.  You may, if desired, redirect that output to a file by appending @syntax{1> filename} or simply @syntax{> filename} to the end of the command that executes the program.  This applies to both Windows (any type) or Unix versions of GnuCOBOL.
@p @item The @syntaxidx{NO ADVANCING} clause, if used, will suppress the carriage-return / line-feed sequence that is normally added to the end of any console display.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified device.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.12.2 DISPLAY UPON COMMAND-LINE                             **
@comment *********************************************************************
@page
@newunit{7.8.12.2,DISPLAY UPON COMMAND-LINE}
@diagram{DISPLAY UPON COMMAND-LINE,PD-DISPLAY-2,PD-DISPLAY-2,None}@p This form of the @statement{DISPLAY} may be used to specify the command-line argument number to be retrieved by a subsequent @statementrefalt{ACCEPT FROM ARGUMENT-VALUE,ACCEPT FROM COMMAND-LINE} or to specify a new value for the command-line arguments themselves.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item By displaying a numeric integer value UPON @syntaxidx{ARGUMENT-NUMBER}, you will specify which argument (by its relative number) will be retrieved by a subsequent @statement{ACCEPT FROM ARGUMENT-VALUE}.
@p @item Executing a @syntax{DISPLAY UPON COMMAND-LINE} will influence subsequent @syntax{ACCEPT FROM COMMAND-LINE} statements (which will then return the  value you displayed), but will not influence subsequent @syntax{ACCEPT FROM ARGUMENT-VALUE} statements --- these will continue to return the original program execution parameters.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified item.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.12.3 DISPLAY UPON ENVIRONMENT-NAME                         **
@comment *********************************************************************
@page
@newunit{7.8.12.3,DISPLAY UPON ENVIRONMENT-NAME}
@diagram{DISPLAY UPON ENVIRONMENT-NAME,PD-DISPLAY-3-Info,PD-DISPLAY-3-TeX,None}@p This form of the @statement{DISPLAY} can be used to create or modify environment variables.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item To create or change an environment variable will require two @syntax{DISPLAY} statements.  The following example sets the environment variable "MY_ENV_VAR" to a value of "Demonstration Value":
@p @example
DISPLAY "MY_ENV_VAR" UPON ENVIRONMENT-NAME
DISPLAY "Demonstration Value" UPON ENVIRONMENT-VALUE
@end example
@item Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. @syntaxrefalt{CALL 'SYSTEM',SYSTEM}) but will not be known to the shell or console window that started the GnuCOBOL program.
@p @item Consider using @syntaxref{SET ENVIRONMENT} in lieu of @syntax{DISPLAY} to set environment variables as it is much simpler.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified item.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.12.4 DISPLAY screen-data-item                              **
@comment *********************************************************************
@page
@newunit{7.8.12.4,DISPLAY screen-data-item}
@diagram{DISPLAY screen-data-item,PD-DISPLAY-4,PD-DISPLAY-4,PD-DISPLAY-4}@p This format of the @statement{DISPLAY} presents data onto a formatted screen.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{LINE}, @syntax{LINES}, @syntax{NUMBER} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{COLUMN} and @syntax{POSITION} are interchangeable.
@p @item The reserved words @syntax{LINE} and @syntax{LINES} are interchangeable.
@p @item The reserved words @syntax{TIMEOUT} and @syntax{TIME-OUT} are interchangeable.
@comment Semantic Specifications:
@p @item If @term{identifier-1} is defined in the @syntaxref{SCREEN SECTION}, any @syntax{AT}, @term{Attribute-Specification} and @syntax{WITH} clauses will be ignored.  All field definition, cursor positioning and screen control will occur as a result of the screen section definition of @term{identifier-1}.
@p @item The following points apply if @term{identifier-1} is not defined in the screen section:
@enumerate A
@p @item The purpose of the @syntax{AT} clause is to define where on the screen @term{identifier-1} should be displayed.  @xref{ACCEPT screen-data-item}, for additional information.
@p @item The purpose of the @syntax{WITH} clause is to define the visual attributes that should be applied to @term{identifier-1} when it is displayed on the screen as well as other presentation-control characteristics.
@p @item The following @term{Attribute-Specification} clauses are allowed on the @syntax{DISPLAY} statement --- these are the same as those allowed for @syntax{SCREEN SECTION} data items.  A particular @term{Attribute-Specification} may be used only once in any @syntax{DISPLAY}:
@itemize @bullet
@p @item @syntaxref{BACKGROUND-COLOR}
@p @item @syntaxref{BEEP}, @syntaxref{BELL}
@p @item @syntaxref{BLANK}
@p @item @syntaxref{BLINK}
@p @item @syntaxref{ERASE}
@p @item @syntaxref{FOREGROUND-COLOR}
@p @item @syntaxref{HIGHLIGHT}
@p @item @syntaxref{LOWLIGHT}
@p @item @syntaxref{OVERLINE}
@p @item @syntaxref{REVERSE-VIDEO}
@p @item @syntaxref{UNDERLINE}
@end itemize
@item @xref{ACCEPT screen-data-item}, for additional information on the other @syntax{WITH} clause options.
@end enumerate
@item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of the screen I/O attempt.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.13 DIVIDE                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.13,DIVIDE}
@menu
* 7.8.13.1: DIVIDE INTO
* 7.8.13.2: DIVIDE INTO GIVING
* 7.8.13.3: DIVIDE BY GIVING
@end menu
@comment *********************************************************************
@comment ** 7.8.13.1 DIVIDE INTO                                           **
@comment *********************************************************************
@newunit{7.8.13.1,DIVIDE INTO}
@diagram{DIVIDE INTO,PD-DIVIDE-1,PD-DIVIDE-1,None}@p This format of the @statement{DIVIDE} will divide a numeric value (specified as a literal or numeric data item) into one or more numeric data items, replacing the value in each of those data items with the result(s).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items and @term{literal-1} must be a numeric literal.
@p @item A division operation will be performed for each @term{identifier-2}, in turn.  Each of the results of those divisions will be saved to the corresponding @term{identifier-2} data item(s).
@p @item Should any @term{identifier-2} be an integer numeric data item, the result computed when that @term{identifier-2} is divided by @term{literal-1} or @term{identifier-1} will also be an integer --- any remainder from that division will be discarded.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being numeric truncation caused by an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.13.2 DIVIDE INTO GIVING                                    **
@comment *********************************************************************
@page
@newunit{7.8.13.2,DIVIDE INTO GIVING}
@diagram{DIVIDE INTO GIVING,PD-DIVIDE-2,PD-DIVIDE-2,None}@p This format of the @statement{DIVIDE} will divide one numeric value (specified as a literal or numeric data item) into another numeric value (also specified as a literal or numeric data item) and will then replace the contents of one or more receiving data items with the results of that division.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while both @term{identifier-3} and @term{identifier-4} must be numeric (edited or unedited) data items.
@p @item Both @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item If the @syntaxidx{REMAINDER} clause is coded, there may be only one @term{identifier-3} specified.
@p @item The result obtained when the value of @term{literal-2} or @term{identifier-2} is divided by the value of @term{literal-1} or @term{identifier-1} is computed; this result is then moved into each @term{identifier-3}, in turn, applying the rules defined by the @syntaxref{ROUNDED} clause (if any) for that @term{identifier-3} to the move.
@p @item If a @syntax{REMAINDER} clause is specified, the value of the one and only @term{identifier-3} (as stated earlier, if @syntax{REMAINDER} is specified there may only be a single @term{identifier-3} coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of @term{literal-1} or @term{identifier-1}; that result is then subtracted from the value of @term{literal-2} or @term{identifier-2} and @i{that} result is the value which is moved to @term{identifier-4}.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.13.3 DIVIDE BY GIVING                                      **
@comment *********************************************************************
@page
@newunit{7.8.13.3,DIVIDE BY GIVING}
@diagram{DIVIDE BY GIVING,PD-DIVIDE-3,PD-DIVIDE-3,None}@p This format of the @statement{DIVIDE} will divide one numeric value (specified as a literal or numeric data item) into another numeric value (also specified as a literal or numeric data item) and will then replace the contents of one or more receiving data items with the results of that division.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while both @term{identifier-3} and @term{identifier-4} must be numeric (edited or unedited) data items.
@p @item Both @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item If the @syntaxidx{REMAINDER} clause is coded, there may be only one @term{identifier-3} specified.
@p @item The result obtained when the value of @term{literal-1} or @term{identifier-1} is divided by the value of @term{literal-2} or @term{identifier-2} is computed; this result is then moved into each @term{identifier-3}, in turn, applying the rules defined by the @syntaxref{ROUNDED} clause (if any) for that @term{identifier-3} to the move.
@p @item If a @syntax{REMAINDER} clause is specified, the value of the one and only @term{identifier-3} (as stated earlier, if @syntax{REMAINDER} is specified there may only be a single @term{identifier-3} coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of @term{literal-2} or @term{identifier-2}; that result is then subtracted from the value of @term{literal-1} or @term{identifier-1} and @i{that} result is the value which is moved to @term{identifier-4}.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.14 ENTRY                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.14,ENTRY}
@diagram{ENTRY,PD-ENTRY,PD-ENTRY,None}
@diagram{ENTRY-Argument,PD-ENTRY-Arg,PD-ENTRY-Arg,None}@p The @statement{ENTRY} is used to define an alternate entry-point into a subroutine, along with the arguments that subroutine will be expecting.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{BY} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item You may not use an @statement{ENTRY} in a nested subprogram, nor may you use it in any form of user-defined function.
@p @item The @syntaxidx{USING} clause defines the arguments the subroutine entry-point supports.  This list of arguments must match up against the @syntax{USING} clause of any @statement{CALL} that will be invoking the subroutine using this entry-point.
@p @item Each @term{ENTRY-Argument} specified on the @statement{ENTRY} must be defined in the linkage section of the subroutine in which the @statement{ENTRY} exists.
@p @item The @term{literal-1} value will specify the entry-point name of the subroutine.  It must be specified exactly on @syntax{CALL} statements (with regard to the use of upper- and lower-case letters) as it is specified on the @statement{ENTRY}.
@p @item The meaning of @syntaxidx{REFERENCE}, @syntaxidx{CONTENT} and @syntaxidx{VALUE} are the same as the equivalent specifications on the @statementref{CALL}.  Whatever specification will be used for an argument on the @syntax{CALL} to this entry-point should match the specification used in the corresponding @term{ENTRY-Argument}.  The same rules regarding the presence or absence of a @syntax{BY} clause on a @statement{CALL} apply to the presence or absence of a @syntax{BY} clause on the corresponding argument of the @statement{ENTRY}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.15 EVALUATE                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.15,EVALUATE}
@diagram{EVALUATE,PD-EVALUATE,PD-EVALUATE,None}
@diagram{EVALUATE Selection Subject,PD-EVALUATE-SS,PD-EVALUATE-SS,None}
@diagram{EVALUATE Selection Object,PD-EVALUATE-SO,PD-EVALUATE-SO,None}@p The @statement{EVALUATE} provides a means of defining processing that should take place under any number of mutually-exclusive conditions.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item There must be at least one @syntaxidx{WHEN} clause (in addition to any @syntaxidx{WHEN OTHER} clause) specified on any @statement{EVALUATE}.
@p @item There must be at least one @term{Selection-Subject} specified on the @statement{EVALUATE}.  Any number of additional @term{Selection-Subject} clauses may be specified, using the @syntaxidx{ALSO} reserved word to separate each from the prior.
@p @item Each @syntax{WHEN} clause (other than the @syntaxidx{WHEN OTHER} clause, if any) must have the same number of @term{Selection-Object} clauses as there are @term{Selection-Subject} clauses.
@p @item When using @syntaxidx{THRU}, the values on both sides of the @syntax{THRU} must be the same class (both numeric, both alphanumeric, etc.).
@p @item A @term{partial-expression} is one of the following:
@enumerate A
@p @item A Class Condition without a leading @term{identifier-1} (@pxref{Class Conditions}).
@p @item A Sign Condition without a leading @term{identifier-1} (@pxref{Sign Conditions}).
@p @item A Relation Condition with nothing to the left of the relational operator (@pxref{Relation Conditions}).
@end enumerate
@comment Semantic Specifications:
@item At execution time, each @term{Selection-Subject} on the @statement{EVALUATE} will have its value matched against that of the corresponding @term{Selection-Object} on a @syntax{WHEN} clause, in turn, until:
@enumerate A
@p @item A @syntax{WHEN} clause has @i{each} of its @term{Selection-Object}(s) successfully matched by the corresponding @term{Selection-Subject}; this will be referred to as the '@i{Selected WHEN clause}'.
@p @item The complete list of @syntax{WHEN} clauses (except for the @syntax{WHEN OTHER} clause, if any) has been exhausted.  In this case, there is no '@i{Selected WHEN Clause}'.
@end enumerate
@item If a '@i{Selected WHEN Clause}' was identified:
@enumerate A
@p @item The @term{imperative-statement-1} (@pxref{Imperative Statement}) immediately following the '@i{Selected WHEN Clause}' will be executed.  If the '@i{Selected WHEN Clause}' is lacking an @term{imperative-statement-1}, the first @term{imperative-statement-1} found after any following @syntax{WHEN} clause will be executed.
@p @item Once the @term{imperative-statement-1} has been executed, or no @term{imperative-statement-1} was found anywhere after the '@i{Selected WHEN Clause}', control will proceed to the statement following the @syntax{END-EVALUATE} or, if there is no @syntax{END-EVALUATE}, the first statement that follows the next period.  If, however, the @term{imperative-statement-1} included a @statement{GO TO}, and that @syntax{GO TO} was executed, then control will transfer to the procedure named on the @syntax{GO TO} instead.
@end enumerate
@item If no '@i{Selected WHEN Clause}' was identified:
@enumerate A
@p @item The @syntax{WHEN OTHER} clause's @term{imperative-statement-other} will be executed, if such a clause was coded.
@p @item Control will then proceed to the statement following the @syntax{END-EVALUATE} or the first statement that follows the next period if there is no @syntax{END-EVALUATE}.  If,however, the @term{imperative-statement-other} included a @statement{GO TO}, and that @syntax{GO TO} was executed, then control will transfer to the procedure named on the @syntax{GO TO} instead.
@end enumerate
@item In order for a @term{Selection-Subject} to match the corresponding @term{Selection-Object} on a @syntax{WHEN} clause, at least one of the following must be true:
@enumerate A
@p @item The @term{Selection-Object} is @syntaxidx{ANY}
@p @item The implied Relation Condition @syntax{@term{Selection-Subject} = @term{Selection Object}} is TRUE --- @xref{Relation Conditions}, for the rules on how the comparison will be made.
@p @item The value of the @term{Selection-Subject} falls within the range of values specified by the @syntax{THRU} clause of the @term{Selection-Object}
@p @item If the @term{Selection-Object} is a @term{partial-expression}, then the conditional expression that would be represented by coding @syntax{@term{Selection-Subject} @term{Selection-Object}} evaluates to TRUE
@end enumerate
@item Here is a sample program that illustrates the EVALUATE statement.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DEMOEVALUATE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Test-Digit                  PIC 9(1).
    88 Digit-Is-Odd VALUE 1, 3, 5, 7, 9.
    88 Digit-Is-Prime VALUE 1, 3, 5, 7.
PROCEDURE DIVISION.
P1. PERFORM UNTIL EXIT
    DISPLAY "Enter a digit (0 Quits): "
        WITH NO ADVANCING
    ACCEPT Test-Digit
    IF Test-Digit = 0
        EXIT PERFORM
    END-IF
    EVALUATE Digit-Is-Odd ALSO Digit-Is-Prime
    WHEN TRUE ALSO FALSE
        DISPLAY Test-Digit " is ODD"
            WITH NO ADVANCING
    WHEN TRUE ALSO TRUE
        DISPLAY Test-Digit " is PRIME"
            WITH NO ADVANCING
    WHEN FALSE ALSO ANY
        DISPLAY Test-Digit " is EVEN"
            WITH NO ADVANCING
    END-EVALUATE
    EVALUATE Test-Digit
    WHEN < 5
        DISPLAY " and it's small too"
    WHEN < 8
        DISPLAY " and it's medium too"
    WHEN OTHER
        DISPLAY " and it's large too"
    END-EVALUATE
END-PERFORM
DISPLAY "Bye!"
STOP RUN
.
@end example
@* Console output when run (user input follows the colons on the prompts for input):
@p @example
Enter a digit (0 Quits): 1
1 is PRIME and it's small too
Enter a digit (0 Quits): 2
2 is EVEN and it's small too
Enter a digit (0 Quits): 3
3 is PRIME and it's small too
Enter a digit (0 Quits): 4
4 is EVEN and it's small too
Enter a digit (0 Quits): 5
5 is PRIME and it's medium too
Enter a digit (0 Quits): 6
6 is EVEN and it's medium too
Enter a digit (0 Quits): 7
7 is PRIME and it's medium too
Enter a digit (0 Quits): 8
8 is EVEN and it's large too
Enter a digit (0 Quits): 9
9 is ODD and it's large too
Enter a digit (0 Quits): 0
Bye!
@end example
@end enumerate
@comment *********************************************************************
@comment ** 7.8.16 EXIT                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.16,EXIT}
@diagram{EXIT,PD-EXIT,PD-EXIT,None}@p The @statement{EXIT} is a multi-purpose statement; it may provide a common end point for a series of procedures, exit an in-line PERFORM, paragraph or section or it may mark the logical end of a subprogram, returning control back to the calling program.
@enumerate
@comment Syntactical Specifications:
@p @item The @statement{EXIT PROGRAM} is not legal anywhere within a user-defined function.
@p @item The @statement{EXIT FUNCTION} cannot be used anywhere within a subroutine.
@p @item Neither @syntax{EXIT PROGRAM} nor @syntax{EXIT FUNCTION} may be used within a @syntax{USE GLOBAL} routine in @syntaxref{DECLARATIVES}.
@comment Semantic Specifications:
@p @item The following points describe the @statement{EXIT} with none of the optional clauses:
@enumerate A
@p @item When this form of an @statement{EXIT} is used, it must be the only statement in the procedure (paragraph or section) in which it occurs.
@p @item This usage of the @statement{EXIT} simply provides a common "GO TO" end point for a series of procedures, as may be seen in the following example:
@p @example
01  Switches.
    05 Input-File-Switch PIC X(1).
       88 EOF-On-Input-File VALUE Y FALSE N.
@dots{}
    SET EOF-On-Input-File TO FALSE.
    PERFORM 100-Process-A-Transaction THRU 199-Exit
        UNTIL EOF-On-Input-File.
@dots{}
100-Process-A-Transaction.
    READ Input-File AT END
        SET EOF-On-Input-File TO TRUE
        GO TO 199-Exit
    END-READ.
    IF Input-Rec of Input-File = SPACES
        GO TO 199-Exit  *> IGNORE BLANK RECORDS!
    END-IF.
    <<@term{process the record just read}>>
199-Exit.
    EXIT.
@end example
@item In this case, the @statement{EXIT} takes no other run-time action.
@end enumerate
@item The following points apply to the @syntax{EXIT PARAGRAPH} and @syntax{EXIT SECTION} statements:
@enumerate A
@p @item If an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} resides in a paragraph @i{within} the scope of a procedural @syntaxrefalt{PERFORM,Procedural PERFORM}, control will be returned back to the @syntax{PERFORM} for evaluation of any @syntax{TIMES}, @syntax{VARYING} and/or @syntax{UNTIL} clauses.
@p @item If an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} resides @i{outside} the scope of a procedural @syntax{PERFORM}, control simply transfers to the first executable statement in the next paragraph (@syntax{EXIT PARAGRAPH}) or section (@syntax{EXIT SECTION}).
@p @item The following shows how the previous example could have been coded without a @syntax{GO TO} by utilizing an @statement{EXIT PARAGRAPH}.
@p @example
01  Switches.
    05 Input-File-Switch PIC X(1).
       88 EOF-On-Input-File VALUE Y FALSE N.
@dots{}
    SET EOF-On-Input-File TO FALSE.
    PERFORM 100-Process-A-Transaction
        UNTIL EOF-On-Input-File.
@dots{}
100-Process-A-Transaction.
    READ Input-File AT END
        SET EOF-On-Input-File TO TRUE
        EXIT PARAGRAPH
    END-READ.
    IF Input-Rec of Input-File = SPACES
        EXIT PARAGRAPH *> IGNORE BLANK RECORDS!
    END-IF.
    <<@term{process the record just read}>>
@end example
@end enumerate
@item The following points apply to the @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements:
@enumerate A
@p @item The @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements are intended to be used in conjunction with an in-line @statementrefalt{PERFORM,Inline PERFORM}.
@p @item An @statement{EXIT PERFORM CYCLE} will terminate the current iteration of the in-line @syntax{PERFORM}, giving control to any @syntax{TIMES}, @syntax{VARYING} and/or @syntax{UNTIL} clauses for them to determine if another cycle needs to be performed.
@p @item An @statement{EXIT PERFORM} will terminate the in-line PERFORM outright, transferring control to the first statement following the @syntax{END-PERFORM} (if there is one) or to the next sentence following the @syntax{PERFORM} if there is no @syntax{END-PERFORM}.
@p @item This last example shows the final modification to the previous examples by using an in-line @syntax{PERFORM} along with @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements:
@p @example
PERFORM FOREVER
    READ Input-File AT END
        EXIT PERFORM
    END-READ
    IF Input-Rec of Input-File = SPACES
        EXIT PERFORM CYCLE *> IGNORE BLANK RECORDS!
    END-IF
    <<@term{process the record just read}>>
END PERFORM
@end example
@end enumerate
@item The following points apply to the @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} statements:
@enumerate A
@p @item The @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} statements terminate the execution of a subroutine (i.e.  a program that has been CALLed by another) or user-defined function, respectively, returning control back to the calling program.
@p @item An @statement{EXIT PROGRAM} returns control back to the statement following the @syntaxref{CALL} of the subprogram.  An @statement{EXIT FUNCTION} returns control back to the processing of the statement in the calling program that invoked the user-defined function.
@p @item If executed by a main program, neither the @syntax{EXIT PROGRAM} nor @syntax{EXIT FUNCTION} statements will take any action.
@p @item The COBOL2002 standard has made a common extension to the COBOL language --- the @statementref{GOBACK} --- a standard language element; the @syntax{GOBACK} statement should be strongly considered as the preferred alternative to both @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} for new subprograms.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.17 FREE                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.17,FREE}
@diagram{FREE,PD-FREE,PD-FREE,None}@p The @statement{FREE} releases memory previously allocated to the program by the @statementref{ALLOCATE}.
@enumerate
@comment Syntactical Specifications:
@p @item The @syntax{ADDRESS OF} clause is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this clause has no effect upon the program.
@comment Semantic Specifications:
@p @item @term{identifier-1} must have a @syntaxref{USAGE} of @syntax{POINTER}, or it must be an 01-level data item with the @syntaxref{BASED} attribute.
@p @item If @term{identifier-1} is a @syntax{USAGE POINTER} data item and it contains a valid address, the @statement{FREE} will release the memory block the pointer references.  In addition, any @syntax{BASED} data items that the pointer was used to provide an address for will become un-based and therefore un-usable.  If @term{identifier-1} did not contain a valid address, no action will be taken.
@p @item If @term{identifier-1} is a @syntax{BASED} data item and that data item is currently based (meaning it currently has memory allocated to it), its memory is released and @term{identifier-1} will become un-based and therefore un-usable.  If @term{identifier-1} was not based, no action will be taken.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.18 GENERATE                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.18,GENERATE}
@diagram{GENERATE,PD-GENERATE,PD-GENERATE,None}@p The @statement{GENERATE} presents data to a report.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The following points apply when @term{identifier-1} is specified:
@enumerate A
@p @item @term{identifier-1} must be the name of a @syntaxrefalt{DETAIL,RWCS Lexicon} report group.
@p @item If necessary, @term{identifier-1} may be qualified with a report name.
@p @item The file in whose @syntax{FD} a @syntax{REPORT} clause exists for the report in which @term{identifier-1} is a detail group must be opened for @syntax{OUTPUT} or @syntax{EXTEND} at the time the @syntax{GENERATE} is executed.  @xref{OPEN}, for information on file open modes.
@p @item The report in which @term{identifier-1} is a @syntax{DETAIL} group must have been successfully initiated via the @statementref{INITIATE} and not yet terminated via the @statementref{TERMINATE} at the time the @syntax{GENERATE} is executed.
@p @item If at least one @syntax{GENERATE} statement of this form is executed against a report, the report is said to be a @define{detail report}.  If no @syntax{GENERATE} statements of this form are executed against a report, the report is said to be a @define{summary report}.
@end enumerate
@item The following points apply when @term{report-name-1} is specified:
@enumerate A
@p @item @term{report-name-1} must be the name of a report having an @syntax{RD} defined for it in the report section.
@p @item There must be at least one @syntaxrefalt{CONTROL,RWCS Lexicon} group defined for @term{report-name-1}.
@p @item There cannot be more than one @syntax{DETAIL} group defined for @term{report-name-1}.
@p @item The file in whose @syntax{FD} a @syntax{REPORT @term{report-name-1}} clause exists must be open for  @syntax{OUTPUT} or @syntax{EXTEND} at the time the GENERATE is executed.
@p @item @term{report-name-1} must have been successfully initiated (via "INITIATE @term{report-name-1}") and not yet terminated (via TERMINATE) at the time the @syntax{GENERATE} is executed.  @xref{OPEN}, for information on file open modes.
@p @item The @syntax{DETAIL} group which is defined for @term{report-name-1} @i{will} be processed but will not actually be presented to any report page.  This will allow summary processing to take place.  If all @syntax{GENERATE} statements are of this form, the report is said to be a @define{summary report}.  If at least one @syntax{GENERATE @term{identifier-1}} is executed, the report is considered to be a @define{detail report}.
@end enumerate
@item When the first @syntax{GENERATE} statement for a report is executed, the contents of all control fields are saved so they may be referenced during the processing of subsequent @syntax{GENERATE} statements.
@p @item When, during the processing of  a subsequent @syntax{GENERATE}, it is determined that a control field has changed value (ie. a control break has occurred), the appropriate control footing and control heading processing will take place and a snapshot of the current values of all control fields will again be saved.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.19 GOBACK                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.19,GOBACK}
@diagram{GOBACK,PD-GOBACK,PD-GOBACK,None}@p The @statement{GOBACK} is used to logically terminate an executing program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item If executed within a subprogram (i.e. a subroutine or user-defined function), @syntax{GOBACK} behaves like an @syntax{EXIT PROGRAM} or @statement{EXIT FUNCTION}, respectively.
@p @item If executed within a main program, @syntax{GOBACK} will act as a @syntax{STOP RUN} statement.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.20 GO TO                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.20,GO TO}
@menu
* 7.8.20.1: Simple GO TO
* 7.8.20.2: GO TO DEPENDING ON
@end menu
@comment *********************************************************************
@comment ** 7.8.20.1 Simple GO TO                                          **
@comment *********************************************************************
@newunit{7.8.20.1,Simple GO TO}
@diagram{Simple GO TO,PD-GO-TO-1,PD-GO-TO-1,None}@p This form of the @statement{GO TO} unconditionally transfers control in a program to the first executable statement within the specified @term{procedure-name-1}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{TO} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item If this format of the @statement{GO TO} appears in a consecutive sequence of imperative statements (@pxref{Imperative Statement}) within a sentence, it must be the @i{final} statement in the sentence.
@comment Semantic Specifications:
@p @item If a @syntax{GO TO} is executed within the scope of@dots{}
@enumerate A
@p @item ...an in-line @syntaxref{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to @term{procedure-name-1}.
@p @item ...a procedural @syntaxref{PERFORM}, and @term{procedure-name-1} lies outside the scope of that @syntax{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to @term{procedure-name-1}.
@p @item ...a @statementref{MERGE} @syntax{OUTPUT PROCEDURE} or within the scope of either an @syntax{INPUT PROCEDURE} or @syntax{OUTPUT PROCEDURE} of a @statementrefalt{SORT,File-Based SORT}, and @term{procedure-name-1} lies outside the scope of that procedure, the @syntax{SORT} or @syntax{MERGE} operation is terminated as control of execution transfers to @term{procedure-name-1}.  Any sorted or merged data accumulated to that point is lost.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.20.2 GO TO DEPENDING ON                                    **
@comment *********************************************************************
@page
@newunit{7.8.20.2,GO TO DEPENDING ON}
@diagram{GO TO DEPENDING ON,PD-GO-TO-2,PD-GO-TO-2,None}@p This form of the @statement{GO TO} will transfer control to any one of a number of specified procedure names depending on the numeric value of the identifier specified on the statement.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{TO} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntaxref{PICTURE} and/or @syntaxref{USAGE} of the specified @term{identifier-1} must be such as to define it as a numeric, unedited, preferably unsigned integer data item.
@p @item If the value of @term{identifier-1} has the value 1, control will be transferred to the 1st specified procedure name.  If the value is 2, control will transfer to the 2nd procedure name, and so on.
@p If control of execution is transferred to a procedure named on the statement, and the @syntax{GO TO} is executed within the scope of@dots{}
@enumerate A
@p @item ...an in-line @syntaxref{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to the procedure named on the statement.
@p @item ...a procedural @syntaxref{PERFORM}, and @term{procedure-name-1} lies outside the scope of that @syntax{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to the procedure named on the statement.
@p @item ...a @statementref{MERGE} @syntax{OUTPUT PROCEDURE} or within the scope of either an @syntax{INPUT PROCEDURE} or @syntax{OUTPUT PROCEDURE} of a @statementrefalt{SORT,File-Based SORT}, and @term{procedure-name-1} lies outside the scope of that procedure, the @syntax{SORT} or @syntax{MERGE} operation is terminated as control of execution transfers to the procedure named on the statement.  Any sorted or merged data accumulated to that point is lost.
@end enumerate
@item If the value of @term{identifier-1} is less than 1 or exceeds the total number of procedure names specified on the statement, control will simply fall through into the next statement following the @syntax{GO TO}.
@p @item The following example shows how @syntax{GO TO ... DEPENDING ON} may be used in a real application situation, and compares it against an alternative --- @syntaxref{EVALUATE}.
@verbatim
GO TO DEPENDING ON Example        Equivalent EVALUATE Example
================================= =================================
    GO TO                         EVALUATE Acct-Type
      ACCT-TYPE-1                 WHEN 1
      ACCT-TYPE-2                     <<< Handle Acct Type 1 >>>
      ACCT-TYPE-3                 WHEN 2
    DEPENDING ON Acct-Type.           <<< Handle Acct Type 2 >>>
    <<< Invalid Acct Type >>>     WHEN 3
    GO TO All-Done.                   <<< Handle Acct Type 3 >>>
Acct-Type-1.                      WHEN OTHER
    <<< Handle Acct Type 1 >>>        <<< Invalid Acct Type >>>
    GO TO All-Done.               END-EVALUATE.
Acct-Type-2.
    <<< Handle Acct Type 2 >>>
    GO TO All-Done.
Acct-Type-3.
    <<< Handle Acct Type 3 >>>
All-Done.
@end verbatim
@item Current programming philosophy would prefer the use of the @statement{EVALUATE} to that of this form of the @statement{GO TO}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.21 IF                                                      **
@comment *********************************************************************
@page
@newsubsection{7.8.21,IF}
@diagram{IF,PD-IF,PD-IF,None}@p The @statement{IF} is used to conditionally execute an imperative statement (@pxref{Imperative Statement}) or to select one of two different imperative statements to execute based upon the TRUE/FALSE value of a conditional expression.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{THEN} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item  You cannot use both @syntax{NEXT SENTENCE} and the @syntax{END-IF} scope terminator in the same @syntax{IF} statement.
@comment Semantic Specifications:
@p @item If @term{conditional-expression} evaluates to TRUE, @term{imperative-statement-1} will be executed regardless of whether or not an @syntaxidx{ELSE} clause is present.  Once @term{imperative-statement-1} has been executed, control falls into the first statement following the @syntax{END-IF} or to the first statement of the next sentence if there is no @syntax{END-IF} clause.
@p @item If the optional @syntax{ELSE} clause is present and conditional-expression evaluates to false, then (and only then) @term{imperative-statement-2} will be executed. Once @term{imperative-statement-2} has been executed, control falls into the first statement following the @syntax{END-IF} or to the first statement of the next sentence if there is no @syntax{END-IF} clause.
@p @item The clause @syntaxidx{NEXT SENTENCE} may be substituted for either imperative-statement, but not both.  If control reaches a @syntax{NEXT SENTENCE} clause due to the truth or falsehood of @term{conditional-expression}, control will be transferred to the first statement of the next sentence found in the program (the first statement after the next period).
@p @syntax{NEXT SENTENCE} was needed for COBOL programs that were coded according to pre-1985 standards that wish to nest one @statement{IF} inside another.  @xref{Use of VERB/END-VERB Constructs}, for an explanation of why @syntax{NEXT SENTENCE} was necessary.
@p Programs coded for 1985 (and beyond) standards don't need it, instead using the explicit scope-terminator @syntax{END-IF} to inform the compiler where @term{imperative-statement-2} (or @term{imperative-statement-1} if there is no @syntax{ELSE} clause coded) ends.  New GnuCOBOL programs should be coded to use the @syntax{END-IF} scope terminator for @syntax{IF} statements.  @xref{Use of VERB/END-VERB Constructs}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.22 INITIALIZE                                              **
@comment *********************************************************************
@page
@newsubsection{7.8.22,INITIALIZE}
@diagram{INITIALIZE,PD-INITIALIZE,PD-INITIALIZE,None}@p The @statement{INITIALIZE} initializes each @term{identifier-1} with certain specific values, depending upon the options specified.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{DATA}, @syntax{OF}, @syntax{THEN}, @syntax{TO} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{INITIALIZE} and @syntax{INITIALISE} are interchangeable.
@p @item The @syntax{WITH FILLER}, @syntax{REPLACING} and @syntax{DEFAULT} clauses are meaningful only if @term{identifier-1} is a group item.  They are accepted if it's an elementary item, but will serve no purpose.  The @syntax{VALUE} clause is meaningful in both cases.
@p @item A @term{category-name-1} and/or @term{category-name-2} may be any of the following:
@table @asis
@p @item @syntaxidx{ALPHABETIC}
@p The @syntaxref{PICTURE} of the data item only contains @syntax{A} symbols.
@p @item @syntaxidx{ALPHANUMERIC}
@p The @syntax{PICTURE} of the data item contains only @syntax{X} or a combination of @syntax{A} and @syntax{9} symbols.
@p @item @syntaxidx{ALPHANUMERIC-EDITED}
@p The @syntax{PICTURE}  of the data item contains only @syntax{X} or a combination of @syntax{A} and @syntax{9} symbols plus at least one @syntax{B}, @syntax{0} (zero) or @syntax{/} symbol.
@p @item @syntaxidx{NUMERIC}
@p The data item is one that is described with a picture less @syntaxref{USAGE} or has a @syntax{PICTURE} composed of nothing but @syntax{P}, @syntax{9}, @syntax{S} and @syntax{V} symbols.
@p @item @syntaxidx{NUMERIC-EDITED}
@p The @syntax{PICTURE} of the data item contains nothing but the symbol @syntax{9} and at least one of the editing symbols @syntax{$}, @syntax{+}, @syntax{-}, @syntax{CR}, @syntax{DB}, @syntax{.}, @syntax{,}, @syntax{*} or @syntax{Z}.
@p @item @syntaxidx{NATIONAL}
@p The data item is one containing nothing but the @syntax{N} symbol.
@p @item @syntaxidx{NATIONAL-EDITED}
@p The data item contains nothing but @syntax{N}, @syntax{B}, @syntax{/} and @syntax{0} symbols.
@end table
@comment Semantic Specifications:
@item From the sequence of @term{identifier-1} data items specified on the @statement{INITIALIZE}, a list of initialized fields referred to as the @i{field list} in the remainder of this section, will include:
@enumerate A
@p @item Every @term{identifier-1} that is an elementary item, including any that may have the @syntaxref{REDEFINES} clause in their descriptions.
@p @item Every non-FILLER elementary item subordinate to @term{identifier-1}, provided that elementary item neither contains a @syntax{REDEFINES} clause in its definition nor belongs to a group item @i{subordinate to} @term{identifier-1} which contains a @syntax{REDEFINES} clause in its definition.
@p @item If the optional @syntaxidx{WITH FILLER} clause is included on the @statement{INITIALIZE}, then every FILLER elementary item subordinate to each @term{identifier-1} will be included as well, provided that elementary item neither contains a @syntax{REDEFINES} clause in its definition nor belongs to a group item @i{subordinate to} @term{identifier-1} which contains a @syntax{REDEFINES} clause in its definition..
@end enumerate
@item Once a field list has been determined, each item in that field list will be initialized as if an individual @syntaxref{MOVE} statement to that effect had been coded.  The rules for initialization are as follows:
@p @item If no @syntaxidx{VALUE}, @syntaxidx{REPLACING} or @syntaxidx{DEFAULT} clauses are coded, each member of the field list will be initialized as if the figurative constant @syntax{ZERO} (if the field list item is numeric or numeric-edited) or @syntax{SPACES} (otherwise) were being moved to it.
@p @item If a @syntax{VALUE} clause is specified on the @statement{INITIALIZE}, each qualifying member of the field list having a compile-time @syntaxref{VALUE} specified in it's definition will be initialized to that value.  Field list members with @syntax{VALUE} clauses will qualify for this treatment as follows:
@enumerate A
@p @item If the @syntax{ALL} keyword was specified on the @syntax{VALUE} clause, all members of the field list with @syntax{VALUE} clauses will qualify.
@p @item If @term{category-name-1} is specified instead of @syntax{ALL}, only those members of the field list with @syntax{VALUE} clauses that also meet the criteria set down for the specified @term{category-name} (see the list above) will qualify.
@p @item If you need to apply @syntax{VALUE} initialization to multiple @term{category-name-1} values, you will need to use multiple @syntax{INITIALIZE} statements.
@end enumerate
@item If a @syntax{REPLACING} clause is specified on the @statement{INITIALIZE}, each qualifying member of the field list that was not already initialized by a @syntax{VALUE} clause, if any, will be initialized to the specified @term{literal-1} or @term{identifier-1} value.
@p Only those as-yet uninitialized list members meeting the criteria set forth for the specified @term{category-name-2} will qualify for this initialization.
@p If you need to apply @syntax{REPLACING} initialization to multiple @term{category-name-2} values, you may repeat the syntax after the reserved word @syntax{REPLACING}, as necessary.
@p @item If a @syntax{DEFAULT} clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).
@p @item The following example may help your understanding of how the @statement{INITIALIZE} works.  The sample code makes use of the COBDUMP program to dump the storage that is (or is not) being initialized.  @xref{COBDUMP,COBDUMP,COBDUMP,gnucobsp,GnuCOBOL Sample Programs}, for a source and cross-reference listing of the COBDUMP program.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DemoInitialize.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Item-1.
    05 I1-A VALUE ALL '*'.
       10 FILLER                PIC X(1).
       10 I1-A-1                PIC 9(1) VALUE 9.
    05 I1-B                     USAGE BINARY-CHAR.
    05 I1-C                     PIC A(1) VALUE 'C'.
    05 I1-D                     PIC X/X VALUE 'ZZ'.
    05 I1-E                     OCCURS 2 TIMES PIC 9.
PROCEDURE DIVISION.
000-Main.
    DISPLAY "MOVE HIGH-VALUES TO Item-1"
        PERFORM 100-Init-Item-1
        CALL "COBDUMP" USING Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1"
        INITIALIZE Item-1
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 WITH @syntax{FILLER}"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 WITH @syntax{FILLER}
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 ALL TO VALUE"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 ALPHANUMERIC TO VALUE
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 REPLACING NUMERIC BY 1"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 REPLACING NUMERIC BY 1
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    STOP RUN
    .

100-Init-Item-1.
    MOVE HIGH-VALUES TO Item-1
    .
@end example
@* When executed, this program produces the following output:
@p @smallexample
MOVE HIGH-VALUES TO Item-1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF FF FF FF FF FF FF FF FF                      .........

INITIALIZE Item-1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF 30 00 20 20 2F 20 30 30                      .0.  / 00

INITIALIZE Item-1 WITH @syntax{FILLER}
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 20 30 00 20 20 2F 20 30 30                       0.  / 00

INITIALIZE Item-1 ALL TO VALUE
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 2A 2A FF 43 5A 5A 20 FF FF                      **.CZZ ..

INITIALIZE Item-1 REPLACING NUMERIC BY 1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF 31 01 FF FF FF FF 31 31                      .1.....11
@end smallexample
@end enumerate
@comment *********************************************************************
@comment ** 7.8.23 INITIATE                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.23,INITIATE}
@diagram{INITIATE,PD-INITIATE,PD-INITIATE,None}@p The @statement{INITIATE} starts Report-Writer Control System (RWCS) processing for a report.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Each @term{report-name-1} must be the name of a report having an @syntaxrefalt{RD,REPORT SECTION} defined for it.
@p @item The file in whose @syntaxrefalt{FD,File/Sort-Description} a @syntax{REPORT @term{report-name-1}} clause exists must be open for @syntax{OUTPUT} or @syntax{EXTEND} at the time the @statement{INITIATE} is executed.  @xref{OPEN}, for more information on file open modes.
@p @item The @statement{INITIATE} will initialize all of the following for each report named on the statement:
@itemize @bullet
@p @item All sum counters, if any, will be set to 0
@p @item The report's @registerrefalt{LINE-COUNTER,Special Registers} will be set to 0
@p @item The report's @register{PAGE-COUNTER} will be set to 1
@end itemize
@item No report content will actually presented to the report file as a result of a successful @statement{INITIATE} --- that will not occur until the first @statementref{GENERATE} is executed.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.24 INSPECT                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.24,INSPECT}
@diagram{INSPECT,PD-INSPECT,PD-INSPECT,None}@p The @statement{INSPECT} is used to perform various counting and/or data-alteration operations against strings.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{INITIAL} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this words has no effect upon the program.
@p @item If a @syntaxidx{CONVERTING} clause is specified, neither the @syntaxidx{TALLYING} nor @syntaxidx{REPLACING} clauses may be used.
@p @item If either the @syntax{TALLYING} or @syntax{REPLACING} clauses are specified, the @syntax{CONVERTING} clause cannot be used.
@p @item If both the @syntax{TALLYING} and @syntax{REPLACING} clauses are specified, they must be specified in the order shown.
@p @item All literals and identifiers must be explicitly or implicitly defined as alphanumeric or alphabetic.
@p @item If @term{function-reference-1} is specified, it must be an invocation of an intrinsic function that returns a @i{string} result.  Additionally, only the @syntax{TALLYING} clause may be specified.
@p @item If @term{literal-1} is specified, only the @syntax{TALLYING} clause may be specified.
@comment Semantic Specifications:
@p @item Whichever is specified --- @term{literal-1}, @term{identifier-1} or @term{function-reference-1} --- that item will be referred to in the discussions that follows as the '@i{inspect subject}'.
@p @item The three optional clauses control the operation of this statement as follows:
@enumerate A
@p @item The @syntax{CONVERTING} clause replaces one or more individual characters found in the inspect subject with a different character in much the same manner as is possible with the @statementref{TRANSFORM}.
@p @item The @syntax{REPLACING} clause replaces one or more sub strings located in the inspect subject with a different, but equally-sized replacement sub string.  If you need to replace a sub string with another of a @i{different} length, consider using either the @intrinsicref{SUBSTITUTE} or the @intrinsicref{SUBSTITUTE-CASE}.
@p @item The @syntax{TALLYING} clause counts the number of occurrences of one or more strings of characters in the inspect subject.
@end enumerate
@item The optional @syntax{INITIAL} clauses may be used to limit the range of characters in the inspect subject that the  @syntax{CONVERTING}, @syntax{REPLACING} or @syntax{TALLYING} instruction in which they occur will apply.  We call this the '@i{target range}' of the inspect subject.  The target range is defined as follows:
@enumerate A
@p @item If there is no @syntax{INITIAL} clause specified, the target range is the entire inspect subject.
@p @item Either a @syntax{BEFORE} phrase, an @syntax{AFTER} phrase or both may be specified.  They may be specified in any order.
@p @item The starting point of the target range will be the first character following the sub string identified by the @syntax{AFTER} specification.  The ending point will be the last character immediately preceding the sub string identified by the @syntax{BEFORE} specification.
@p @item If no @syntax{AFTER} is specified, the first character position of the target range will be character position #1 of the inspect subject.
@p @item If no @syntax{BEFORE} is specified, the last character position of the target range will be the last character position of the inspect subject.
@end enumerate
@item The following points apply to the use of the @syntax{TALLYING} clause:
@enumerate A
@p @item While there will typically be only be a single set of counting instructions on an @syntax{INSPECT}:
@p @example
INSPECT Character-String
    TALLYING C-ABC FOR ALL "ABC"
@end example
@* There could be multiple counting instructions specified:
@p @example
INSPECT Character-String
    TALLYING C-ABC FOR ALL "ABC"
             C-BCDE FOR ALL "BCDE"
@end example
@* When there @i{are} multiple instructions, the one specified first will take priority over the one specified second, (and so forth) as the @syntax{INSPECT} proceeds forward through the inspect subject, character-by-character.
@p With the above example, if the inspect subject were @syntax{--ABCDEF----BCDEF--}, the final result of the counting would be that C-ABC would be incremented by 1 while C-BCDE would be incremented only once; although the human eye clearly sees two "BCDE" sequences, the @syntax{INSPECT ... TALLYING} would only "see" the second --- the first would have been processed by the first (higher-priority) counting instruction.
@p @item Each set of counting instructions contains the following information:
@enumerate a
@p @item A target range, specified by the presence of an @syntax{AFTER INITIAL} and/or @syntax{BEFORE INITIAL} clause; the rules for specifying target ranges were covered previously.
@p @item A Target Sub string --- this is a sequence of characters to be located somewhere in the inspect subject and counted.  Target sub strings may be defined as a literal value (figurative constants are allowed) or by the contents of an identifier.  If the target sub string is specified as a figurative constant, it will be assumed to have a length of one (1) character.  The keywords before the literal or identifier control how many target sub strings could be identified from that replacement instruction, as follows:
@p @syntax{ALL} --- identifies every possible target sub string that occurs within the target range.  There are three occurrences of @syntax{ALL 'XX'} found in @syntax{aXXabbXXccXXdd}.
@p @syntax{LEADING} --- identifies only an occurrence of the target sub string found either at the first character position of the target range or immediately following a previously-found occurrence.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there is one occurrence of @syntax{LEADING 'a'} (the first character).
@p @syntax{TRAILING} --- identifies only an occurrence of the target sub string found either at the very end of the target range or toward the end, followed by nothing but other occurrences.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there are two occurrences of @syntax{TRAILING 'd'}.
@p The @syntax{CHARACTERS} option will match any one single character, regardless of what that character is.
@end enumerate
@item @term{identifier-2} will be incremented by 1 each time the target sub string is found within the target range of the inspect subject.  The @syntax{INSPECT} statement @i{will not} zero-out @term{identifier-2} at the start of execution of the @syntax{INSPECT} --- it is the programmer's responsibility to ensure that all @term{identifier-2} data items are properly initialized to the desired starting values prior to execution of the @syntax{INSPECT}.
@end enumerate
@item The following points apply to the use of the @syntax{REPLACING} clause:
@enumerate A
@p @item While there will typically be only be a single set of replacement instructions on an @syntax{INSPECT}:
@p @example
INSPECT Character-String
    REPLACING ALL "ABC" BY "DEF"
@end example
@* There could be multiple replacement instructions:
@p @example
INSPECT Character-String
    REPLACING ALL "ABC" BY "DEF"
              ALL "BCDE" BY "WXYZ"
@end example
@* When there @i{are} multiple replacement instructions, the one specified first will take priority over the one specified second, (and so forth) as the @syntax{INSPECT} proceeds forward through the inspect subject, character-by-character.
@p With the above example, if the inspect subject were @syntax{--ABCDEF----BCDEF--}, the final result of the replacement would be @syntax{--DEFDEF----WXYZF--}.
@p @item Each set of replacement instructions contains the following information:
@enumerate a
@p @item A target range, specified by the presence of an @syntax{AFTER INITIAL} and/or @syntax{BEFORE INITIAL} clause; the rules for specifying target ranges were covered previously.
@p @item A Target Sub string --- this is a sequence of characters to be located somewhere in the inspect subject and subsequently replaced with a new value.  Target sub strings, which are specified before the @syntax{BY} keyword, may be defined as a literal value (figurative constants are allowed) or by the contents of an identifier.  If the target sub string is specified as a figurative constant, it will be assumed to have a length of one (1) character.  The keywords before the literal or identifier control how many target sub strings could be identified from that replacement instruction, as follows:
@p @syntax{ALL} --- identifies every possible target sub string that occurs within the target range.  There are three occurrences of @syntax{ALL 'XX'} found in @syntax{aXXabbXXccXXdd}.
@p @syntax{FIRST} --- the first occurrence of the target sub string found within the target range.  The @syntax{FIRST 'XX'} found in @syntax{aXXabbXXccXXdd} would be the one found between the "a" and "b" characters.
@p @syntax{LEADING} --- an occurrence of the target sub string found either at the first character position of the target range or immediately following a previously-found occurrence.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there is one occurrence of @syntax{LEADING 'a'} (the first character).
@p @syntax{TRAILING} --- an occurrence of the target sub string found either at the very end of the target range or toward the end, followed by nothing but other occurrences.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there are two occurrences of @syntax{TRAILING 'd'}.
@p The @syntax{CHARACTERS} option will match any one single character.  When you use this option, the replacement sub string (see the next item) must be exactly one character in length.
@p @item A Replacement Sub string --- this is the sequence of characters that should replace the target sub string.  Replacement sub strings are specified after the @syntax{BY} keyword.  They too may be specified as a literal, either with or without an @syntax{ALL} prefix (again, figurative constants are allowed) or the value of an identifier.  If a figurative constant is coded, the @syntax{ALL} keyword will be assumed, even if it wasn't specified.  Literals without @syntax{ALL} will either be truncated or padded with spaces on the right to match the length of the target sub string.  Literals with @syntax{ALL} or figurative constants will be repeated as necessary to match the length of the target sub string.  Identifiers specified as replacement sub strings must be defined with a length equal to that of the target sub string.
@end enumerate
@end enumerate
@item When both @syntax{REPLACING} and @syntax{TALLYING} are specified:
@enumerate A
@p @item The @syntax{INSPECT} statement will make a single pass through the sequence of characters comprising the inspect subject.  As the pointer to the current inspect target character reaches a point where it falls within the explicit or implicit target ranges specified on the operational instructions of the two clauses, the actions specified by those instructions will become eligible to be taken.  As the character pointer reaches a point where it falls past the end of target ranges, the instructions belonging to those target ranges will become disabled.
@p @item At any point in time, there may well be multiple@syntax{REPLACING} and/or @syntax{TALLYING} operational instructions  active.  Only one of the @syntax{TALLYING} and one of the @syntax{REPLACING} instructions (if any) can be executed for any one character pointer position.  In each case, it will be the first of the instructions in each category that produces a match with it's target string specification.
@p @item When both a @syntax{TALLYING} and a @syntax{REPLACING} instruction have been selected for execution, the @syntax{TALLYING} instruction will be executed first.  This guarantees that @syntax{TALLYING} will compute occurrences based upon the @i{initial} value of the inspect subject before any replacements occur.
@end enumerate
@item The following points apply to the use of the @syntax{CONVERTING} clause:
@enumerate A
@p @item A @syntax{CONVERTING} clause performs a series of single-character substitutions against a data item in much the same manner as is possible with the @statementref{TRANSFORM}.
@p @item Unlike the @syntax{TALLYING} and @syntax{REPLACING} clauses, both of which may have multiple operations specified, there may be only one @syntax{CONVERTING} operation per @syntax{INSPECT}.
@p @item If the length of @term{literal-7} or @term{identifier-8} (the "from" string) @i{exceeds} the length of @term{literal-8} or @term{identifier-9} (the "to" string), then the "to" string will be assumed to be padded to the right with enough spaces to make it the same length as the "from" string.
@p @item If the length of the "from" string @i{is less than} the length of the "to" string, then the "to" string will be truncated to the length of the "from" string.
@p @item Each character, in turn, within the "from" string will be searched for in the target range of the inspect subject.  Each located occurrence will be replaced by the corresponding character of the "to" string.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.25 MERGE                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.25,MERGE}
@diagram{MERGE,PD-MERGE-Info,PD-MERGE-TeX,PD-DUPLICATES}@p The @statement{MERGE} merges the contents of two or more files that have each been pre-sorted on a set of specified identical keys.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{sort-file-1} named on the @statement{MERGE} must be defined using a sort description (@syntaxrefalt{SD,File/Sort-Description}).  This file is referred to in the remainder of this discussion as the "merge work file".
@p @item Each @term{file-name-1}, @term{file-name-2} and @term{file-name-3} (if specified) must reference @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{ORGANIZATION SEQUENTIAL} files.  These files must be defined using a file description (@syntaxrefalt{FD,File/Sort-Description}).
@p @item The @term{identifier-1} @dots{} field(s) must be defined as field(s) within a record of @term{sort-file-1}.
@p @item The record descriptions of @term{file-name-1}, @term{file-name-2}, @term{file-name-3} (if any) and @term{sort-file-1} are assumed to be identical in layout and size.  While the actual data names used for fields in these files' records may differ, the structure of records, @syntaxref{PICTURE} of fields, @syntaxref{USAGE} of fields, size of fields and location of fields within the records should match field-by-field across all files, at least as far as the @syntax{KEY} fields are concerned.
@p @item A common programming technique when using the @statement{MERGE} is to define the records of all files involved as simple elementary items of the form @syntax{01 record-name PIC X(n).} where n is the record size.  The only file where records are actually described in detail would then be @term{sort-file-1}.
@p @item The following rules apply to the files named on the @syntax{USING} clause:
@enumerate A
@p @item None of them may be open at the time the @syntax{MERGE} is executed.
@p @item Each of those files is assumed to be already sorted according to the specifications set forth on the @statement{MERGE}'s @syntaxidx{KEY} clause.
@p @item No two of those files may be referenced on a @syntaxref{SAME RECORD AREA}, @syntax{SAME SORT AREA} or @syntax{SAME SORT-MERGE AREA} statement.
@end enumerate
@item The merging process is as follows:
@enumerate A
@p @item As the @statement{MERGE} begins execution, the first record in each of the @syntaxidx{USING} files is read automatically.
@p @item As the @statement{MERGE} executes, the current record from each of the @syntax{USING} files is examined and compared to each other according to the rules set forth by the @syntax{KEY} clause and the alphabet (@pxref{Alphabet-Name-Clause}) specified on the @syntaxidx{COLLATING SEQUENCE} clause.  The record that should be next in sequence will be written to the merge work file and the @syntax{USING} file from which that record came will be read so that its next record is available.  As end-of-file conditions are reached on @syntax{USING} files, those files will be excluded from further processing --- processing continues with the remaining files until all the contents of all of them have been exhausted.
@p @item After the merge work file has been populated, the merged data will be written to each @term{file-name-3} if the @syntaxidx{GIVING} clause was specified, or will be processed by utilizing an @syntaxidx{OUTPUT PROCEDURE}.
@p @item When @syntax{GIVING} is specified, none of the @term{file-name-3} files can be open at the time the @statement{MERGE} is executed.
@p @item When an output procedure is used, the procedure(s) specified on the @syntax{OUTPUT PROCEDURE} clause will be invoked as if by a procedural @syntaxrefalt{PERFORM,Procedural PERFORM} statement with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Merged records may be read from the merge work file --- one at a time --- within the output procedure using the @syntaxref{RETURN} statement.
@p A @statementref{GO TO} that transfers control out of the output procedure will terminate the @statement{MERGE} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an output procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the merge work file are lost.  You may, however, re-execute the @statement{MERGE} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A MERGE, OR RE-STARTING A PREVIOUSLY-CANCELLED MERGE IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An output procedure should be terminated in the same way a procedural @statement{PERFORM} would be.  Usually, this action will be taken once the @statement{RETURN} indicates that all records in the merge work file have been processed, but termination could occur at @i{any} time --- via an @statementref{EXIT} --- if required.
@p Neither a file-based @statementrefalt{SORT,File-Based SORT} nor another @statement{MERGE} may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.
@p @item Once the output procedure terminates, or the last @term{file-name-3} file has been populated with merged data, the output phase --- and the @statement{MERGE} itself --- is complete.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.26 MOVE                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.26,MOVE}
@menu
* 7.8.26.1: Simple MOVE
* 7.8.26.2: MOVE CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 7.8.26.1 Simple MOVE                                           **
@comment *********************************************************************
@newunit{7.8.26.1,Simple MOVE}
@diagram{Simple MOVE,PD-MOVE-1,PD-MOVE-1,None}@p The Simple @statement{MOVE} moves a specific value to one or more receiving data items.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The @statement{MOVE} will replace the contents of one or more receiving data items (@term{identifier-2}) with a new value --- the one specified by @term{literal-1} or @term{identifier-1}.
@p @item Only numeric data can be moved to a numeric or numeric-edited @term{identifier-2}.  A @syntax{MOVE} involving numeric data will perform any necessary format conversions that might be necessary due to differing @syntaxref{USAGE} specifications.
@p @item The contents of the @term{identifier-1} data item will not be changed, unless that same data item appears as an @term{identifier-2}.  Note that such situations will cause a warning message to be issued by the compiler, if warning messages are enabled.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.26.2 MOVE CORRESPONDING                                    **
@comment *********************************************************************
@page
@newunit{7.8.26.2,MOVE CORRESPONDING}
@diagram{MOVE CORRESPONDING,PD-MOVE-2,PD-MOVE-2,None}@p The @statement{MOVE CORRESPONDING} similarly-named items from one group item to another.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{CORRESPONDING} may be abbreviated as @syntax{CORR}.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for a discussion of how corresponding matches between two group items are established.
@p @item When corresponding matches are established, the effect of a @syntax{MOVE CORRESPONDING} on those matches will be as if a series of individual @syntax{MOVE}s were done --- one for each match.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.27 MULTIPLY                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.27,MULTIPLY}
@menu
* 7.8.27.1: MULTIPLY BY
* 7.8.27.2: MULTIPLY GIVING
@end menu
@comment *********************************************************************
@comment ** 7.8.27.1 MULTIPLY BY                                           **
@comment *********************************************************************
@newunit{7.8.27.1,MULTIPLY BY}
@diagram{MULTIPLY BY,PD-MULTIPLY-1,PD-MULTIPLY-1,None}@p The @statement{MULTIPLY BY} computes the product of one or more data items (@term{identifier-2}) and either a numeric literal or another data item.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric un-edited data items; @term{literal-1} must be a numeric literal.
@p @item The product of @term{identifier-1} or @term{literal-1} and each @term{identifier-2}, in turn, will be computed and moved to each of the @term{identifier-2} data items, replacing the prior contents.
@p @item The value of @term{identifier-1} is not altered, unless that same data item appears as an @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.27.2,MULTIPLY GIVING                                       **
@comment *********************************************************************
@page
@newunit{7.8.27.2,MULTIPLY GIVING}
@diagram{MULTIPLY GIVING,PD-MULTIPLY-2,PD-MULTIPLY-2,None}@p The @statement{MULTIPLY GIVING} computes the product of two literals and/or data items and saves that result in one or more other data items.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric un-edited data items; @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item The product of @term{identifier-1} or @term{literal-1} and @term{identifier-2} or @term{literal-2} will be computed and moved to each of the @term{identifier-3} data items, replacing their old contents.
@p @item Neither the value of @term{identifier-1} nor @term{identifier-2} will be altered, unless either appears as an @term{identifier-3}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.28 OPEN                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.28,OPEN}
@diagram{OPEN,PD-OPEN,PD-OPEN,PD-OPEN}@p The @statement{OPEN} makes one or more files described in your program available for use.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{OTHER} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @syntax{SHARING} and @syntax{WITH LOCK} clauses may not both be specified in the same @statement{OPEN}.
@comment Semantic Specifications:
@p @item Any file defined in a GnuCOBOL program must be successfully opened before it or any of it's record descriptions may be referenced on:
@p A @statementref{CLOSE}
@p A @statementref{DELETE}
@p A @statementref{READ}
@p A @statementref{REWRITE}
@p A @statementref{START}
@p An @statementref{UNLOCK}
@p A @statementref{WRITE}
@p @item Any attempt to open a file that is already open will fail with a file status of 41 (@pxref{File Status Codes}).
@p @item Any open failure (including status 41) may be trapped using @syntaxref{DECLARATIVES} or an error procedure established using the @subpgmref{CBL_ERROR_PROC} built-in subroutine or even just checking the status field defined.  It is up to the programmer to check for bad statuses and respond accordingly such as issue a CLOSE before dealing with the problem.
@p @item @anchoridx{File OPEN Modes}The @syntaxidx{INPUT}, @syntaxidx{OUTPUT}, @syntaxidx{I-O} and @syntaxidx{EXTEND} open modes inform GnuCOBOL of the manner in which you wish to use the file, as follows:
@table @asis
@p @item @syntax{INPUT}
@p You may only read the existing contents of the file --- only the @syntax{CLOSE}, @syntax{READ}, @syntax{START} and @syntax{UNLOCK} statements will be allowed.  This enforcement takes place at execution time, not compilation time.
@p @item @syntax{OUTPUT}
@p You may only write new content (which will completely replace any previous file contents) to the file --- only the @syntax{CLOSE}, @syntax{UNLOCK} and @syntax{WRITE} statements will be allowed.  This enforcement takes place at execution time, not compilation time.
@p @item @syntax{I-O}
@p You may perform any operation you wish against the file --- all file I/O statements will be allowed.
@p @item @syntax{EXTEND}
@p You may only write new content (which will be appended after the previously existing file contents) to the file --- only the @syntax{CLOSE}, @syntax{UNLOCK} and @syntax{WRITE} statements will be allowed.  This enforcement takes place at execution time, not compilation time.  You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.
@end table
@item The @syntaxidx{SHARING} clause informs the GnuCOBOL file runtime modules how you are willing to co-exist with any other GnuCOBOL programs that may attempt to open the same file after your program does.  @xref{File Sharing}, for an explanation of the @syntax{SHARING} clause.
@p @item The @syntaxidx{WITH LOCK} option will be functional only if your GnuCOBOL build can support it.  GnuCOBOL built for MinGW or native Windows will not, because the Unix "fcntl() primitive doesn't exist in those environments.  GnuCOBOL built for Cygwin or Unix will.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.29 PERFORM                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.29,PERFORM}
@menu
* 7.8.29.1: Procedural PERFORM
* 7.8.29.2: Inline PERFORM
* 7.8.29.3: VARYING
@end menu
@comment *********************************************************************
@comment ** 7.8.29.1 Procedural PERFORM                                    **
@comment *********************************************************************
@newunit{7.8.29.1,Procedural PERFORM}
@diagram{Procedural PERFORM,PD-PERFORM-1,PD-PERFORM-1,None}@p This format of the @statement{PERFORM} is used to transfer control to one or more procedures, which will return control back when complete.  Execution of the procedure(s) can be done a single time, multiple times, repeatedly until a condition becomes TRUE or forever (with some way of breaking out of the control of the @syntax{PERFORM} or of halting program execution within the procedure(s)).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{WITH} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item The reserved word and phrase @syntax{FOREVER} and @syntax{UNTIL EXIT} are interchangeable.
@comment Semantic Specifications:
@p @item  Both @term{procedure-name-1} and @term{procedure-name-2} must be procedure division sections or paragraphs defined in the same program as the @syntax{PERFORM} statement.  If @term{procedure-name-2} is specified, it must follow @term{procedure-name-1} in the program's source code.
@p @item The @define{perform scope} is defined as being the statements within @term{procedure-name-1}, the statements within @term{procedure-name-2} and all statements in all procedures defined between them.
@p @item @term{literal-1} must be a numeric literal or a reference to a function that returns a numeric value.  The value must be an integer greater than zero.
@p @item @term{identifier-1} must be an elementary un-edited numeric data item with an integer value greater than zero.
@p @item Without the @syntaxidx{UNTIL}, @syntaxidx{UNTIL EXIT}, @syntaxidx{TIMES}, @termrefalt{VARYING-Clause,VARYING} or @syntaxidx{FOREVER} clauses, the code within the perform scope will be executed once, after which control will return to the statement following the @syntax{PERFORM}.
@p @item  The @syntax{FOREVER} option will repeatedly execute the code within the perform scope with no conditions defined for termination of the repetition --- it will be up to the programmer to include an @statementrefalt{EXIT SECTION,EXIT} or @statement{EXIT PARAGRAPH} within the procedure(s) being performed that will break out of the loop.
@p @item The @syntax{TIMES} option will repeat the execution of the code within the perform scope a fixed number of times.  When the @syntax{PERFORM} statement begins execution, an internal repeat counter (not accessible to the programmer) will be set to the value of @term{literal-1} or the value within @term{identifier-1}.
@p If the counter has a value greater than zero, the statement(s) within the @syntax{PERFORM} scope will be executed, after which the counter will be decremented by 1 with each repetition.  Once that counter reaches zero, repetition will cease and control will fall into the next statement following the @syntax{PERFORM}.
@p If the @term{identifier-1} option was used, altering the value of that data item within the perform scope will @i{not} affect the repetition count.
@p @item The @syntax{UNTIL @term{conditional-expression-1}} option will repeat the code within the perform scope until the specified conditional expression evaluates to a TRUE value.
@p @item The optional @syntaxidx{WITH TEST} clause will control whether @syntax{UNTIL} testing occurs @syntax{BEFORE} the statements within the perform scope are executed on each iteration (creating the possibility --- if @term{conditional-expression-1} is initially TRUE --- that the statements within the perform scope will never be executed) or @syntaxidx{AFTER} (guaranteeing the statements within the perform scope will be executed at least once).
@p The default, if this clause is absent, is @syntax{WITH TEST BEFORE}.
@p This clause may not be coded when the @syntax{TIMES} clause is used.
@p @item The optional @term{VARYING-Clause} is a mechanism that creates an advanced loop-management mechanism complete with one or more numeric data items being automatically incremented (or decremented) on each loop iteration as well as the termination control of an @syntax{UNTIL} clause.  @xref{VARYING}, for the details.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.29.2 Inline PERFORM                                        **
@comment *********************************************************************
@page
@newunit{7.8.29.2,Inline PERFORM}
@diagram{Inline PERFORM,PD-PERFORM-2,PD-PERFORM-2,None}@p This format of the @statement{PERFORM} is identical in operation to the procedural @syntax{PERFORM}, except for the fact that the statement(s) comprising the perform scope (@term{imperative-statement-1}) (@pxref{Imperative Statement}) are now specified in-line with the @syntax{PERFORM} code rather than in procedures located elsewhere within the program.
@comment *********************************************************************
@comment ** 7.8.29.3 VARYING                                               **
@comment *********************************************************************
@page
@newunit{7.8.29.3,VARYING}
@diagram{VARYING,PD-PERFORM-VARYING,PD-PERFORM-VARYING,None}@p The @syntax{VARYING} clause, available on both formats of the @syntax{PERFORM} statement, is a looping mechanism that allows for the specification of one or more numeric data items that will be initialized to a programmer-specified value and automatically incremented by another programmer-specified value after each loop iteration.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item All identifiers used in a @term{VARYING-Clause} must be elementary, un-edited numeric data items.  All literals must be numeric literals.
@p @item The following points describe the sequence of events that take place as a result of the @syntax{VARYING} portion of the clause:
@enumerate A
@p @item When the @syntax{PERFORM} begins execution, the @syntax{FROM} value will be moved to @term{identifier}.
@p @item If the @syntax{PERFORM} specifies or implies @syntax{WITH TEST BEFORE}, @term{conditional-expression-1} will be evaluated and processing of the @syntax{PERFORM} will halt if the expression evaluates to TRUE.  If @syntax{WITH TEST BEFORE} was @i{not} specified or implied, or if the conditional expression evaluated to FALSE, processing proceeds with step (C).
@p @item The statements within the perform scope will be executed.  If a @syntax{GO TO} executed within the perform scope transfers control to a point outside the perform scope, processing of the @syntax{PERFORM} will halt.
@p @item When the statements within the perform scope terminate the loop iteration, by@dots{}
@itemize @bullet
@p @item @dots{}allowing the flow of execution to attempt to fall past the last statement in the perform scope, or@dots{}
@p @item @dots{}executing an @statementrefalt{EXIT PERFORM CYCLE,EXIT}, or@dots{}
@p @item @dots{}executing an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} when there is only one paragraph (or section) in the perform scope ( this option only applies to a procedural @syntax{PERFORM})
@end itemize
@* Control will return back to the @syntax{PERFORM}, where --- if @syntax{WITH TEST AFTER} was specified --- @term{conditional-expression-1} will be evaluated and processing of the @syntax{PERFORM} will halt if the expression evaluates to TRUE.  If @syntax{WITH TEST AFTER} was @i{not} specified, or if the conditional expression evaluated to FALSE, processing continues with the next step.
@p @item The @syntax{BY} value, if any, will be added to @term{identifier-2}.  If no @syntax{BY} is specified, it will be treated as if "BY 1" had been specified.
@p @item Return to step (C).
@end enumerate
@item Most @term{VARYING-Clause}s have no @syntax{AFTER} specified.  Those that do, however, are establishing a loop-within-a-loop situation where the process described above in steps (A) through (F) will take place from the @syntax{AFTER}, and those six processing steps actually replace step (C) of the @syntax{VARYING}.  This "nesting" process can continue indefinitely, with each additional @syntax{AFTER}.
@end enumerate
@* This is the point where an example should really help you see this at work.  Observe the following code which defines a two-dimensional (3 row by 4 column) table and a pair of numeric data items to be used to subscript references to each element of the table:
@p @example
01  PERFORM-DEMO.
    05 PD-ROW             OCCURS 3 TIMES.
       10 PD-COL          OCCURS 4 TIMES
          15 PD           PIC X(1).
01  PD-Col-No             PIC 9 COMP.
01  PD-Row-No             PIC 9 COMP.
@end example
@* Let's say the 3x4 "grid" defined by the above structure has these values:
@p @example
A B C D
E F G H
I J K L
@end example
@* This code will display @syntax{ABCDEFGHIJKL} on the console output window:
@p @example
PERFORM WITH TEST AFTER
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* While this code will display @syntax{AEIBFJCGKDHL} on the console output window:
@p @example
PERFORM WITH TEST AFTER
        VARYING PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
          AFTER PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* While we're looking at sample code, this code displays @syntax{ABCEFG}:
@p @example
PERFORM
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* By removing the @syntax{WITH TEST} clause, the statement is now assuming @syntax{WITH TEST BEFORE}.  Since testing now happens @i{before} the @statement{DISPLAY} gets executed, when PD-Row-No is 3 and PD-Col-No is 4 the @statement{DISPLAY} won't be executed.
@p Most COBOL programmers, when using @syntax{WITH TEST BEFORE} explicitly or implicitly have developed the habit of using ">" rather than "=" on @syntax{UNTIL} clauses.  This would make the sample code:
@p @example
PERFORM
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No > 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No > 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* With this change, @syntax{ABCDEFGHIJKL} is once again displayed.
@comment *********************************************************************
@comment ** 7.8.30 READ                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.30,READ}
@menu
* 7.8.30.1: Sequential READ
* 7.8.30.2: Random READ
@end menu
@comment *********************************************************************
@comment ** 7.8.30.1 Sequential READ                                       **
@comment *********************************************************************
@newunit{7.8.30.1,Sequential READ}
@diagram{Sequential READ,PD-READ-1,PD-READ-1,None}@p This form of the @statement{READ} retrieves the next (or previous) record from a file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AT}, @syntax{RECORD} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @term{file-name-1} file @i{must} have been defined via an @syntaxrefalt{FD,File/Sort-Description}, not an @syntax{SD}.
@comment Semantic Specifications:
@p @item The @term{file-name-1} file must currently be open for @syntaxrefalt{INPUT,File OPEN Modes} or @syntax{I-O}.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with an @syntax{ACCESS MODE RANDOM}, this statement cannot be used.
@p @item If @term{file-name-1} was specified as @syntax{ACCESS MODE SEQUENTIAL}, this is the @i{only} format of the @statement{READ} that is available.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with @syntax{ACCESS MODE DYNAMIC}, this statement as well as a random @syntaxrefalt{READ,Random READ} may be used.
@p @item The keywords @syntaxidx{NEXT} and @syntaxidx{PREVIOUS} specify what direction of "travel" the reading process will take through the file.  If neither is specified, @syntax{NEXT} is assumed.
@p @item The @syntax{PREVIOUS} option is available only for @syntax{ORGANIZATION INDEXED} files.
@p @item When reading any sequential (any organization) or relative file, the "next" direction refers to the physical sequence of records in the file.  When reading an indexed file, the "next" and "previous" directions refer to the sequence of primary or alternate record key values in the file's records, regardless of where the records physically occur within the file.
@p @item The minimal statement @syntax{READ @term{file-name-1}} is perfectly legal according to @i{both} READ formats.  For that reason, when @syntax{ACCESS MODE DYNAMIC} has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a @i{sequential} @syntax{READ}, you must add either @syntax{NEXT} or @syntax{PREVIOUS} to the statement (otherwise it will be treated as a random @syntax{READ}).
@p @item A successful sequential READ will retrieve the next available record from @term{file-name-1}, in either a "next" or "previous" direction from the most-recently-read record, depending upon the use of the @syntax{NEXT} or @syntax{PREVIOUS} option.  The newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's @syntax{FD}.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item When an @syntax{ORGANIZATION RELATIVE} file has been successfully read, the file's @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the retrieved record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{AT END} clause, if coded, is used to detect and react to the failure of an attempt to retrieve another record from the file due to an end-of-file (i.e. no more records) condition.
@p @item The optional @syntax{NOT AT END} clause, if coded, will check for a file status value of 00.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.30.1 Random READ                                           **
@comment *********************************************************************
@page
@newunit{7.8.30.2,Random READ}
@diagram{Random READ,PD-READ-2,PD-READ-2,None}@p This form of the @statement{READ} retrieves an arbitrary record from an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS}, @syntax{KEY} (on the @syntax{INVALID} and @syntax{NOT INVALID} clauses), @syntax{RECORD} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @term{file-name-1} file @i{must} have been defined via an @syntaxrefalt{FD,File/Sort-Description}, not an @syntax{SD}.
@comment Semantic Specifications:
@p @item The @term{file-name-1} file must currently be open for @syntaxrefalt{INPUT,File OPEN Modes} or @syntax{I-O}.
@p @item If the @syntax{ACCESS MODE} of @term{file-name-1} is @syntax{SEQUENTIAL}, or the @syntax{ORGANIZATION} of the file is any form of sequential, this format of the @statement{READ} cannot be used.
@p @item If the @syntax{ACCESS MODE} of @term{file-name-1} is @syntax{RANDOM}, this is the @i{only} format of the @statement{READ} that is available.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with @syntax{ACCESS MODE DYNAMIC}, this statement as well as a sequential @syntaxrefalt{READ,Sequential READ} may be used.
@p @item The minimal statement @syntax{READ @term{file-name-1}} is perfectly legal according to @i{both} READ formats.  For that reason, when @syntax{ACCESS MODE DYNAMIC} has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a @i{random} @syntax{READ}, you must omit the @syntax{NEXT} or @syntax{PREVIOUS} available to the sequential format of the @statement{READ} to ensure the statement @i{will} be treated as a random @syntax{READ}.
@p @item The optional @syntaxidx{KEY} clause tells the compiler how a record is to be located in the file.  If the clause is absent, and@dots{}
@enumerate A
@p @item @dots{}if the file is an @syntax{ORGANIZATION RELATIVE} file, the contents of the field declared as the file's @syntax{RELATIVE KEY} will be used to identify a record, otherwise@dots{}
@p @item @dots{}if the file is an @syntax{ORGANIZATION INDEXED} file, the contents of the field declared as the file's @syntax{RECORD KEY} will be used to identify a record.
@end enumerate
@item But, if the @syntax{KEY} clause @i{is} specified, and@dots{}
@enumerate A
@p @item @dots{}if the file is an @syntax{ORGANIZATION RELATIVE} file, the contents of @term{identifier-2} will be used as the relative record number of the record to be accessed --- @term{identifier-2} need not be the @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field of the file (although it could be if you wish).
@p @item @dots{}if the file is an @syntax{ORGANIZATION INDEXED} file, @term{identifier-2} @i{must} be the @syntaxrefalt{RECORD KEY,ORGANIZATION INDEXED} or one of the file's @syntax{ALTERNATE RECORD KEY} fields (if any) --- the current contents of that field will identify the record to be accessed.  If an alternate record key is used, and that key allows duplicate values, the record accessed will be the @i{first} one having that key value.
@end enumerate
@item Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's @syntax{FD}.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item When an @syntax{ORGANIZATION RELATIVE} file has been successfully read, the file's @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the retrieved record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.31 READY TRACE                                             **
@comment *********************************************************************
@page
@newsubsection{7.8.31,READY TRACE}
@diagram{READY TRACE,PD-READY-TRACE,PD-READY-TRACE,None}@p The @statement{READY TRACE} turns procedure or procedure-and-statement tracing on.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item In order for this statement to be functional, tracing code must have been generated into the compiled program using either the @switchidx{-ftrace} (procedures only) or @switch{-ftraceall} (procedures and statements).
@p @item Tracing may be turned off at any point by executing the @statementref{RESET TRACE}.
@p @item The @envvarruntimeref{COB_SET_TRACE} provides another way to control tracing.  If this environment variable is set to a value of "Y" prior to the start of program execution, tracing starts at the point the program begins execution, as if @syntax{READY TRACE} were the first executed statement.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.32 RELEASE                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.32,RELEASE}
@diagram{RELEASE,PD-RELEASE,PD-RELEASE,None}@p The @statement{RELEASE} adds a new record to a sort work file.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item This statement is valid only within the @syntax{INPUT PROCEDURE} of a file-based @statementrefalt{SORT,File-Based SORT}.
@p @item The specified @term{record-name-1} must be a record defined to the sort description (@syntaxrefalt{SD,File/Sort-Description}) of the sort work file being processed by the current sort.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the @term{file-name-1}.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{RELEASE}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.33 RESET TRACE                                             **
@comment *********************************************************************
@page
@newsubsection{7.8.33,RESET TRACE}
@diagram{RESET TRACE,PD-RESET-TRACE,PD-RESET-TRACE,None}@p The @statement{RESET TRACE} turns procedure or procedure-and-statement tracing off.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item By default, procedure and procedure-and-statement tracing is off as programs begin execution.  The @statementref{READY TRACE} can be used to turn tracing on.
@p @item In order for this statement to be functional, tracing code must have been generated into the compiled program using either the @switchidx{-ftrace} (procedures only) or @switchidx{-ftraceall} (procedures and statements).
@p @item The @envvarruntimeref{COB_SET_TRACE} provides another way to control tracing.  If this environment variable is set to a value of "Y" prior to the start of program execution, tracing started at the point the program begins execution, as if @syntax{READY TRACE} were the first executed statement.  The @syntax{RESET TRACE} statement, if executed, will then turn off tracing.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.34 RETURN                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.34,RETURN}
@diagram{RETURN,PD-RETURN,PD-RETURN,None}@p The @statement{RETURN} reads a record from a sort- or merge work file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AT} and @syntax{RECORD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @statement{RETURN} is valid only within the @syntax{OUTPUT PROCEDURE} of a file-based @syntaxrefalt{SORT,File-Based SORT} or a @statementref{MERGE} statement.
@p @item The @term{sort-file-name-1} file must be a sort- or merge work file defined with a @syntaxrefalt{SD,File/Sort-Description}, not an @syntax{FD}.
@p @item A successful @syntax{RETURN} will retrieve the next available record from @term{sort-file-name-1}.  The newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's SD.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item The mandatory @syntax{AT END} clause is used to detect and react to the failure of an attempt to retrieve another record from the file due to an end-of-file (i.e. no more records) condition.
@p @item The optional @syntax{NOT AT END} clause, if coded, will check checking for a file status value of 00.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.35 REWRITE                                                 **
@comment *********************************************************************
@page
@newsubsection{7.8.35,REWRITE}
@diagram{REWRITE,PD-REWRITE,PD-REWRITE,None}@p The @statement{REWRITE} replaces a logical record on a disk file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{KEY} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @term{record-name-1} specified on the statement must be defined as an 01-level record subordinate to the File Description (@syntaxrefalt{FD,File/Sort-Description}) of a file that is currently open for @syntaxrefalt{I-O,File OPEN Modes}.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the @term{file-name-1}.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{REWRITE}.
@p @item This statement may not be used with @syntaxref{ORGANIZATION LINE SEQUENTIAL} files.
@p @item Rewriting a record does not cause the contents of the file to be physically updated until the next block of the file is read, a @syntaxref{COMMIT} or @statementref{UNLOCK} is issued or that file is closed.
@p @item If the file has @syntaxref{ORGANIZATION SEQUENTIAL}:
@enumerate A
@p @item The record to be rewritten will be the one retrieved by the most-recently executed @syntaxref{READ} of the file.
@p @item If the @syntax{FD} of the file contains the @syntax{RECORD CONTAINS} or @syntax{RECORD IS VARYING} clause, and that clause allows the record size to vary, the size of @term{record-name-1} cannot be altered.
@end enumerate
@item If the file has @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED}:
@enumerate A
@p @item If the file has @syntax{ACCESS MODE SEQUENTIAL}, the record to be rewritten will be the one retrieved by the most-recently executed @syntax{READ} of the file.  If the file has @syntax{ACCESS MODE RANDOM} or @syntax{ACCESS MODE DYNAMIC}, no @syntax{READ} is required before a record may be rewritten --- the @syntax{RELATIVE KEY} or @syntax{RECORD KEY} definition for the file, respectively, will specify the record to be updated.
@p @item If the @syntax{FD} of the file contains the @syntax{RECORD CONTAINS} or @syntax{RECORD IS VARYING} clause, and that clause allows the record size to vary, the size @i{can} be altered.
@end enumerate
@item The optional @syntax{LOCK} options may be used to manually control access to the re-written record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.36 ROLLBACK                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.36,ROLLBACK}
@diagram{ROLLBACK,PD-ROLLBACK,PD-ROLLBACK,None}@p The @statement{ROLLBACK} has the same effect as if an @statementref{UNLOCK} were executed against every open file in the program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item All locks currently being held for all open files will be released.
@p @item @xref{Record Locking}, to review the various record locking behaviours.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.37 SEARCH                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.37,SEARCH}
@diagram{SEARCH,PD-SEARCH,PD-SEARCH,None}@p The @statement{SEARCH} is used to sequentially search a table, stopping either once a specific value is located within the table or when the table has been completely searched.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{AT} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item The searching process will be controlled through a @define{Search Index} --- a data item with a @syntaxref{USAGE} of @syntax{INDEX}.  The search index is either the @term{index-name-1} identifier specified on the @syntaxidx{VARYING} clause or --- if no @syntax{VARYING} is specified --- the @syntax{USAGE INDEX} data item implicitly created by an @syntaxrefalt{INDEXED BY,OCCURS} clause in the table's definition.
@p @item At the time the @syntax{SEARCH} statement is executed, the current value of the search index data item will define the starting position in the table where the searching process will begin.  Typically, one initializes that index to a value of 1 before starting the @syntax{SEARCH} via @syntax{SET @term{search-index} TO 1}.
@p @item Each of the @term{conditional-expression-n}s on the @syntax{WHEN} clause(s) should involve a data element within the table, subscripted using the search index.
@p @item The searching process is as follows:
@enumerate A
@p @item Each @term{conditional-expression-n} will be evaluated, in turn, until either one evaluates to a value of TRUE or all have evaluated to FALSE.
@p @item The @term{imperative-statement-n} (@pxref{Imperative Statement}) specified on the @syntax{WHEN} clause whose @term{conditional-expression-n} evaluated to TRUE will be executed; after that, the search will be considered complete and control will fall into the first executable statement following the @syntax{SEARCH}.
@p @item If all @term{conditional-expression-n}s evaluated to FALSE:
@itemize @bullet
@p @item The search index will be incremented by 1
@p @item If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the @term{imperative-statement-1} on the optional @syntaxidx{AT END} clause, if any, will be executed.  After that, control will fall into the first executable statement following the @syntax{SEARCH}.
@p @item If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).
@end itemize
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.38 SEARCH ALL                                              **
@comment *********************************************************************
@page
@newsubsection{7.8.38,SEARCH ALL}
@diagram{SEARCH ALL,PD-SEARCH-ALL,PD-SEARCH-ALL,None}@p The @statement{SEARCH ALL} performs a binary, or half-interval, search against a sorted table.  This is generally @i{significantly} faster than performing a sequential @syntax{SEARCH} of a table, especially if the table contains a large number of entries.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{AT} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item To be eligible for searching via @syntax{SEARCH ALL}:
@enumerate A
@p @item The @syntax{OCCURS} clause of @term{table-name-1} must contain the following elements:
@itemize @bullet
@p @item An @syntaxidx{INDEXED BY} entry to define an implicit search index data item with a @syntaxref{USAGE} of @syntax{INDEX}.
@p @item An @syntaxidx{ASCENDING KEY} or @syntaxidx{DESCENDING KEY} clause to specify the field within the table by which all entries in the table are sorted.
@end itemize
@item Just because the table has one or more @syntax{KEY} clauses doesn't mean the data is actually @i{in} that sequence in the table --- the actual sequence of the data @i{must} agree with the KEY clause(s)!  A table-based @syntaxrefalt{SORT,Table SORT} can prove very useful in this regard.
@p @item No two records in the table may have the same @syntax{KEY} field values.  If the table has multiple @syntax{KEY} definitions, then no two records in the table may have the same @i{combination} of @syntax{KEY} field values.
@end enumerate
@item If rule (A) is violated, the compiler will reject the @syntax{SEARCH ALL}.  If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a @syntax{SEARCH ALL} against the table will probably be incorrect.
@p @item The @term{conditional-expression-1} should involve the @syntax{KEY} field(s), using the search index (the table's @syntax{INDEXED BY} index name) as a subscript.
@p @item The function of the single, mandatory, @syntaxidx{WHEN} clause is to compare the key field(s) of the table, as indexed by the search index data item, against whatever literal and/or identifier values you are comparing the key field(s) to in the @term{conditional-expression-1} in order to locate the desired entry in the table.  The search index will be automatically varied in a manner designed to require the minimum number of tests.
@p @item The internal processing of the SEARCH ALL statement begins by setting internal "first" and "last" pointers to the 1st and last entry locations of the table.  Processing then proceeds as follows:
@enumerate A
@p @item The entry half-way between "first" and "last" is identified.  We'll call this the "current" entry, and will set its table entry location into @term{index-name-1}.
@p @item The @term{conditional-expression-1} is evaluated.  This comparison of the key(s) against the target literal/identifier values will have one of three possible outcomes:
@itemize @bullet
@p @item If the key(s) and value(s) match, @term{imperative-statement-2} (@pxref{Imperative Statement}) is executed, after which control falls through into the next statement following the @syntax{SEARCH ALL}.
@p @item If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the "current" to "last" range of the table, so a new "first" pointer value is set (it will be set to the "current" pointer).
@p @item If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the "first" to "current" range of the table, so a new "last" pointer value is set (it will be set to the "current" pointer).
@end itemize
@item If the new "first" and "last" pointers are different than the old "first" and "last" pointers, there's more left to be searched, so return to step (A) and continue.
@p @item If the new "first" and "last" pointers are the same as the old "first" and "last" pointers, the table has been exhausted and the entry being searched for cannot be found; @term{imperative-statement-1} is executed, after which control falls through into the next statement following the @syntax{SEARCH ALL}.  If there is no @syntax{AT END} clause coded, control simply falls into the next statement following the @syntax{SEARCH ALL}.
@end enumerate
@item The net effect of the above algorithm is that only a fraction of the number of elements in the table need ever be tested in order to decide whether or not a particular entry exists.  This is because the half the remaining entries in the table are discarded each time an entry is checked.
@p @item Computer scientists will compare the two techniques implemented by the @syntax{SEARCH} and @statement{SEARCH ALL}s as follows:
@p @item When searching a table with "n" entries, a sequential search will need an average of n/2 tests and a worst case of n tests in order to find an entry and n tests to identify that an entry doesn't exist.
@p @item When searching a table with "n" entries,  a binary search will need a worst-case of log2(n) tests in order to find an entry and log2(n) tests to identify that an entry doesn't exist (n = the number of entries in the table), where "log2" is the base-2 logarithm function.
@end enumerate
@* Here's a more practical view of the difference.  Let's say that a table has 1,000 entries in it.  With a sequential search, on average, you'll have to check 500 of them to find an entry and you'll have to look at all 1,000 of them to find that an entry doesn't exist.
@p With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer --- the number of digits a decimal number would have if expressed in the logarithm's number base).  In this case, we end up with 10 --- THAT is the worst-case number of tests required to find an entry or to identify that it doesn't exist.  That's quite an improvement!
@comment *********************************************************************
@comment ** 7.8.39 SET                                                      **
@comment *********************************************************************
@page
@newsubsection{7.8.39,SET}
@menu
* 7.8.39.1: SET ENVIRONMENT
* 7.8.39.2: SET Program-Pointer
* 7.8.39.3: SET ADDRESS
* 7.8.39.4: SET Index
* 7.8.39.5: SET UP/DOWN
* 7.8.39.6: SET Condition Name
* 7.8.39.7: SET Switch
* 7.8.39.8: SET ATTRIBUTE
* 7.8.39.9: SET LAST EXCEPTION
@end menu
@comment *********************************************************************
@comment ** 7.8.39.1 SET ENVIRONMENT                                        **
@comment *********************************************************************
@newunit{7.8.39.1,SET ENVIRONMENT}
@diagram{SET ENVIRONMENT,PD-SET-1,PD-SET-1,None}@p The @statement{SET ENVIRONMENT} provides a straight-forward means of setting environment values from within a program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The value of @term{literal-1} or @term{identifier-1} specifies the name of the environment variable to set.
@p @item The value of @term{literal-2} or @term{identifier-2} specifies the value to be assigned to the environment variable.
@p @item Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL "SYSTEM") but will not be known to the shell or console window that started the GnuCOBOL program.
@end enumerate
@* This is a much simpler and more readable means of setting environment variables than by using the @statementref{DISPLAY UPON ENVIRONMENT-NAME}.  For example, these two code sequences produce identical results:
@p @example
DISPLAY "VARNAME" UPON ENVIRONMENT-NAME
DISPLAY "VALUE" UPON ENVIRONMENT-VALUE

SET ENVIRONMENT "VARNAME" TO "VALUE"
@end example
@comment *********************************************************************
@comment ** 7.8.39.2 SET Program-Pointer                                    **
@comment *********************************************************************
@page
@newunit{7.8.39.2,SET Program-Pointer}
@diagram{SET Program-Pointer,PD-SET-2,PD-SET-2,None}@p The @statement{SET @term{Program-Pointer}} allows you to retrieve the address of a procedure division code module --- specifically the @syntax{PROGRAM-ID}, @syntax{FUNCTION-ID} or an entry-point established via the @statementref{ENTRY}.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item If you have used other versions of COBOL before (particularly mainframe implementations), you've possibly seen subroutine calls made passing a procedure name as an argument --- that is not possible in GnuCOBOL; instead, you need to know how to use this form of the @statement{SET}.
@p @item The @syntaxref{USAGE} of @term{program-pointer-1} must be @syntax{PROGRAM-POINTER}.
@p @item The @term{literal-1} or @term{identifier-1} value specified must name a primary entry-point name (@syntax{PROGRAM-ID} of a subroutine or @syntax{FUNCTION-ID} of a user-defined function) or an alternate entry-point defined via an @syntax{ENTRY} statement within a subprogram.
@p @item Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for.  For examples of @syntax{PROGRAM-POINTER}s at work, see the discussions of the @subpgmref{CBL_ERROR_PROC} and @subpgmref{CBL_EXIT_PROC}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.3 SET ADDRESS                                            **
@comment *********************************************************************
@page
@newunit{7.8.39.3,SET ADDRESS}
@diagram{SET ADDRESS,PD-SET-3,PD-SET-3,None}@p The @statement{SET ADDRESS} can be used to work with the addresses of data items rather than their contents.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item When the @syntaxidx{ADDRESS OF} clause is used @i{before} the @syntax{TO} you will be using this statement to alter the address of a linkage section or @syntaxref{BASED} data item.  Without that clause you will be assigning an address to one or more data items whose @syntaxref{USAGE} is @syntax{POINTER}.
@p @item When the @syntax{ADDRESS OF} clause is used @i{after} the @syntax{TO}, this statement will be identifying the address of @term{identifier-2} as the address to be assigned to @term{identifier-1} or stored in @term{pointer-name-1}.
@p @item If the @syntax{ADDRESS OF} clause is absent after the @syntax{TO}, the contents of @term{pointer-name-2} will serve as the address to be assigned.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.4 SET Index                                              **
@comment *********************************************************************
@page
@newunit{7.8.39.4,SET Index}
@diagram{SET Index,PD-SET-4,PD-SET-4,None}@p This statement assigns a value to a @syntax{USAGE INDEX} data item.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Either the @syntaxref{USAGE} of @term{index-name-1} should be @syntax{INDEX}, or @term{index-name-1} must be identified in a table @syntax{INDEXED BY} clause.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.5 SET UP/DOWN                                            **
@comment *********************************************************************
@page
@newunit{7.8.39.5,SET UP/DOWN}
@diagram{SET UP/DOWN,PD-SET-5,PD-SET-5,None}@p Use this statement to increment or decrement the value of an index or pointer by a specified amount.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The @syntaxref{USAGE} of @term{identifier-1} must be @syntax{INDEX}, @syntax{POINTER} or @syntax{PROGRAM-POINTER}.
@p @item The typical usage when @term{identifier-1} is a @syntax{USAGE INDEX} data item is to increment it's value @syntax{UP} or @syntax{DOWN} by 1, since an index is usually being used to sequentially walk through the elements of a table.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.6 SET Condition Name                                     **
@comment *********************************************************************
@page
@newunit{7.8.39.6,SET Condition Name}
@diagram{SET Condition Name,PD-SET-6-Info,PD-SET-6-TeX,None}@p The @statement{SET @term{Condition Name}} provides one method of specifying the TRUE / FALSE value of a level-88 condition name.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item By setting the specified @term{condition-name-1}(s) to a TRUE or FALSE value, you will actually be assigning a value to the parent data item(s) to which the condition name data item(s) is(are) subordinate to.
@p @item When specifying @syntax{TRUE}, the value assigned to each parent data item will be the first value specified on the condition name's @syntax{VALUE} clause.
@p @item When specifying @syntax{FALSE}, the value assigned to each parent data item will be the value specified for the @syntax{FALSE} clause of the condition name's definition; if any @term{condition-name-1} occurrence lacks a @syntax{FALSE} clause, the @syntax{SET} statement will be rejected by the compiler.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.7 SET Switch                                             **
@comment *********************************************************************
@page
@newunit{7.8.39.7,SET Switch}
@diagram{SET Switch,PD-SET-7-Info,PD-SET-7-TeX,None}@p This form of the @statement{SET} is used to turn switches on or off.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Switches are defined using the @syntaxref{SPECIAL-NAMES} paragraph.
@p @item Switches may be tested via the @statementref{IF} and a Switch-Status Condition.  @xref{Switch-Status Conditions}, for more information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.8 SET ATTRIBUTE                                          **
@comment *********************************************************************
@page
@newunit{7.8.39.8,SET ATTRIBUTE}
@diagram{SET ATTRIBUTE,PD-SET-8,PD-SET-8,None}@p The @statement{SET ATTRIBUTE} may be used to modify one or more attributes of a screen section data item at run-time.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item When making an attribute change to @term{identifier-1}, the change will not become visible on the screen until the screen section data item containing @term{identifier-1} is next accepted (if @term{identifier-1} is an input field) or is next displayed (if @term{identifier-1} is not an input field).
@p @item The attributes shown in the syntax diagram are the only ones that may be altered by this statement.  @xref{Data Description Clauses}, for information on their usage.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.39.9 SET LAST EXCEPTION                                     **
@comment *********************************************************************
@page
@newunit{7.8.39.9,SET LAST EXCEPTION}
@diagram{SET ATTRIBUTE,PD-SET-9,PD-SET-9,None}@p The @statement{SET LAST EXCEPTION} will set the last program exception status to indicate no exception.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The predefined object reference EXCEPTION-OBJECT is set to null, and the last exception status is set to indicate no exception.
@p @item This action resets the global exception object completely (FUNCTION EXCEPTION-{FILE, LOCATION, STATEMENT, STATUS } ), and will not show anything afterwards), no matter what the last exception was (such as a divide by zero). Use with care.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.40 SORT                                                     **
@comment *********************************************************************
@page
@newsubsection{7.8.40,SORT}
@menu
* 7.8.40.1: File-Based SORT
* 7.8.40.2: Table SORT
@end menu
@comment *********************************************************************
@comment ** 7.8.40.1 File-Based SORT                                        **
@comment *********************************************************************
@newunit{7.8.40.1,File-Based SORT}
@diagram{File-Based SORT,PD-SORT-1-Info,PD-SORT-1-TeX,PD-DUPLICATES}@p This format of the @statement{SORT} is designed to sort large volumes of data according to one or more key fields.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{sort-file-1} named on the @statement{SORT} must be defined using a sort description (@syntaxrefalt{SD,File/Sort-Description}).  This file is referred to in the remainder of this discussion as the "sort work file".
@p @item If specified, @term{file-name-1} and @term{file-name-2} must reference @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{ORGANIZATION SEQUENTIAL} files.  These files must be defined using a file description (@syntaxrefalt{FD,File/Sort-Description}).  The same file(s) may be used for @term{file-name-1} and @term{file-name-2}.
@p @item The @term{identifier-1} @dots{} field(s) must be defined as field(s) within a record of @term{sort-file-1}.
@p @item A sort work file is never opened or closed.
@p @item The sorting process works in three stages --- the Input Stage, the Sort Stage and the Output Stage.
@p @item The following points pertain to the Input Stage:
@enumerate A
@p @item The data to be sorted is loaded into the sort work file either by copying the entire contents of the file(s) named on the @syntax{USING} clause (done automatically by the sort) or by utilizing an input procedure.
@p @item When @syntaxidx{USING} is specified, none of the @term{file-name-1} files may be open at the time the @statement{SORT} is executed.
@p @item When an input procedure is used, the procedure(s) specified on the @syntaxidx{INPUT PROCEDURE} clause will be invoked as if by a procedural @statementrefalt{PERFORM,Procedural PERFORM} with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Records will be loaded into the sort work file --- one at a time --- within the input procedure using the @statementref{RELEASE}.  This, by the way, is how you could sort the contents of relative or indexed files.
@p A @statementref{GO TO} that transfers control out of the input procedure will terminate the @statement{SORT} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an input procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the sort work file are lost.  You may, however, re-execute the @statement{SORT} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A SORT, OR RE-STARTING A PREVIOUSLY-CANCELLED SORT IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An input procedure should be terminated in the same way a procedural @statement{PERFORM} would be.
@p Neither a another file-based @statement{SORT} nor a @statement{MERGE} may be executed within the input procedure unless those statements utilize a different sort or merge work file.
@p @item Once the input procedure terminates, the input phase is complete.
@p @item As data is loaded into the sort work file, it is actually being buffered in dynamically-allocated memory.  Only if the amount of data to be sorted exceeds the amount of available sort memory (128 MB) will actual disk files be allocated and utilized.  There is a @envvarruntimeref{COB_SORT_MEMORY} that you may use to allocate more or less memory to the sorting process.
@end enumerate
@item The following points pertain to the Sort Stage:
@enumerate A
@p @item The sort will take place by arranging the data records in the sequence defined by the @syntax{KEY} specification(s) on the @statement{SORT} according to the @syntax{COLLATING SEQUENCE} specified on the @syntax{SORT} (if any) or --- if none was defined --- the @syntaxrefalt{PROGRAM COLLATING SEQUENCE,OBJECT-COMPUTER}.  Keys may be any supported data type and @syntaxref{USAGE} except for level-78 or level-88 data items.
@p @item For example, let's assume we're sorting a series of financial transactions.  The SORT statement might look like this:
@p @example
SORT Sort-File
    ASCENDING  KEY Transaction-Date
    ASCENDING  KEY Account-Number
    DESCENDING KEY Transaction-Amount
@end example
@* The effect of this statement will be to sort all transactions into ascending order of the date the transaction took place (oldest first, newest last).  Unless the business running this program is going out of business, there are most-likely many transactions for any given date.  Therefore, within each grouping of transactions all with the same date, transactions will be sub-sorted into ascending sequence of the account number the transactions apply to.  Since it's quite possible there might be multiple transactions for an account on any given date, a third level sub-sort will arrange all transactions for the same account on the same date into descending sequence of the actual amount of the transaction (largest first, smallest last).  If two or more transactions of $100.00 were recorded for account #12345 on the 31st of August 2009, those transactions will be retained in the order in which they were loaded into the sort work file.
@p @item  Should disk work files be necessary due to the amount of data being sorted, they will be automatically allocated to disk in a folder defined by the @envvarruntime{TMPDIR}, @envvarruntime{TMP} or @envvarruntimerefs{TEMP} (checked for existence in that sequence).  These disk files will be automatically purged upon @syntax{SORT} termination or program execution termination (normal or otherwise).
@end enumerate
@item The following points pertain to the Output Stage:
@enumerate A
@p @item Once the sort stage is complete, a copy of the sorted data will be written to each @term{file-name-2} if the @syntaxidx{GIVING} clause was specified.  None of the @term{file-name-2} files can be open at the time the sort is executed.
@p @item When an output procedure is used, the procedure(s) specified on the @syntaxidx{OUTPUT PROCEDURE} clause will be invoked as if by a procedural @statementrefalt{PERFORM,Procedural PERFORM} with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Records will be retrieved from the sort work file --- one at a time --- within the output procedure using the @statementref{RETURN}.
@p A @statementref{GO TO} that transfers control out of the output procedure will terminate the @statement{SORT} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an output procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the sort work file are lost.  You may, however, re-execute the @statement{SORT} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A SORT, OR RE-STARTING A PREVIOUSLY-CANCELLED SORT IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An output procedure should be terminated in the same way a procedural @statement{PERFORM} would be.
@p Neither a another file-based @statement{SORT} nor a @statement{MERGE} may be executed within the output procedure unless those statements utilize a different sort or merge work file.
@p @item Once the output procedure terminates, the sort is complete.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.40.2 Table SORT                                            **
@comment *********************************************************************
@page
@newunit{7.8.40.2,Table SORT}
@diagram{Table SORT,PD-SORT-2,PD-SORT-2,PD-DUPLICATES}@p This format of the @statement{SORT} sorts relatively small quantities of data --- namely data contained in a data division table --- according to one or more key fields.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{table-name-1} data item must be a table defined in any data division section @i{except} the report or screen sections.
@p @item The data within @term{table-name-1} will be sorted in-place (i.e. no sort file is required).
@p @item The sort will take place by rearranging the data in @term{table-name-1} into the sequence defined by the @syntax{KEY} specification(s) on the @statement{SORT}, according to the @syntax{COLLATING SEQUENCE} specified on the @syntax{SORT} (if any) or --- if none was defined --- the @syntaxrefalt{PROGRAM COLLATING SEQUENCE,OBJECT-COMPUTER}.  Keys may be any supported data type and @syntaxref{USAGE} except for level-78 or level-88 data items.
@p @item If you are sorting @term{table-name-1} for the purpose of preparing the table for use with a @statementref{SEARCH ALL}, care must be taken that the @syntax{KEY} specifications on the @syntax{SORT} agree with those in the table's definition.
@p @item Although the specification of one or more KEY clauses is optional, currently, a table sort with no @syntax{KEY} specification(s) made on the @statement{SORT} is unsupported by GnuCOBOL and will be rejected by the compiler.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.41 START                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.41,START}
@diagram{START,PD-START,PD-START,None}@p The @statement{START} defines the logical starting point within a relative or indexed file for subsequent sequential read operations.  It positions an internal logical record pointer to a particular record in the file, but does not actually transfer any of that record's data into the record buffer.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS}, @syntax{KEY}, @syntax{THAN} and @syntax{TO} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item To use this statement, @term{file-name-1} must be an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file that must have been defined with an @syntax{ACCESS MODE DYNAMIC} or @syntax{ACCESS MODE SEQUENTIAL} in its @statementref{SELECT}.
@p @item At the time this statement is executed, @term{file-name-1} must be open in either @syntax{INPUT} or @syntaxrefalt{I-O,File OPEN Modes} mode.
@p @item If @term{file-name-1} is a relative file, @term{identifier-1} must be the defined @syntax{RELATIVE KEY} of the file.
@p @item If @term{file-name-1} is an indexed file, @term{identifier-1} must be the defined @syntax{RECORD KEY} of the file or any of the @syntax{ALTERNATE RECORD KEY} fields for the file.
@p @item If no @syntax{FIRST}, @syntax{LAST} or @syntax{KEY} clause is specified, @syntax{KEY IS EQUAL TO xxx} will be assumed, where "xxx" is the defined @syntax{RELATIVE KEY} of (if @term{file-name-1} is a relative file) or the defined @syntax{RECORD KEY} (if @term{file-name-1} is an indexed file).
@p @item After successful execution of a @statement{START}, the internal logical record pointer into the @term{file-name-1} data will be positioned to the record which satisfied the actual or implied @syntax{FIRST}, @syntax{LAST} or @syntax{KEY} clause specification, as follows:
@enumerate A
@p @item If @syntax{FIRST} was specified, the logical record pointer will point to the first record in the file.
@p @item If @syntax{LAST} was specified, the logical record pointer will point to the last record in the file.
@p @item If @syntax{KEY} was specified or implied, the logical record pointer will be specified to the @i{first} record satisfying the relation condition; to identify this record, the file's contents are searched in a first-to-last (in sequence of the key implied by the @syntax{KEY} clause), provided the relation is @syntax{EQUAL TO}, @syntax{GREATER THAN} or @syntax{GREATER THAN OR EQUAL TO} (or any of their syntactical equivalents).
@p @item If @syntax{KEY} was specified or implied, the logical record pointer will be specified to the @i{last} record satisfying the relation condition; to identify this record, the file's contents are searched in a last-to-first (in sequence of the key implied by the @syntax{KEY} clause), provided the relation is @syntax{LESS THAN}, @syntax{LESS THAN OR EQUAL TO} or @syntax{NOT GREATER THAN} (or any of their syntactical equivalents).
@end enumerate
@* The next sequential @statement{READ} will read the record that is pointed to by the logical record pointer.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.42 STOP                                                    **
@comment *********************************************************************
@page
@newsubsection{7.8.42,STOP}
@diagram{STOP,PD-STOP,PD-STOP,None}@p The @statement{STOP} suspends program execution.  Some options will allow program execution to resume while others return control to the operating system.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{STATUS} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntaxidx{RETURNING} and @syntaxidx{GIVING} are interchangeable.
@comment Semantic Specifications:
@p @item The @syntaxidx{RUN} clause halts the program without displaying any special message to that effect.
@p @item The @term{literal-3} clause displays the specified text on the @syntax{SYSOUT}/@syntax{STDOUT} device, waits for the user to press the Enter key and then --- once the key has been pressed --- allows the program to continue execution.
@p @item The optional @syntax{RETURNING} clause provides the opportunity to return a numeric value to the operating system (a "return code").  The manner in which the return code may be interrogated by the operating system varies, but Windows can use @syntax{%ERRORLEVEL%} to query the return code while Unix shells such as sh, bash and ksh can query the return code as @syntax{$?}.  Other Unix shells may have different ways to access return code values.
@p @item The @syntaxidx{STATUS} clause provides another means of returning a return code.  Using the @syntax{STATUS} clause is functionally equivalent to using the @syntax{RETURNING} clause.
@p @item Using the @syntax{STATUS} clause without a @term{literal-2} or @term{identifier-2} will return a return code of 0 if the @syntaxidx{NORMAL} keyword is used or a 1 if @syntaxidx{ERROR} was specified.
@p @item Your program will @i{always} return a return code, even if no @syntax{RETURNING} or @syntax{STATUS} clause is specified.  In the absence of the use of these clauses, the value in the @registerrefalt{RETURN-CODE,Special Registers} at the time the @statement{STOP} is executed will be used as the return code.
@p @item Any programmer-defined exit procedure (established via the @subpgmref{CBL_EXIT_PROC}) will be executed by @syntax{STOP RUN}, but not by @syntax{STOP @term{literal-3}}.
@p @item Valid return code values can be in the range -2147483648 to +2147483647.
@p @item The three code snippets below are all equivalent --- they show different ways in which a GnuCOBOL program may be coded to pass a return code value of 16 back to the operating system and then halt.
@p @example
STOP RUN RETURNING 16

MOVE 16 TO RETURN-CODE
STOP RUN

STOP RUN WITH ERROR STATUS 16
@end example
@end enumerate
@comment *********************************************************************
@comment ** 7.8.43 STRING                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.43,STRING}
@diagram{STRING,PD-STRING,PD-STRING,None}@p The @statement{STRING} is used to concatenate all or a part of one or more strings together, forming a new string.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{ON} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item All literals and identifiers (except for @term{identifier-4}) must be explicitly or implicitly defined with a @syntaxref{USAGE} of @syntax{DISPLAY}.   Any of the identifiers may be group items.
@p @item The @syntaxidx{POINTER} data item --- @term{identifier-4} --- must be a non-edited elementary integer numeric data item with a value greater than zero.
@p @item Each @term{literal-1} / @term{identifier-1} will be referred to as a source item.  The receiving data item is @term{identifier-3}.
@p @item The @statement{STRING}'s processing is based upon a @define{current character pointer}.  The initial value of the current character pointer will be the value of @term{identifier-4} at the time the @syntax{STRING} statement began execution.  If no @syntax{POINTER} clause is coded, a value of 1 (meaning "the 1st character position") will be assumed for the current character pointer's initial value.
@p @item For each source item, the contents of the sending item will be copied --- character-by-character --- into @term{identifier-3} at the character position specified by the current character pointer.  After each character is copied, the current character pointer will be incremented by 1 so that it points to the position within @term{identifier-3} where the @i{next} character should be copied.
@p @item The @syntaxidx{DELIMITED BY} clause specifies how much of each source item will be copied into @term{identifier-3}.  @syntax{DELIMITED BY SIZE} (the default if no @syntax{DELIMITED BY} clause is specified) causes the @i{entire} contents of the source item to be copied into @term{identifier-3}.
@p @item Using @syntax{DELIMITED BY @term{literal-2}} or @syntax{DELIMITED BY @term{identifier-2}} causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.
@p @item @syntax{STRING} processing will cease when one of the following occurs:
@enumerate A
@p @item The initial value of the current character pointer is less than 1 or greater than the number of characters in @term{identifier-3}, or@dots{}
@p @item The value of the current character pointer exceeds the size of @term{identifier-3} at the point the STRING statement wants to copy a character into @term{identifier-3}, or@dots{}
@p @item All sending items have been fully processed
@end enumerate
@item If event (A) occurs, @term{identifier-3} will remain unchanged.
@p @item The occurrence of either event (A) or (B) triggers what is referred to as an @define{overflow condition}.
@p @item The @term{identifier-3}) is neither automatically initialized (to spaces or any other value) at the start of a @syntax{STRING} statement nor will it be space-filled should the total number of sending item characters copied into it be less than its size.  You may explicitly initialize @term{identifier-3} yourself via the @syntaxref{INITIALIZE} or @syntaxref{MOVE} statements before executing the @syntax{STRING} if you wish.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses may be used to detect and react to the occurrence or not, respectively, of an overflow condition.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.44 SUBTRACT                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.44,SUBTRACT}
@menu
* 7.8.44.1: SUBTRACT FROM
* 7.8.44.2: SUBTRACT GIVING
* 7.8.44.3: SUBTRACT CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 7.8.44.1 SUBTRACT FROM                                         **
@comment *********************************************************************
@newunit{7.8.44.1,SUBTRACT FROM}
@diagram{SUBTRACT FROM,PD-SUBTRACT-1-Info,PD-SUBTRACT-1-TeX,None}@p This format of the @statement{SUBTRACT} generates the arithmetic sum of all arguments that appear before the @syntax{FROM} (@term{identifier-1} or @term{literal-1}) and subtracts that sum from each @term{identifier-2}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items.
@p @item @term{literal-1} must be a numeric literal.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.44.2 SUBTRACT GIVING                                       **
@comment *********************************************************************
@page
@newunit{7.8.44.2,SUBTRACT GIVING}
@diagram{SUBTRACT GIVING,PD-SUBTRACT-2-Info,PD-SUBTRACT-2-TeX,None}@p The @statement{SUBTRACT GIVING} generates the arithmetic sum of all arguments that appear before the @syntax{FROM} (@term{identifier-1} or @term{literal-1}), subtracts that sum from the contents of @term{identifier-2} and then replaces the contents of the identifiers listed after the @syntaxidx{GIVING} (@term{identifier-3}) with that result.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items.
@p @item @term{literal-1} must be a numeric literal.
@p @item @term{identifier-3} must be a numeric (edited or unedited) data item.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.44.3 SUBTRACT CORRESPONDING                                **
@comment *********************************************************************
@page
@newunit{7.8.44.3,SUBTRACT CORRESPONDING}
@diagram{SUBTRACT CORRESPONDING,PD-SUBTRACT-3,PD-SUBTRACT-3,None}@p The @statement{SUBTRACT CORRESPONDING} generates code equivalent to individual @syntax{SUBTRACT FROM} statements for corresponding matches of data items found subordinate to the two identifiers.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for information on how corresponding matches will be found between @term{identifier-1} and @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.45 SUPPRESS                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.45,SUPPRESS}
@diagram{SUPPRESS,PD-SUPPRESS,PD-SUPPRESS,None}@p The @statement{SUPPRESS} causes the presentation of a report group to be suppressed.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{PRINTING} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item This statement may only appear within a @syntax{USE BEFORE REPORTING} procedure (in @syntaxref{DECLARATIVES}).
@p @item @syntax{SUPPRESS} only prevents the presentation of the report group within whose @syntax{USE BEFORE REPORTING} procedure the statement occurs.
@p @item This statement must be executed each time presentation of the report group is to be suppressed.
@p @item When a report group's presentation is suppressed, none of the following operations for the report will take place:
@enumerate A
@p @item Actual presentation of the report group in question.
@p @item Processing of any @syntaxref{LINE} clauses within the report group in question.
@p @item Processing of the @syntaxref{NEXT GROUP} clause (if any) within the report group in question.
@p @item Any modification to the @registerrefalt{LINE-COUNTER,Special Registers}.
@p @item Any modification to the @register{PAGE-COUNTER}.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 7.8.46 TERMINATE                                               **
@comment *********************************************************************
@page
@newsubsection{7.8.46,TERMINATE}
@diagram{TERMINATE,PD-TERMINATE,PD-TERMINATE,None}@p The @statement{TERMINATE} causes the processing of the specified report(s) to be completed.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Each @term{report-name-1} must be the name of a report having an @syntaxrefalt{RD,REPORT SECTION} defined for it.
@p @item The specified report name(s) must be currently initiated (via @syntaxref{INITIATE}) and cannot yet have been terminated.
@p @item The @statement{TERMINATE} will present each @syntax{CONTROL FOOTING} (if any), in reverse sequence of the control hierarchy, starting with the most minor up to @syntax{FINAL} (if any).  During the presentation of these groups and the processing of any @syntax{USE BEFORE REPORTING} procedures for those groups, the prior set of control data item values will be available, as though a control break had been detected at the most major control data name.
@p @item During the presentation of the @syntax{CONTROL FOOTING} groups, any necessary @syntax{PAGE FOOTING} and @syntax{PAGE HEADING} groups will be presented as well.
@p @item Finally,the @syntax{REPORT FOOTING} group, if any, will be presented.
@p @item If an @syntax{INITIATE} is followed by a @syntax{TERMINATE} with no intervening @syntaxref{GENERATE} statements (all pertaining to the same report, of course), no report groups will be presented to the output file.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.47 TRANSFORM                                               **
@comment *********************************************************************
@page
@newsubsection{7.8.47,TRANSFORM}
@diagram{TRANSFORM,PD-TRANSFORM,PD-TRANSFORM,None}@p The @statement{TRANSFORM} scans a data item performing a series of mono-alphabetic substitutions, defined by the arguments before and after the @syntax{TO} clause.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Both @term{literal-1} and/or @term{literal-2} must be alphanumeric literals.
@p @item All of @term{identifier-1}, @term{identifier-2} and @term{identifier-3} must either be group items or alphanumeric data items.  Numeric data items with a @syntaxref{USAGE} of @syntax{DISPLAY} are accepted, but will generate warning messages from the compiler.
@p @item The @syntax{TRANSFORM} statement will replace characters within @term{identifier-1} that are found in the string specified @i{before} the @syntax{TO} keyword with the corresponding characters from the string specified @i{after} the @syntax{TO} keyword.
@p @item This statement exists within GnuCOBOL to provide compatibility with COBOL programs written to pre-1985 standards.  The @statement{TRANSFORM} was made obsolete in the 1985 standard of COBOL, having been replaced by the @syntax{CONVERTING} clause of the @statementref{INSPECT}.  New programs should be coded to use @syntax{INSPECT CONVERTING} rather than @syntax{TRANSFORM}.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.48 UNLOCK                                                  **
@comment *********************************************************************
@page
@newsubsection{7.8.48,UNLOCK}
@diagram{UNLOCK,PD-UNLOCK,PD-UNLOCK,None}@p This statement synchronizes any as-yet unwritten file I/O buffers to the specified file (if any) and releases any record locks held for records belonging to @term{file-name-1}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{RECORD} and @syntax{RECORDS} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item If @term{file-name-1} is a Sort/Merge work file, no action will be taken.
@p @item Not all GnuCOBOL implementations support locking.  Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated.  When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored.  There will be no compiler message issued.  Buffer syncing, if needed, will still occur.
@p @item @xref{Record Locking}, for additional information on record locking.
@end enumerate
@comment *********************************************************************
@comment ** 7.8.49 UNSTRING                                                **
@comment *********************************************************************
@page
@newsubsection{7.8.49,UNSTRING}
@diagram{UNSTRING,PD-UNSTRING,PD-UNSTRING,None}@p The @statement{UNSTRING} parses a string, extracting any number of sub strings from it.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{IN} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item @term{identifier-1} through @term{identifier-5} must be explicitly or implicitly defined with a @syntaxref{USAGE} of @syntax{DISPLAY}.   Any of those identifiers may be group items.
@p @item Both @term{literal-1} and @term{literal-2} must be alphanumeric literals.
@p @item Each of @term{identifier-6}, @term{identifier-7} and @term{identifier-8} must be elementary non-edited integer numeric items.
@p @item At the time the @statement{UNSTRING} begins execution, @term{identifier-7} must have a value greater than 0.
@p @item @term{identifier-1} will be referred to as the '@i{source string}' and each @term{identifier-4} will be referred to as a '@i{destination field}' in the following discussions.
@p @item  The @statement{UNSTRING}'s processing is based upon a '@i{current character pointer}', the initial value of which will be the value of @term{identifier-7} at the time the @syntax{UNSTRING} statement began execution.  If no @syntax{POINTER} clause is coded, a value of 1 (meaning "the 1st character position") will be assumed for the current character pointer's initial value.
@p @item The source string will be parsed into sub strings starting from the current character pointer position.  Sub strings are identified by using the various delimiter strings specified on the @syntaxidx{DELIMITED BY} clause as inter-sub string separators.
@p @item Using the @syntaxidx{ALL} option allows a delimiter sequence to be an arbitrarily long sequence of occurrences of the delimiter literal whereas its absence treats each occurrence as a separate delimiter.  When multiple delimiters are specified, they will be looked for in the source string in the sequence in which they are coded.
@p @item Two consecutive delimiter sequences will identify a null sub string.
@p @item Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length.  Both truncation and padding will be controlled by the presence or absence of a @syntaxref{JUSTIFIED} clause on the destination field.
@p @item Each destination field may have an optional @syntaxidx{DELIMITER} clause.  If a @syntax{DELIMITER} clause is specified, @term{identifier-5} will have the delimiter character string used to identify the sub string for the destination field moved into it.  If a destination field was not altered (because an insufficient number of sub strings were identified), @term{identifier-5} for that destination field will also be unchanged.
@p @item Each destination field may have an optional @syntaxidx{COUNT} clause.  If a @syntax{COUNT} clause is specified, @term{identifier-6} will have the size of the sub string (in characters) for the destination field moved into it.  If a destination field was not altered (because an insufficient number of sub strings were identified), @term{identifier-6} for that destination field will also be unchanged.
@p @item If a @syntax{TALLYING} clause is coded, @term{identifier-8} will be incremented by 1 each time a destination field is populated.
@p @item None of @term{identifier-4}, @term{identifier-5}, @term{identifier-6}, @term{identifier-7} or @term{identifier-8} are initialized by the @statement{UNSTRING}.  You need to do that yourself via a @syntaxref{MOVE} or @statementref{INITIALIZE}.
@p @item @syntax{UNSTRING} processing will cease when one of the following occurs:
@enumerate A
@p @item The initial value of the current character pointer is less than 1 or greater than the number of character positions in @term{identifier-1}, or@dots{}
@item All destination fields have been fully processed
@end enumerate
@p @item If event (A) occurs, none of the destination field contents (or the contents of their @syntax{DELIMITER} or @term{COUNT} identifiers) will be changed.
@p @item An '@i{overflow}' condition exists if either event (A) occurs, or if event (B) occurs with at least one character position in @term{identifier-1} not having been processed.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses may be used to detect and react to the occurrence or not, respectively, of an overflow condition.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@* The following sample program illustrates the @statement{UNSTRING} statement.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DEMOUNSTRING.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Full-Name                   PIC X(40).
01  Parsed-Info.
    05 Last-Name                PIC X(15).
    05 First-Name               PIC X(15).
    05 MI                       PIC X(1).
    05 Delim-LN                 PIC X(1).
    05 Delim-FN                 PIC X(1).
    05 Delim-MI                 PIC X(1).
    05 Count-LN                 BINARY-CHAR.
    05 Count-FN                 BINARY-CHAR.
    05 Count-MI                 BINARY-CHAR.
    05 Tallying-Ctr             BINARY-CHAR.
PROCEDURE DIVISION.
P1. PERFORM UNTIL EXIT
      DISPLAY "Enter Full Name (null quits):"
          WITH NO ADVANCING
      ACCEPT Full-Name
      IF Full-Name = SPACES
        EXIT PERFORM
      END-IF
      INITIALIZE Parsed-Info
      UNSTRING Full-Name
        DELIMITED BY ", "
                  OR ","
                  OR ALL SPACES
        INTO Last-Name
                 DELIMITER IN Delim-LN
                 COUNT IN Count-LN
             First-Name
                 DELIMITER IN Delim-FN
                 COUNT IN Count-FN
             MI
                 DELIMITER IN Delim-MI
                 COUNT IN Count-MI
        TALLYING Tallying-Ctr
    DISPLAY "First-Name=" First-Name
            " Delim='"    Delim-FN
            "' Count="    Count-FN
    DISPLAY "MI        =" MI "              "
            " Delim='"    Delim-MI
            "' Count="    Count-MI
    DISPLAY "Last-Name =" Last-Name
            " Delim='"    Delim-LN
            "' Count="    Count-LN
    DISPLAY "Tally=     " Tallying-Ctr
  END-PERFORM
  DISPLAY "Bye!"
  STOP RUN   .
@end example
@* The following is sample output from the program:
@p @example
Enter Full Name (null quits):Cutler, Gary L
First-Name=Gary            Delim=' ' Count=+004
MI        =L               Delim=' ' Count=+001
Last-Name =Cutler          Delim=',' Count=+006
Tally=     +003
Enter Full Name (null quits):Snoddgrass,Throckmorton,P
First-Name=Throckmorton    Delim=',' Count=+012
MI        =P               Delim=' ' Count=+001
Last-Name =Snoddgrass      Delim=',' Count=+010
Tally=     +003
Enter Full Name (null quits):Munster   Herman
First-Name=Herman          Delim=' ' Count=+006
MI        =                Delim=' ' Count=+000
Last-Name =Munster         Delim=' ' Count=+007
Tally=     +002
Enter Full Name (null quits):
Bye!
@end example
@comment *********************************************************************
@comment ** 7.8.50 WRITE                                                   **
@comment *********************************************************************
@page
@newsubsection{7.8.50,WRITE}
@diagram{WRITE,PD-WRITE,PD-WRITE,None}@p The @statement{WRITE} writes a new record to an open file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{ADVANCING}, @syntax{AT}, @syntax{KEY}, @syntax{LINE}, @syntax{LINES} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{END-OF-PAGE} and @syntax{EOP} are interchangeable.
@comment Semantic Specifications:
@p @item The @term{record-name-1} specified on the statement must be defined as an 01-level record subordinate to the File Description (@syntaxrefalt{FD,File/Sort-Description}) of a file that is currently open for @syntaxrefalt{OUTPUT,File OPEN Modes}, @syntax{EXTEND} or @syntax{I-O}.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the appropriate file.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{WRITE}.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the just-written record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviour.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used when writing to relative or indexed files to detect and react to the failure (non-zero file status code) or success (00 file status code), respectively, of the statement.  @xref{File Status Codes}, for additional information.
@p @item When @syntax{WRITE} is used against an @syntaxref{ORGANIZATION LINE SEQUENTIAL} file, with or without the @syntaxref{LINE ADVANCING} option, an end-of-record delimiter character sequence will be written to the file to signify where one record ends and the next record begins.  This delimiter sequence will be either of the following:
@itemize @bullet
@p @item A line-terminator sequence consisting of an ASCII carriage-return/line-feed character sequence (X'0D0A') if you are running a MinGW or native Windows build of GnuCOBOL
@p @item A line-terminator sequence consisting of an ASCII line-feed character (X'0A') if you are running a Cygwin, Linux, Unix or OSX build of GnuCOBOL
@end itemize
@item The following points pertain to the use (or not) of the @syntax{ADVANCING} clause:
@enumerate A
@p @item Using this clause with any organization other than @syntax{ORGANIZATION LINE SEQUENTIAL} will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file (@syntaxref{ORGANIZATION SEQUENTIAL}).
@p @item If no @syntax{ADVANCING} clause is specified on a @syntax{WRITE} to a line-advancing file, @syntax{AFTER ADVANCING 1 LINE} will be assumed; on other than line-advancing files, @syntax{BEFORE ADVANCING 1 LINE} will be assumed.
@p @item When @syntaxidx{BEFORE ADVANCING} is used (or implied), the record is written to the file before the @syntax{ADVANCING} action writes line-terminator characters to the file.
@p @item If @syntaxidx{AFTER ADVANCING} is used (or implied), the @syntax{ADVANCING} action writes line-terminator characters to the file and then the record data is written to the file.
@p @item The @syntax{ADVANCING n LINES} clause will introduce the specified number of line-terminator character sequences into the file either before the written record (@syntax{AFTER ADVANCING}) or after the written record (@syntax{BEFORE ADVANCING}).
@item  If the @syntaxrefalt{LINAGE,File/Sort-Description} clause is @i{absent} from the file's @syntax{FD}:
@enumerate a
@p @item The @syntaxidx{ADVANCING PAGE} clause will introduce an ASCII formfeed character into the file either before the written record (@syntax{AFTER PAGE}) or after the written record (@syntax{BEFORE PAGE}).
@p @item Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with "full page" situations and the like are the complete responsibility of the programmer.
@end enumerate
@item  If the LINAGE clause is @i{present} in the file's @syntax{FD}:
@enumerate a
@p @item The @syntax{ADVANCING PAGE} clause will introduce the appropriate number of line-terminator character sequences into the file either before the written record (@syntax{AFTER ADVANCING}) or after the written record (@syntax{BEFORE ADVANCING}) so as to force the printer to automatically advance to a new sheet of paper when the file prints.  No formfeed characters will be generated when @syntax{LINAGE} is specified --- instead, it is assumed that the printer to which the report will be printed will be loaded with special forms that conform to the specifications defined by the @syntax{LINAGE} clause.
@p @item  Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with "full page" situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the @registerrefalt{LINAGE-COUNTER,Special Registers} and the @syntaxidx{END-OF-PAGE} clause to deal with page formatting issues.
@p @item The @syntax{AT END-OF-PAGE} clause will be triggered, thus executing @term{imperative-statement-1} (@pxref{Imperative Statement}), if the @statement{WRITE} introduces a data line or line-feed character into the file at a line position within the Page Footer area defined by the @syntax{LINAGE} clause.  The @syntax{NOT AT END-OF-PAGE} clause will be triggered (thus executing @term{imperative-statement-2}) if no end-of-page condition occurred during the @syntax{WRITE}.
@end enumerate
@end enumerate
@end enumerate
@iftex
@sp 3
@center ------------------------------------------------------------
@center End of Chapter 7 --- PROCEDURE DIVISION
@end iftex

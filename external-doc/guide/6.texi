@comment *********************************************************************
@comment ** 6. PROCEDURE DIVISION                                           **
@comment *********************************************************************
@newchapter{6,PROCEDURE DIVISION}
@diagram{PROCEDURE DIVISION,PD-Overview-Info,PD-Overview-TeX,None}
@p The PROCEDURE DIVISION of any GnuCOBOL program marks the point where all executable code is written.
@menu
* 6.1:  PROCEDURE DIVISION USING.
* 6.2:  PROCEDURE DIVISION CHAINING.
* 6.3:  PROCEDURE DIVISION RETURNING.
* 6.4:  PROCEDURE DIVISION Sections and Paragraphs.
* 6.5:  DECLARATIVES.
* 6.6:  Table References.
* 6.7:  Qualification of Data Names.
* 6.8:  Reference Modifiers.
* 6.9:  Arithmetic Expressions.
* 6.10: Conditional Expressions.
@detailmenu
*   6.10.1: Condition Names.
*   6.10.2: Class Conditions.
*   6.10.3: Sign Conditions.
*   6.10.4: Switch-Status Conditions.
*   6.10.5: Relation Conditions.
*   6.10.6: Combined Conditions.
*   6.10.7: Negated Conditions.
@end detailmenu
* 6.11: Use of Periods.
* 6.12: Use of VERB/END-VERB Constructs.
* 6.13: Concurrent Access to Files.
@detailmenu
*   6.13.1: File Sharing.
*   6.13.2: Record Locking.
@end detailmenu
* 6.14: Common Clauses on Executable Statements.
@detailmenu
*   6.14.1: AT END + NOT AT END.
*   6.14.2: CORRESPONDING.
*   6.14.3: INVALID KEY + NOT INVALID KEY.
*   6.14.4: ON EXCEPTION + NOT ON EXCEPTION.
*   6.14.5: ON OVERFLOW + NOT ON OVERFLOW.
*   6.14.6: ON SIZE ERROR + NOT ON SIZE ERROR.
*   6.14.7: ROUNDED.
@end detailmenu
* 6.15: Special Registers.
* 6.16: Intrinsic Functions.
@detailmenu
@end detailmenu
* 6.17: GnuCOBOL Statements.
@end menu
@comment *********************************************************************
@comment ** 6.1 PROCEDURE DIVISION USING                                    **
@comment *********************************************************************
@page
@newsection{6.1,PROCEDURE DIVISION USING}
@diagram{PROCEDURE DIVISION Subprogram-Argument,PD-USING,PD-USING,None}@p The @syntax{USING} clause defines the arguments that will be passed to a GnuCOBOL program which is serving as a subprogram.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY} and @syntax{IS} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words have no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntaxidx{USING} clause should only be used on the procedure division header of subprograms (subroutines or user-defined functions).
@p @item The calling program will pass zero or more data items, known as arguments, to this subprogram --- there must be exactly as many @term{identifier-1} data items specified on the USING clause as the maximum number of arguments the subprogram will ever be passed.
@p @item If a subprogram does not expect any arguments, it should not have a @syntax{USING} clause specified on it's procedure division header.
@p @item The order in which arguments are defined on the @syntax{USING} clause must correspond to the order in which those arguments will be passed to the subprogram by the calling program.
@p @item The identifiers specified on the @syntax{USING} clause must be defined in the linkage section of the subprogram.  No storage is actually allocated for those identifiers in the subprogram as the actual storage for them will exist in the calling program.
@p @item A GnuCOBOL subprogram expects that all arguments to it will be one of two things:
@itemize @bullet
@p @item The memory address of the actual data item (allocated in the calling program) that is being passed to the subprogram.
@p @item A numeric, full-word, binary value (i.e. @syntaxrefalt{USAGE BINARY-LONG,USAGE}) which is the actual argument being passed to the subprogram.
@end itemize
@* In the case of the former, the @syntax{USING} clause on the procedure division header should describe the argument via the @syntaxidx{BY REFERENCE} clause --- in the latter case, a @syntaxidx{BY VALUE} specification should be coded.  This allows the code generated by the compiler to properly reference the subprogram arguments at run-time.
@p @item @syntax{BY REFERENCE} is the assumed default for the first @syntax{USING} argument should no @syntax{BY} clause be specified for it.  Subsequent arguments will assume the @syntax{BY} specification of the argument prior to them should they lack a @syntax{BY} clause of their own.
@p @item Changes made by a subprogram to the value of an argument specified on the @syntax{USING} clause will "be visible" to the calling program only if @syntax{BY REFERENCE} was explicitly specified or implicitly assumed for the argument on the subprogram's procedure division header @i{and} the argument was passed to the subprogram @syntax{BY REFERENCE} by the calling program.  @xref{Subprogram Arguments}, for additional information on the mechanics of how arguments are passed to subprograms.
@p @item The optional @syntax{SIZE} clause allows you to specify the number of bytes a @syntax{BY VALUE} argument will occupy, with @syntax{SIZE DEFAULT} specifying 4 bytes (this is the default if no @syntax{SIZE} clause is used), @syntax{SIZE AUTO} specifying the size of the argument in the calling program and @syntax{SIZE @term{integer-1}} specifying a specific byte count.
@p @item The optional @syntax{UNSIGNED} keyword, legal only if @syntax{SIZE AUTO} or @syntax{SIZE @term{integer-1}} are coded, will add the "unsigned" attribute to the argument's specification in the C-language function header code generated for the subprogram.  While not of any benefit when the calling program is a GnuCOBOL program, this can improve compatibility with a C-language calling program.
@p @item The @syntaxidx{OPTIONAL} keyword, legal only on @syntax{BY REFERENCE} arguments, allows calling programs to code @syntaxidx{OMITTED} for that corresponding argument when they call this subprogram.  @xref{CALL}. for additional information on this feature.
@end enumerate
@comment *********************************************************************
@comment ** 6.2 PROCEDURE DIVISION CHAINING                                 **
@comment *********************************************************************
@page
@newsection{6.2,PROCEDURE DIVISION CHAINING}
@diagram{PROCEDURE DIVISION Main-Program-Argument,PD-CHAINING,PD-CHAINING,None}@p The @syntax{CHAINING} term provides one mechanism a programmer may use to retrieve command-line arguments passed to a program at execution time.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item @syntax{PROCEDURE DIVISION CHAINING} may only be coded in a main program (that is, the first program executed when a compiled GnuCOBOL compilation unit is executed).  It cannot be used in any form of subprogram.
@p @item The @syntax{CHAINING} clause defines arguments that will be passed to a main program from the operating system.  The argument identifiers specified on the CHAINING clause will be populated by character strings comprised of the parameters specified to the program on the command line that executed it, as follows:
@enumerate A
@p @item When a GnuCOBOL program is executed from a command-line, the complete command line text will be broken into a series of "tokens", where each token is identified as being a word separated from the others in the command text by at least one space.  For example, if the command line was @code{/usr/local/myprog THIS IS A TEST}, there will be five tokens identified by the operating system --- "/usr/local/myprog", "THIS", "IS", "A" and "TEST".
@p @item Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes.  For example, there are only three tokens generated from the command line @code{C:\Pgms\myprog.exe "THIS IS A" TEST} --- "C:\Pgms\myprog.exe", "THIS IS A" and "TEST".  When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token's value.
@p @item Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the "CHAINING" arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.
@p @item If there are more tokens than there are arguments, the excess tokens will be discarded.
@p @item If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the @syntaxrefalt{INITIALIZE @term{identifier-1},INITIALIZE} statement were executed.
@p @item All identifiers specified on the CHAINING clause should be defined as PIC X, PIC A, group items (which are treated implicitly as PIC X) or as PIC 9 USAGE DISPLAY.  The use of USAGE BINARY (or the like) data items as CHAINING arguments is not recommended as all command-line tokens will be retained in their original character form as they are moved into the argument data items.
@p @item If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in.  Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.
@p @item If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner.  unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with "0" characters from the systems native character set.
@p This behaviour when the argument is defined as @syntax{PIC 9} may be unacceptable, as an argument defined as @syntax{PIC 9(3)} but passed in a value of "1" from the command line will receive a value of "100", not "001".  Consider defining "numeric" command line arguments as @syntax{PIC X} and then using the @intrinsicref{NUMVAL} function to determine the proper numeric value.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.3 PROCEDURE DIVISION RETURNING                                **
@comment *********************************************************************
@page
@newsection{6.3,PROCEDURE DIVISION RETURNING}
@diagram{PROCEDURE DIVISION RETURNING,PD-RETURNING,PD-RETURNING,None}@p The RETURNING clause on the PROCEDURE DIVISION header documents that the subprogram in which the clause appears will be returning a numeric value back to the program that called it.
@comment Semantic Specifications:
@enumerate
@p @item The @syntax{RETURNING} clause is optional within a subroutine, as not all subroutines return a value to their caller.
@p @item The @syntax{RETURNING} clause is mandatory within a user-defined function, as all such must return a numeric result.
@p @item The @term{identifier-1} data item should be defined as a USAGE BINARY-LONG data item.
@p @item Main programs that wish to "pass back" a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the @syntax{RETURN-CODE} special register.
@p @item This is not the only mechanism that a subprogram may use to pass a value back to it's caller.  Other possibilities are:
@enumerate A
@p @item The subprogram may modify any argument that is specified as "BY REFERENCE" on it's PROCEDURE DIVISION header.  Whether the calling program can actually "see" any modifications depends upon how the calling program passed the argument to the subprogram.  @xref{CALL}, for more information.
@p @item A data item with the @syntaxref{GLOBAL} attribute specified in it's description in the calling program is automatically visible to and updatable by a subprogram nested with the calling program.  @xref{Independent vs Contained vs Nested Subprograms}, for more information on subprogram nesting.
@p @item A data item defined with the @syntaxref{EXTERNAL} attribute in a subprogram and the calling program (same name in both programs) is automatically visible to and updatable by both programs, even if those programs are compiled separately from one  another.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.4 PROCEDURE DIVISION Sections and Paragraphs                  **
@comment *********************************************************************
@page
@newsection{6.4,PROCEDURE DIVISION Sections and Paragraphs}@p The procedure division is the only one of the COBOL divisions that allows you to create your own sections and paragraphs.  These are collectively referred to as @define{Procedures}, and the names you create for those sections and paragraphs are called @define{Procedure Names}.@p Procedure names are optional in the procedure division and --- when used --- are named entirely according to the needs and whims of the programmer.
@p Procedure names may be up to thirty one (31) characters long and may consist of letters, numbers, dashes and underscores.  A procedure name may neither begin nor end with a dash (-) or underscore (_) character.  This means that "Main", "0100-Read-Transaction" and "17" are all perfectly valid procedure names.
@p There are three circumstances under which the use of certain GnuCOBOL statements or options will require the specification of procedures.  These situations are:
@enumerate
@p @item When @syntaxref{DECLARATIVES} are specified.
@p @item When the @statementref{ENTRY} is being used.
@p @item When any procedure division statement that references procedures is used.  These statements are:
@itemize @bullet
@p @item @syntax{ALTER @term{procedure-name}}
@p @item @syntax{GO TO @term{procedure-name}}
@p @item @syntax{MERGE @dots{} OUTPUT PROCEDURE @term{procedure-name}}
@p @item @syntax{PERFORM @term{procedure-name}}
@p @item @syntax{SORT @dots{} INPUT PROCEDURE @term{procedure-name}} and/or @syntax{SORT @dots{} INPUT PROCEDURE @term{procedure-name}}
@end itemize
@end enumerate
@comment *********************************************************************
@comment ** 6.5 DECLARATIVES                                                **
@comment *********************************************************************
@page
@newsection{6.5,DECLARATIVES}
@diagram{DECLARATIVES,PD-DECLARATIVES,PD-DECLARATIVES,PD-DECLARATIVES}@p The @syntax{DECLARATIVES} area of the procedure division allows the programmer to define a series of "trap" procedures (referred to as declarative procedures) capable of intercepting certain events that may occur at program execution time.  The syntax diagram above shows the format of a single such procedure.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{FOR}, @syntax{ON}, @syntax{PROCEDURE} and @syntax{STANDARD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item @syntax{EC} and @syntax{EXCEPTION CONDITION} are interchangeable.
@comment Semantic Specifications:
@p @item The declaratives area may contain any number of declarative procedures, but no two declarative procedures should be coded to trap the same event.
@p @item The following points apply to the @syntaxidx{USE BEFORE REPORTING} clause:
@enumerate A
@p @item @term{identifier-2} must be a report group.
@p @item At run-time, the declaratives procedure will be executed prior to the processing of the specified report group's presentation; within the procedure you may take either of the following actions:
@itemize @bullet
@p @item You may adjust the value(s) of any items referenced in @syntaxref{SUM} or @syntaxref{SOURCE} clauses in the report group.
@p @item You may execute the @syntaxref{SUPPRESS} statement to squelch the presentation of the specified report group altogether.  Note that you will be suppressing this one specific instance of that group's presentation and not all of them.
@end itemize
@end enumerate
@item The following points apply to the @syntaxidx{USE FOR DEBUGGING} clause:
@enumerate A
@p @item This clause allows you to define a declarative procedure that will be invoked whenever@dots{}
@itemize @bullet
@p @item @dots{}@term{identifier-1} is referenced on any statement.
@p @item @dots{}@term{procedure-name-1} is executed.
@p @item @dots{}any procedure is executed (@syntax{ALL PROCEDURES}).
@end itemize
@item A @syntax{USE FOR DEBUGGING} declarative procedure will be ignored at @i{compilation} time unless @syntax{WITH DEBUGGING MODE} is specified in the @syntaxref{SOURCE-COMPUTER} paragraph.  Neither the compiler's @switchidx{-fdebugging-line} nor @switchidx{-debug} will activate this feature.
@p @item Any @syntax{USE FOR DEBUGGING} declarative procedures will be ignored at @i{execution} time unless the @envvarruntimeref{COB_SET_DEBUG} has been set to a value of "Y", "y" or "1".
@p @item The typical use of a @syntax{USE FOR DEBUGGING} declarative procedure is to display the @register{DEBUG-ITEM}, which will be implicitly and automatically created in your program for you if @syntax{WITH DEBUGGING MODE} is active.
@p The structure of DEBUG-ITEM will be as follows:
@p @example
01  DEBUG-ITEM.
    05 DEBUG-LINE      PIC X(6).
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-NAME      PIC X(31).
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-1     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-2     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-SUB-3     PIC S9(4) SIGN LEADING SEPARATE.
    05 FILLER          PIC X(1) VALUE SPACE.
    05 DEBUG-CONTENTS  PIC X(31).
@end example
@* where@dots{}
@table @asis
@p @item @syntax{DEBUG-LINE}
@dots{} is the program line number of the statement that triggered the declaratives procedure.
@p @item @syntax{DEBUG-NAME}
@dots{} is the procedure name or identifier name that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-1}
@dots{} is the first subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-2}
@dots{} is the second subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-SUB-3}
@dots{} is the third subscript value (if any) for the reference of the identifier that triggered the declaratives procedure.
@p @item @syntax{DEBUG-CONTENTS}
@dots{} is a (brief) statement of the manner in which the procedure that triggered the declaratives procedure was executed or the first 31 characters of the value of the identifier whose reference triggered the declaratives procedure (the value after the statement was executed).
@end table
@end enumerate
@item The @syntaxidx{USE AFTER STANDARD ERROR PROCEDURE} clause defines a declarative procedure invoked any time a failure is encountered with the specified I/O type (or against the specified file(s)).
@p @item The @syntaxref{GLOBAL} option, if used, allows a declarative procedure to be used across the program containing the @statement{USE} and any subprograms nested within that program.
@p @item Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.
@end enumerate
@comment *********************************************************************
@comment ** 6.6 Table References                                            **
@comment *********************************************************************
@page
@newsection{6.6,Table References}COBOL uses parenthesis to specify the subscripts used to reference table entries (tables in COBOL are what other programming languages refer to as arrays).
@p For example, observe the following data structure which defines a 4 column by 3 row grid of characters:
@p @example
01  GRID.
     05 GRID-ROW OCCURS 3 TIMES.
        10 GRID-COLUMN OCCURS 4 TIMES.
            15 GRID-CHARACTER       PIC X(1).
@end example
@* If the structure contains the following grid of characters:
@p @example
A B C D
E F G H
I J K L
@end example
@* Then @syntax{GRID-CHARACTER (2, 3)} references the "G" and @syntax{GRID-CHARACTER (3, 2)} references the "J".
@p Subscripts may be specified as numeric (integer) literals, numeric (integer) data items, data items created with any of the picture-less integer @syntaxref{USAGE} specifications, @syntax{USAGE INDEX} data items or arithmetic expressions resulting in a non-zero integer value.
@p In the above examples, a comma is used as a separator character between the two subscript values; semicolons (@syntax{;}) are also valid subscript separator characters, as are spaces!  The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other.  The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code.  It isn't too difficult to read and understand @syntax{GRID-CHARACTER(2 3)}, but it's another story entirely when trying to comprehend @syntax{GRID-CHARACTER(I + 1 J / 3)} (instead of @syntax{GRID-CHARACTER(I + 1, J / 3)}).  The compiler accepts it, but too much of this would make @i{my} head hurt.
@comment *********************************************************************
@comment ** 6.7 Qualification of Data Names                                 **
@comment *********************************************************************
@page
@newsection{6.7,Qualification of Data Names}COBOL allows data names to be duplicated within a program, provided references to those data names may be made in such a manner as to make those references unique through a process known as qualification.
@p To see qualification at work, observe the following segments of two data records defined in a COBOL program:
@verbatim
01  EMPLOYEE.                     01  CUSTOMER.
    05 MAILING-ADDRESS.               05 MAILING-ADDRESS.
       10 STREET        PIC X(35).       10 STREET        PIC X(35).
       10 CITY          PIC X(15).       10 CITY          PIC X(15).
       10 STATE         PIC X(2).        10 STATE         PIC X(2).
       10 ZIP-CODE.                      10 ZIP-CODE.
          15 ZIP-CODE-5 PIC 9(5).           15 ZIP-CODE-5 PIC 9(5).
          15 FILLER     PIC X(4).           15 FILLER     PIC X(4).
@end verbatim
@* Now, let's deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-ADDRESS to "Philadelphia".  Clearly, @syntax{MOVE 'Philadelphia' TO CITY} cannot work because the compiler will be unable to determine which of the two CITY fields you are referring to.
@p In an attempt to correct the problem, we could qualify the reference to CITY as @syntax{MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS}.
@p Unfortunately that too is insufficient because it still insufficiently specifies which CITY is being referenced.  To truly identify which specific CITY you want, you'd have to code @syntax{MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS OF EMPLOYEE}.
@p Now there can be no confusion as to which CITY is being changed.  Fortunately, you don't need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted.  This allows @syntax{MOVE 'Philadelphia' TO CITY OF EMPLOYEE} to do the job nicely.
@p If you need to qualify a reference to a table, do so by coding something like @syntax{@term{identifier-1} OF @term{identifier-2} ( subscript(s) )}.
@p The reserved word @syntax{IN} may be used in lieu of @syntax{OF}.
@comment *********************************************************************
@comment ** 6.8 Reference Modifiers                                         **
@comment *********************************************************************
@page
@newsection{6.8,Reference Modifiers}
@diagram{Reference Modifier (Format 1),PD-Ref-Mod-1,PD-Ref-Mod-1,None}
@diagram{Reference Modifier (Format 2),PD-Ref-Mod-2,PD-Ref-Mod-2,None}@p The COBOL '85 standard introduced the concept of a reference modifier to facilitate references to only a portion of a data item; GnuCOBOL fully supports reference modification.
@p The @term{start} value indicates the starting character position being referenced (character position values start with 1, not 0 as is the case in some programming languages) and @term{length} specifies how many characters are wanted.
@p If no @term{length} is specified, a value equivalent to the remaining character positions from @term{start} to the end of @term{identifier-1} or to the end of the value returned by the function will be assumed.
@p Both @term{start} and @term{length} may be specified as integer numeric literals, integer numeric data items or arithmetic expressions with an integer value.
@p Here are a few examples:
@table @asis
@p @item @syntax{CUSTOMER-LAST-NAME (1:3)}
@p References the first three characters of CUSTOMER-LAST-NAME.
@p @item @syntax{CUSTOMER-LAST-NAME (4:)}
@p References all character positions of CUSTOMER-LAST-NAME from the fourth onward.
@p @item @syntax{FUNCTION CURRENT-DATE (5:2)}
@p References the current month as a 2-digit number in character form.  @xref{CURRENT-DATE}, for more information.
@p @item @syntax{Hex-Digits (Nibble + 1:1)}
@p Assuming that "Nibble" is a numeric data item with a value in the range 0-15, and Hex-Digits is a @syntax{PIC X(16)} item with a value of "0123456789ABCDEF", this converts that numeric value to a hexadecimal digit.
@p @item @syntax{Table-Entry (6) (7:5)}
@p References characters 7 through 11 (5 characters in total) in the 6th occurrence of Table-Entry.
@end table
@* Reference modification may be used anywhere an identifier is legal, including serving as the receiving field of statements like @syntaxref{MOVE}, @syntaxref{STRING} and @syntaxref{ACCEPT}, to name a few.
@comment *********************************************************************
@comment ** 6.9 Arithmetic Expressions                                      **
@comment *********************************************************************
@page
@newsection{6.9,Arithmetic Expressions}
@diagram{Arithmetic-Expression,PD-Arith-Expr,PD-Arith-Expr,None}
@diagram{Unary-Expression,PD-Unary-Expr,PD-Unary-Expr,None}@p Arithmetic expressions are formed using four categories of operations --- exponentiation, multiplication & division, addition & subtraction, and sign specification.
@p In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.
@p As is the case in almost any other programming language, the programmer is always free to use pairs of parenthesis to enclose sub-expressions of complex expressions that are to be evaluated before other sub-expressions rather than let operator precedence dictate the sequence of evaluation.
@p In highest to lowest order of precedence, here is a discussion of each category of operation:
@table @asis
@p @item Level 1 (Highest) --- Unary Sign Specification (@syntax{+} and @syntax{-} with a single argument)
@cindex - (Unary Sign Reversal)
@cindex + (Unary Sign Retention)
@p The unary "minus" (-) operator returns the arithmetic negation of its single argument, effectively returning as its value the product of its argument and -1.
@p The unary "plus" (+) operator returns the value of its single argument, effectively returning as its value the product of its argument and +1.
@item Level 2 --- Exponentiation (@syntax{**} or @syntax{^})
@cindex ** (Exponentiation)
@cindex ^ (Exponentiation)
@p The value of the left argument is raised to the power indicated by the right argument.  Non-integer powers are allowed.  The @syntax{^} and @syntax{**} operators are both supported to provide compatibility with programs written for other COBOL implementations.
@item Level 3 --- Multiplication (@syntax{*}) and division (@syntax{/})
@cindex * (Multiplication)
@cindex / (Division)
@p The @syntax{*} operator computes the product of the left and right arguments while the @syntax{/} operator computes the value of the left argument divided by the value of the right argument.  If the right argument has a value of zero, expression evaluation will be prematurely terminated before a value is generated.  This may cause program failure at run-time.
@p A sequence of multiple 3rd-level operations (@syntax{A * B / C}, for example) will evaluate in strict left-to-right sequence if no parenthesis are used to control the order of evaluation.
@item Level 4 --- Addition (@syntax{+}) or subtraction (@syntax{+})
@cindex + (Addition)
@cindex - (Subtraction)
@p The @syntax{+} operator calculates the sum of the left and right arguments while the @syntax{-} operator computes the value of the right argument subtracted from that of the left argument.
@p A sequence of multiple 4th-level operations (@syntax{A - B + C}, for example) will evaluate in strict left-to-right sequence if no parenthesis are used to control the order of evaluation.
@end table
@* The syntactical rules of COBOL, allowing a dash (-) character in data item names, can lead to some ambiguity.
@p @example
01  C        PIC 9 VALUE 5.
01  D        PIC 9 VALUE 2.
01  C-D      PIC 9 VALUE 7.
01  I        PIC 9 VALUE 0.
@dots{}
COMPUTE I=C-D+1
@end example
@* The @syntaxref{COMPUTE} statement will evaluate the arithmetic expression @syntax{C-D+1} and then save that result in @syntax{I}.
@p What value will be stored in @syntax{I}?  The number 4, which is the result of subtracting the value of @syntax{D} (2) from the value of @syntax{C} (5) and then adding 1?  Or, will it be the number 8, which is the value of adding 1 to the value of data item @syntax{C-D} (7)?
@p The right answer is 8 --- the value of data item @syntax{C-D} plus 1!  Hopefully, that was the intended result.
@p The GnuCOBOL compiler actually went through the following decision-making logic when generating code for the @syntax{COMPUTE} Statement:
@enumerate
@p @item Is there a data item named @syntax{C-D} defined?  If so, use its value for the character sequence @syntax{C-D}.
@p @item If there is no @syntax{C-D} data item, then are there @syntax{C} and @syntax{D} data items?  If not, the @syntax{COMPUTE} statement is in error.  If there are, however, then code will be generated to subtract the value of @syntax{D} from @syntax{C} and add 1 to the result.
@end enumerate
@* Had there been at least one space to the left and/or the right of the @syntax{-}, there would have been no ambiguity --- the compiler would have been forced to use the individual @syntax{C} and @syntax{D} data items.
@p To avoid any possible ambiguity, as well as to improve program readability, it's considered good COBOL programming practice to always code at least one space to both the left and right of every operator in arithmetic expressions as well as the @syntax{=} sign on a COMPUTE.
@p Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).
@p @multitable @columnfractions .3 .1 .6
@headitem Expression @tab Result @tab Notes
@p @item 3 * 4 + 1
@tab 13
@tab * has precedence over +
@p @item 4 * 2 ^ 3  - 10
@tab 22
@tab 2^3 is 8 (^ has precedence over *), times 4 is 32, minus 10 is 22.
@p @item (4 * 2) ^ 3  - 10
@tab 502
@tab Parenthesis provide for a recursive application of the arithmetic expression rules, effectively allowing you to alter the precedence of operations.  4 times 2 is 8 (the use of parenthesis "trumps" the exponentiation operator, so the multiplication happens first); 8 ^ 3 is 512, minus 10 is 502.
@p @item 5 / 2.5 + 7 * 2 - 1.15
@tab 15.35
@tab Integer and non-integer operands may be freely intermixed
@end multitable
@* Of course, arithmetic expression operands may be numeric data items (any USAGE except POINTER or PROGRAM POINTER) as well as numeric literals.
@comment *********************************************************************
@comment ** 6.10 Conditional Expressions                                    **
@comment *********************************************************************
@page
@newsection{6.10,Conditional Expressions}Conditional expressions are expressions which identify the circumstances under which a program may take an action or cease taking an action.  As such, conditional expressions produce a value of TRUE or FALSE.
@p There are seven types of conditional expressions, as discussed in the following sections.
@menu
* 6.10.1: Condition Names.
* 6.10.2: Class Conditions.
* 6.10.3: Sign Conditions.
* 6.10.4: Switch-Status Conditions.
* 6.10.5: Relation Conditions.
* 6.10.6: Combined Conditions.
* 6.10.7: Negated Conditions.
@end menu
@comment *********************************************************************
@comment ** 6.10.1 Condition Names                                          **
@comment *********************************************************************
@newsubsection{6.10.1,Condition Names}These are the simplest of all conditions.  Observe the following code:
@p @example
05  SHIRT-SIZE               PIC 99V9.
    88 TINY                  VALUE 0 THRU 12.5
    88 XS                    VALUE 13 THRU 13.5.
    88 S                     VALUE 14, 14.5.
    88 M                     VALUE 15, 15.5.
    88 L                     VALUE 16, 16.5.
    88 XL                    VALUE 17, 17.5.
    88 XXL                   VALUE 18, 18.5.
    88 XXXL                  VALUE 19, 19.5.
    88 VERY-LARGE            VALUE 20 THRU 99.9.
@end example
@* The condition names @syntax{TINY}, @syntax{XS}, @syntax{S}, @syntax{M}, @syntax{L}, @syntax{XL}, @syntax{XXL}, @syntax{XXXL} and @syntax{VERY-LARGE} will have TRUE or FALSE values based upon the values within their parent data item (SHIRT-SIZE).
@p A program wanting to test whether or not the current @syntax{SHIRT-SIZE} value can be classified as @syntax{XL} could have that decision coded as a combined condition (the most complex type of conditional expression), as either:
@p @example
IF SHIRT-SIZE = 17 OR SHIRT-SIZE = 17.5

- or -

IF SHIRT-SIZE = 17 OR 17.5
@end example
@* Or it could simply utilize the condition name XL as follows:
@p @example
IF XL
@end example
@comment *********************************************************************
@comment ** 6.10.2 Class Conditions                                         **
@comment *********************************************************************
@page
@newsubsection{6.10.2,Class Conditions}
@diagram{Class-Condition,PD-Class-Cond,PD-Class-Cond,None}@p Class conditions evaluate the type of data that is currently stored in a data item.
@enumerate
@p @item The @syntaxidx{NUMERIC} class test considers only the characters "0", "1", @dots{} , "9" to be numeric; only a data item containing nothing but digits will pass a @syntax{NUMERIC} class test.  Spaces, decimal points, commas, currency signs, plus signs, minus signs and any other characters except the digit characters will all fail @syntax{NUMERIC} class tests.
@p @item The @syntaxidx{ALPHABETIC} class test considers only upper-case letters, lower-case letters and spaces to be alphabetic in nature.
@p @item The @syntaxidx{ALPHABETIC-LOWER} and @syntaxidx{ALPHABETIC-UPPER} class conditions consider only spaces and the respective type of letters to be acceptable in order to pass such a class test.
@p @item The @syntax{NOT} option reverses the TRUE/FALSE value of the condition.
@p @item Note that what constitutes a "letter" (or upper/lower case too, for that manner) may be influenced through the use of @syntax{CHARACTER CLASSIFICATION} specifications in the @syntaxref{OBJECT-COMPUTER} paragraph.
@p @item Only data items whose @syntaxref{USAGE} is either explicitly or implicitly defined as @syntax{DISPLAY} may be used in @syntax{NUMERIC} or any of the @syntax{ALPHABETIC} class conditions.
@p @item Some COBOL implementations disallow the use of group items or @syntax{PIC A} items with @syntax{NUMERIC} class conditions and the use of @syntax{PIC 9} items with @syntax{ALPHABETIC} class conditions.  GnuCOBOL has no such restrictions.
@p @item The @syntaxidx{OMITTED} class condition is used when it is necessary for a subprogram to determine whether or not a particular argument was passed to it.  In such class conditions, @term{identifier-1} must be a linkage section item defined on the @syntax{USING} clause of the subprograms @syntax{PROCEDURE DIVISION} header.  @xref{PROCEDURE DIVISION USING}, for additional information.
@end enumerate
@* The @term{class-name-1} option allows you to test for a user-defined class.  Here's an example.  First, assume the following @syntaxref{SPECIAL-NAMES} definition of the user-defined class "Hexadecimal":
@p @example
SPECIAL-NAMES.
    CLASS Hexadecimal IS '0' THRU '9', 'A' THRU 'F', 'a' THRU 'f'.
@end example
@* Now observe the following code, which will execute the @syntax{150-Process-Hex-Value} procedure if @syntax{Entered-Value} contains nothing but valid hexadecimal digits:
@p @example
    IF Entered-Value IS Hexadecimal
        PERFORM 150-Process-Hex-Value
    END-IF
@end example
@comment *********************************************************************
@comment ** 6.10.3 Sign Conditions                                          **
@comment *********************************************************************
@page
@newsubsection{6.10.3,Sign Conditions}
@diagram{Sign-Condition,PD-Sign-Cond,PD-Sign-Cond,None}@p Sign conditions evaluate the numeric state of a data item defined with a @syntaxref{PICTURE} and/or @syntaxref{USAGE} that supports numeric values.
@enumerate
@p @item A @syntaxidx{POSITIVE} or @syntaxidx{NEGATIVE} class condition will be TRUE only if the value of @term{identifier-1} is strictly greater than or less than zero, respectively.
@p @item A @syntaxidx{ZERO} class condition can be passed only if the value of @term{identifier-1} is exactly zero.
@p @item The @syntax{NOT} option reverses the TRUE/FALSE value of the condition.
@end enumerate
@comment *********************************************************************
@comment ** 6.10.4 Switch-Status Conditions                                 **
@comment *********************************************************************
@page
@newsubsection{6.10.4,Switch-Status Conditions}In the @syntaxref{SPECIAL-NAMES} paragraph, an external switch name can be associated with one or more condition names.  These condition names may then be used to test the ON/OFF status of the external switch.
@p Here are the relevant sections of code in a program named "testprog", which is designed to simply announce if SWITCH-1 is on:
@p @example
@dots{}
ENVIRONMENT DIVISION.
SPECIAL-NAMES.
    SWITCH-1 ON STATUS IS Switch-1-Is-ON.
@dots{}
PROCEDURE DIVISION.
@dots{}
    IF Switch-1-Is-ON
        DISPLAY "Switch 1 Is On"
    END-IF
@dots{}
@end example
@* the following are two different command window sessions --- the left on a Unix/Cygwin/OSX system and the right on a windows system --- that will set the switch on and then execute the "testprog" program.  Notice how the message indicating that the program detected the switch was set is displayed in both examples:
@p @example
$ COB_SWITCH_1=ON           C:>SET COB_SWITCH_1=ON
$ export COB_SWITCH_1       C:>testprog
$ ./testprog                Switch 1 Is On
Switch 1 Is On              C:>
$
@end example
@comment *********************************************************************
@comment ** 6.10.5 Relation Conditions                                      **
@comment *********************************************************************
@page
@newsubsection{6.10.5,Relation Conditions}
@diagram{Relation-Condition,PD-Rel-Cond,PD-Rel-Cond,None}
@diagram{RelOp,PD-RelOp,PD-RelOp,None}@p These conditions evaluate how two different values "relate" to each other.
@enumerate
@p @item When comparing one numeric value to another, the @syntaxref{USAGE} and number of significant digits in either value are irrelevant as the comparison is performed using the actual algebraic values.
@p @item When comparing strings, the comparison is made based upon the program's collating sequence.  When the two string arguments are of unequal length, the shorter is assumed to be padded (on the right) with a sufficient number of spaces as to make the two strings of equal length.  String comparisons take place on a corresponding character-by-character basis, left to right, until the TRUE/FALSE value for the relation test can be established.  Characters are compared according to their relative position in the program's @syntax{COLLATING SEQUENCE} (as defined in @syntaxref{SPECIAL-NAMES}), @i{not} according to the bit-pattern values the characters have in storage.
@p @item By default, the program's @syntax{COLLATING SEQUENCE} will, however, be based entirely on the bit-pattern values of the various characters.
@p @item There is no functional difference between using the wordy version (@syntax{IS EQUAL TO}, @syntax{IS LESS THAN}, @dots{}) versus the symbolic version (@syntax{=}, @syntax{<}, @dots{}) of the actual relation operators.
@end enumerate
@comment *********************************************************************
@comment ** 6.10.6 Combined Conditions                                      **
@comment *********************************************************************
@page
@newsubsection{6.10.6,Combined Conditions}
@diagram{Combined Condition,PD-Comb-Cond,PD-Comb-Cond,None}@p A combined condition is one that computes a TRUE/FALSE value from the TRUE/FALSE values of two other conditions (which could themselves be combined conditions).
@enumerate
@p @item If either condition has a value of TRUE, the result of @syntaxidx{OR}ing the two together will result in a value of TRUE.  @syntax{OR}ing two FALSE conditions will result in a value of FALSE.
@p @item In order for @syntaxidx{AND} to yield a value of TRUE, both conditions must have a value of TRUE.  In all other circumstances, @syntax{AND} produces a FALSE value.
@p @item When chaining multiple, similar conditions together with the same operator (OR/AND), and left or right arguments have common subjects, it is possible to abbreviate the program code.  For example:
@p @example
IF ACCOUNT-STATUS = 1 OR ACCOUNT-STATUS = 2 OR ACCOUNT-STATUS = 7
@end example
@* Could be abbreviated as:
@p @example
IF ACCOUNT-STATUS = 1 OR 2 OR 7
@end example
@item Just as multiplication takes precedence over addition in arithmetic expressions, so does @syntax{AND} take precedence over @syntax{OR} in combined conditions.  Use parenthesis to change this precedence, if necessary.  For example:
@table @asis
@p @item @syntax{FALSE AND FALSE OR TRUE AND TRUE}
@p Evaluates to TRUE
@p @item @syntax{(FALSE AND FALSE) OR (TRUE AND TRUE)}
@p Evaluates to TRUE (since AND has precedence over OR) - this is identical to the previous example
@p @item @syntax{(FALSE AND (FALSE OR TRUE)) AND TRUE}
@p Evaluates to FALSE
@end table
@end enumerate
@comment *********************************************************************
@comment ** 6.10.7 Negated Conditions                                       **
@comment *********************************************************************
@page
@newsubsection{6.10.7,Negated Conditions}
@diagram{Negated Condition,PD-Neg-Cond,PD-Neg-Cond,None}@p A condition may be negated by prefixing it with the @syntaxidx{NOT} operator.
@enumerate
@p @item The @syntax{NOT} operator has the highest precedence of all logical operators, just as a unary minus sign (which "negates" a numeric value) is the highest precedence arithmetic operator.
@p @item Parenthesis must be used to explicitly signify the sequence in which conditions are evaluated and processed if the default precedence isn't desired.  For example:
@table @asis
@p @item @syntax{NOT TRUE AND FALSE AND NOT FALSE}
@p Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE
@p @item @syntax{NOT (TRUE AND FALSE AND NOT FALSE)}
@p Evaluates to NOT (FALSE) which evaluates to TRUE
@p @item @syntax{NOT TRUE AND (FALSE AND NOT FALSE)}
@p Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE
@end table
@end enumerate
@comment *********************************************************************
@comment ** 6.11 Use of Periods                                             **
@comment *********************************************************************
@page
@newsection{6.11,Use of Periods}All COBOL implementations distinguish between sentences and statements in the procedure division.  A @define{Statement} is a single executable COBOL instruction.  For example, these are all statements:
@p @example
MOVE SPACES TO Employee-Address
ADD 1 TO Record-Counter
DISPLAY "Record-Counter=" Record-Counter
@end example
@* Some COBOL statements have a "scope of applicability" associated with them where one or more other statements can be considered to be part of or related to the statement in question.  An example of such a situation might be the following, where the interest on a loan is being calculated and displayed --- 4% interest if the loan balance is under $10000 and 4.5% otherwise (WARNING -- the following code has an error!):
@p @example
IF Loan-Balance < 10000
    MULTIPLY Loan-Balance BY 0.04 GIVING Interest
ELSE
    MULTIPLY Loan-Balance BY 0.045 GIVING Interest
DISPLAY "Interest Amount = " Interest
@end example
@* In this example, the IF statement actually has a scope that can include two sets of associated statements -- one set to be executed when the @syntaxref{IF} condition is TRUE and another if it is FALSE.
@p Unfortunately, there's a problem with the above.  A human being looking at that code would probably infer that the @syntaxref{DISPLAY} statement, because of its lack of indentation, is to be executed regardless of the TRUE/FALSE value of the @syntax{IF} condition.  Unfortunately, the GnuCOBOL compiler (or any other COBOL compiler for that matter) won't see it that way because it really couldn't care less what sort of indentation, if any, is used.  In fact, any COBOL compiler would be just as happy to see the code written like this:
@p @example
IF Loan-Balance < 10000 MULTIPLY Loan-balance
BY 0.04 GIVING Interest ELSE MULTIPLY
Loan-Balance BY 0.045 GIVING Interest DISPLAY
"Interest Amount = " Interest
@end example
@* So how then do we inform the compiler that the @syntax{DISPLAY} statement is outside the scope of the @syntax{IF}?
@p That's where sentences come in.
@p A COBOL @define{Sentence} is defined as any arbitrarily long sequence of statements, followed by a period (.) character.  The period character is what terminates the scope of a set of statements.  Therefore, our example should have been coded like this:
@p @example
IF Loan-Balance < 10000
    MULTIPLY Loan-Balance BY 0.04 GIVING Interest
ELSE
    MULTIPLY Loan-Balance BY 0.045 GIVING Interest.
DISPLAY "Interest Amount = " Interest
@end example
@* See the period at the end of the second @syntaxref{MULTIPLY}?  That is what terminates the scope of the @syntax{IF}, thus making the @syntax{DISPLAY} statement's execution completely independent of the TRUE/FALSE status of the @syntax{IF}.
@comment *********************************************************************
@comment ** 6.12 Use of VERB/END-VERB Constructs                            **
@comment *********************************************************************
@page
@newsection{6.12,Use of VERB/END-VERB Constructs}Prior to the 1985 COBOL standard, using a period character was the only way to signal the end of a statement's scope.  @p Unfortunately, this caused some problems.  Take a look at this code:
@p @example
IF A = 1
    IF B = 1
        DISPLAY "A & B = 1"
ELSE *> This ELSE has a problem!
    IF B = 1
        DISPLAY "A NOT = 1 BUT B = 1"
    ELSE
        DISPLAY "NEITHER A NOR B = 1".
@end example
@* The problem with this code is that indentation --- so critical to improving the human-readability of a program --- can provide an erroneous view of the logical flow.  An @syntax{ELSE} is always associated with the most-recently encountered @syntax{IF}; this means the emphasized @syntax{ELSE} will be associated with the @syntax{IF B = 1} statement, not the @syntax{IF A = 1} statement as the indentation would appear to imply.
@p This sort of problem led to a band-aid solution --- the @syntaxidx{NEXT SENTENCE} clause --- being added to the COBOL language.
@p @example
IF A = 1
    IF B = 1
        DISPLAY "A & B = 1"
    ELSE
        NEXT SENTENCE
ELSE
    IF B = 1
        DISPLAY "A NOT = 1 BUT B = 1"
    ELSE
        DISPLAY "NEITHER A NOR B = 1".
@end example
@* The @syntax{NEXT SENTENCE} clause informs the compiler that if the @syntax{B = 1} condition is false, control should fall into the first statement that follows the next period.
@p With the 1985 standard for COBOL, a much more elegant solution was introduced.  Any COBOL @define{Verb} (the first reserved word of a statement) that needed such a thing was allowed to use an @syntax{END-verb} construct to end it's scope without disrupting the scope of any other statement it might have been in.  Any COBOL 85 compiler would have allowed the following solution to our problem:
@p @example
IF A = 1
    IF B = 1
        DISPLAY "A & B = 1"
    END-IF
ELSE
    IF B = 1
        DISPLAY "A NOT = 1 BUT B = 1"
    ELSE
        DISPLAY "NEITHER A NOR B = 1".
@end example
@* This new facility made the period almost obsolete, as our program segment would probably be coded like this today:
@p @example
IF A = 1
    IF B = 1
        DISPLAY "A & B = 1"
    END-IF
ELSE
    IF B = 1
        DISPLAY "A NOT = 1 BUT B = 1"
    ELSE
        DISPLAY "NEITHER A NOR B = 1"
    END-IF
END-IF
@end example
@* COBOL (GnuCOBOL included) still requires that each procedure division paragraph contain at least one sentence if there is any executable code in that paragraph, but a popular coding style is now to simply code a single period right before the end of each paragraph.
@p The standard for the COBOL language shows the various @syntax{END-verb} clauses are optional because using a period as a scope-terminator remains legal.
@p If you will be porting existing code over to GnuCOBOL, you'll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use.  If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the @syntax{END-verb} structures in those programs.
@comment *********************************************************************
@comment ** 6.13 Concurrent Access to Files                                 **
@comment *********************************************************************
@page
@newsection{6.13,Concurrent Access to Files}The manipulation of data files is one of the COBOL language's great strengths.  There are features built into COBOL to deal with the possibility that multiple programs may be attempting to access the same file concurrently.  Multiple program concurrent access is dealt with in two ways --- file sharing and record locking.
@p Not all GnuCOBOL implementations support file sharing and record-locking options.  Whether they do or not depends upon the operating system they were built for and the build options that were used when the specific GnuCOBOL implementation was generated.
@menu
* 6.13.1: File Sharing.
* 6.13.2: Record Locking.
@end menu
@comment *********************************************************************
@comment ** 6.13.1 File Sharing                                             **
@comment *********************************************************************
@newsubsection{6.13.1,File Sharing}GnuCOBOL controls concurrent-file access at the highest level through the concept of file sharing, enforced when a program attempts to open a file.  This is accomplished via a UNIX operating-system routine called "fcntl()".  That module is not currently supported by Windows and is not present in the MinGW Unix-emulation package.  GnuCOBOL builds created using a MinGW environment will be incapable of supporting file-sharing controls --- files will always be shared in such environments.  A GnuCOBOL build created using the Cygwin environment on Windows @i{would} have access to "fcntl()" and therefore @i{will} support file sharing.  Of course, actual Unix builds of GnuCOBOL, as well as OSX builds, should have no issues because "fcntl()" should be available.
@p Any limitations imposed on a successful @syntaxref{OPEN} will remain in place until your program either issues a @syntaxref{CLOSE} against the file or the program terminates.
@p File sharing is controlled through the use of a @syntaxidx{SHARING} clause:
@verbatim
    SHARING WITH { ALL OTHER }
    ~~~~~~~      { ~~~       }
                 { NO OTHER  }
                 { ~~        }
                 { READ ONLY }
                   ~~~~ ~~~~
@end verbatim
@* This clause may be used either in the file's @statementref{SELECT}, on the @statementref{OPEN} which initiates your program's use of the file, or both.  If a @syntax{SHARING} option is specified in @i{both} places, the specifications made on the @statement{OPEN} will take precedence over those from the @statement{SELECT}.
@p Here are the meanings of the three options:
@table @asis
@p @item @syntaxidx{ALL OTHER}
@p When your program opens a file with this sharing option in effect, no restrictions will be placed on other programs attempting to @syntax{OPEN} the file after your program did.  This is the default sharing mode.
@p @item @syntaxidx{NO OTHER}
@p When your program opens a file with this sharing option in effect, your program announces that it is unwilling to allow any other program to have any access to the file as long as you are using that file; @syntax{OPEN} attempts made in other programs will fail with a file status of 37 ("PERMISSION DENIED") until such time as you @syntaxref{CLOSE} the file.
@p @item @syntaxidx{READ ONLY}
@p Opening a file with this sharing option indicates you are willing to allow other programs to @syntax{OPEN} the file for input while you have it open.  If they attempt any other @syntax{OPEN}, theirs will fail with a file status of 37.  Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.
@end table
@* If the @syntax{SELECT} of a file is coded with a @syntax{FILE STATUS} clause, @syntax{OPEN} failures --- including those induced by sharing failures --- will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible.  If no such clause was coded, however, a runtime message will be issued and the program will be terminated.
@comment *********************************************************************
@comment ** 6.13.2 Record Locking                                           **
@comment *********************************************************************
@page
@newsubsection{6.13.2,Record Locking}Record-locking is supported by advanced file-management software built-in to the GnuCOBOL implementation you are using.  This software provides a single point-of-control for access to files --- usually @syntaxref{ORGANIZATION INDEXED} files.  One such runtime package capable of doing this is the Berkeley Database (BDB) package --- a package frequently used in GnuCOBOL builds to support indexed files.
@p The various I/O statements your program can execute are capable of imposing limitations on access by other concurrently-executing programs to the file record they just accessed.  These limitations are syntactically imposed by placing a lock on the record using a @syntax{LOCK} clause.  Other records in the file remain available, assuming that file-sharing limitations imposed at the time the file was opened didn't prevent access to the entire file.
@enumerate
@p @item If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the @envvarruntimeref{DB_HOME}.
@p @item If the @syntaxref{SELECT} statement or file @syntaxref{OPEN} specifies @syntax{SHARING WITH NO OTHER}, record locking will be disabled.
@p @item If the file's @syntax{SELECT} contains a @syntaxidx{LOCK MODE IS AUTOMATIC} clause, every time a record is read from the file, that record is automatically locked.  Other programs may access @i{other} records within the file, but not a locked record.
@p @item If the file's @syntax{SELECT} contains a @syntaxidx{LOCK MODE IS MANUAL} clause, locks are placed on records @i{only} when a @statement{READ} executed against the file includes a @syntax{LOCK} clause (this clause will be discussed shortly).
@p @item If the @syntax{LOCK ON} clause @i{is} specified in the file's @syntax{SELECT}, locks (either automatically or manually acquired) will continue to accumulate as more and more records are read, until they are explicitly released.  This is referred to as @define{multiple record locking}.
@p Locks acquired vie multiple record locking remain in-effect until the program holding the lock@dots{}
@itemize @bullet
@p @item @dots{}terminates, or @dots{}
@p @item @dots{}executes a @statementref{CLOSE} against the file, or @dots{}
@p @item @dots{}executes an @statementref{UNLOCK} against the file, or @dots{}
@p @item @dots{}executes a @statementref{COMMIT} or @dots{}
@p @item @dots{}executes a @statementref{ROLLBACK}.
@end itemize
@item If the @syntaxidx{LOCK ON} clause is @i{not} specified, then the next I/O statement your program executes, except for @syntaxref{START}, will release the lock.  This is referred to as @define{single record locking}.
@p @item A @syntax{LOCK} clause, which may be coded on a @syntaxref{READ}, @syntaxref{REWRITE} or @statementref{WRITE} looks like this:
@verbatim
    { IGNORING LOCK    }
    { ~~~~~~~~ ~~~~    }
    { WITH [ NO ] LOCK }
    {        ~~   ~~~~ }
    { WITH KEPT LOCK   }
    {      ~~~~ ~~~~   }
    { WITH IGNORE LOCK }
    {      ~~~~~~ ~~~~ }
    { WITH WAIT        }
           ~~~~
@end verbatim
@* The @syntax{WITH [ NO ] LOCK} option is the only one available to @syntax{REWRITE} or @statement{WRITE}s.
@p The meanings of the various record locking options are as follows:
@table @asis
@p @item @syntaxidx{IGNORING LOCK}
@itemx @syntaxidx{WITH IGNORE LOCK}
These options (which are synonymous) inform GnuCOBOL that any locks held by other programs should be ignored.
@p @item @syntaxidx{WITH LOCK}
Access to the record by other programs will be denied.
@p @item @syntaxidx{WITH NO LOCK}
The record will not be locked.  This is the default locking option in effect for all statements.
@p @item @syntaxidx{WITH KEPT LOCK}
When single record locking is in-effect, as a new record is accessed, locks held for previous records are released.  By using this option, not only is the newly-accessed record locked (as WITH LOCK would do), but prior record locks will be retained as well.  A subsequent @syntax{READ} without the @syntax{KEPT LOCK} option will release all "kept" locks, as will the @syntax{UNLOCK} statement.
@p @item @syntaxidx{WITH WAIT}
This option informs GnuCOBOL that the program is willing to wait for a lock held (by another program) on the record being read to be released.
@p Without this option, an attempt to read a locked record will be immediately aborted and a file status of 51 will be returned.
@p With this option, the program will wait for a pre-configured time for the lock to be released.  If the lock is released within the preconfigured wait time, the read will be successful.  If the pre-configured wait time expires before the lock is released, the read attempt will be aborted and a 51 file status will be issued.
@end table
@end enumerate
@comment *********************************************************************
@comment ** 6.14 Common Clauses on Executable Statements                    **
@comment *********************************************************************
@newsection{6.14,Common Clauses on Executable Statements}
@menu
* 6.14.1: AT END + NOT AT END.
* 6.14.2: CORRESPONDING.
* 6.14.3: INVALID KEY + NOT INVALID KEY.
* 6.14.4: ON EXCEPTION + NOT ON EXCEPTION.
* 6.14.5: ON OVERFLOW + NOT ON OVERFLOW.
* 6.14.6: ON SIZE ERROR + NOT ON SIZE ERROR.
* 6.14.7: ROUNDED.
@end menu
@comment *********************************************************************
@comment ** 6.14.1 AT END + NOT AT END                                      **
@comment *********************************************************************
@newsubsection{6.14.1,AT END + NOT AT END}
@diagram{AT END,PD-AT-END,PD-AT-END,None}@p @syntax{AT END} clauses may be specified on @syntaxref{READ}, @syntaxref{RETURN}, @syntaxref{SEARCH} and @syntaxref{SEARCH ALL} statements.
@enumerate
@p @item The following points pertain to the use of these clauses on @syntaxref{READ} and @syntaxref{RETURN} statements:
@enumerate A
@p @item The @syntax{AT END} clause will --- if present --- cause @term{imperative-statement-1} (@pxref{Imperative Statement}) to be executed if the statement fails due to a file status of 10 (end-of-file).  @xref{File Status Codes}, for a list of possible File Status codes.
@p An @syntax{AT END} clause @i{will not detect other non-zero file-status values}.
@p Use a @syntaxref{DECLARATIVES} routine or an explicitly-declared file status field tested after the @syntax{READ} or @syntax{RETURN} to detect error conditions other than end-of-file.
@p @item A @syntax{NOT AT END} clause will cause @term{imperative-statement-2} to be executed if the @syntax{READ} or @syntax{RETURN} attempt is successful.
@end enumerate
@item The following points pertain to the use of these clauses on @syntaxref{SEARCH} and @syntaxref{SEARCH ALL} statements:
@enumerate A
@p @item An @syntax{AT END} clause detects and handles the case where either form of table search has failed to locate an entry that satisfies the search conditions being used.
@p @item The @syntax{NOT AT END} clause is not allowed on either form of table search.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.14.2 CORRESPONDING                                            **
@comment *********************************************************************
@page
@newsubsection{6.14.2,CORRESPONDING}Three GnuCOBOL statements --- @syntaxrefalt{ADD,ADD CORRESPONDING}, @syntaxrefalt{MOVE,MOVE CORRESPONDING} and @syntaxrefalt{SUBTRACT,SUBTRACT CORRESPONDING} support the use of a @syntax{CORRESPONDING} option:
@verbatim
ADD CORRESPONDING group-item-1 TO group-item-2
MOVE CORRESPONDING group-item-1 TO group-item-2
SUBTRACT CORRESPONDING group-item-1 FROM group-item-2
@end verbatim
@* This option allows one or more data items within one group item (@term{group-item-1} --- the first named on the statement) to be paired with correspondingly-named (hence the name) in a second group item (@term{group-item-2} --- the second named on the statement).  The contents of @term{group-item-1} will remain unaffected by the statement while one or more data items within @term{group-item-2} will be changed.
@p In order for @term{data-item-1}, defined subordinate to group item @term{group-item-1} to be a "corresponding" match to @term{data-item-2} which is subordinate to @term{group-item-2}, each of the following must be true:
@enumerate
@p @item Both @term{data-item-1} and @term{data-item-2} must have the same name, and that name may not explicitly or implicitly be @syntax{FILLER}.
@p @item Both @term{data-item-1} and @term{data-item-2}@dots{}
@enumerate A
@p @item @dots{}must exist at the same relative structural "depth" of definition within @term{group-item-1} and @term{group-item-2}, respectively
@p @item @dots{}and all "parent" data items defined within each group item must have identical (but non-@syntax{FILLER}) names.
@end enumerate
@item When used with a @syntax{MOVE} verb@dots{}
@enumerate A
@p @item @dots{}one of @term{data-item-1} or @term{data-item-2} (but not both) is allowed to be a group item
@p @item @dots{}and it must be valid to move @term{data-item-1} TO @term{data-item-2}.
@end enumerate
@item When used with @syntax{ADD} or @syntax{SUBTRACT} verbs, both @term{data-item-1} and @term{data-item-2} must be numeric, elementary, unedited items.
@p @item  Neither @term{data-item-1} nor @term{data-item-2} may be a @syntaxref{REDEFINES} or @syntaxref{RENAMES} of another data item.
@p @item  Neither @term{data-item-1} nor @term{data-item-2} may have an @syntaxref{OCCURS} clause, although either may contain subordinate data items that @i{do} have an @syntax{OCCURS} clause (assuming rule 3a applies)
@end enumerate
@* Observe the definitions of data items "Q" and "Y"@dots{}
@p @example
01  Q.                           01  Y.
    03 X.                            02 A         PIC X(1).
       05 A         PIC 9(1).        02 G1.
       05 G1.                           03 G2.
          10 G2.                           04 B   PIC X(1).
             15 B   PIC X(1).        02 C         PIC X(1).
       05 C.                         02 G3.
          10 FILLER PIC X(1).           03 G5.
       05 G3.                              04 D   PIC X(1).
          10 G4.                        03 G6     PIC X(1).
             15 D   PIC X(1).        02 E         PIC 9(1).
       05 E         PIC X(1).        02 F         PIC X(1).
       05 F         REDEFINES V1     02 G         PIC X(4).
                    PIC X(1).        02 H         OCCURS 4 TIMES
       05 G.                                      PIC X(1).
          10 G6     OCCURS 4 TIMES   66 I         RENAMES E.
                    PIC X(1).        02 J.
       05 H         PIC X(4).           03 K.
       05 I         PIC 9(1).              04 L.
       05 J.                                  05 M.
          10 K.
             15 M   PIC X(1).
@end example
@* The following are the valid CORRESPONDING matches, assuming the statement @syntax{MOVE CORRESPONDING X TO Y} is being executed (there are no valid corresponding matches for @syntax{ADD CORRESPONDING} or @syntax{SUBTRACT CORRESPONDING} because every potential match up violates rule #4):
@p @center A, B, C, G
@p The following are the CORRESPONDING match ups that passed rule #1 (but failed on another rule), and the reasons why they failed.
@p @multitable @columnfractions .1 .9
@headitem Data Item @tab Failure Reason
@item @syntax{D} @tab Fails due to rule #2b
@item @syntax{E} @tab Fails due to rule #3b
@item @syntax{F} @tab Fails due to rule #5
@item @syntax{G1} @tab Fails due to rule #3a
@item @syntax{G2} @tab Fails due to rule #3a
@item @syntax{G3} @tab Fails due to rule #3a
@item @syntax{G4} @tab Fails due to rule #1
@item @syntax{G5} @tab Fails due to rule #1
@item @syntax{G6} @tab Fails due to rule #6
@item @syntax{H} @tab Fails due to rule #6
@item @syntax{I} @tab Fails due to rule #5
@item @syntax{J} @tab Fails due to rule #3a
@item @syntax{K} @tab Fails due to rule #3a
@item @syntax{L} @tab Fails due to rule #1
@item @syntax{M} @tab Fails due to rule #2a
@end multitable
@comment *********************************************************************
@comment ** 6.14.3 INVALID KEY + NOT INVALID KEY                            **
@comment *********************************************************************
@newsubsection{6.14.3,INVALID KEY + NOT INVALID KEY}
@diagram{INVALID KEY,PD-INVALID-KEY,PD-INVALID-KEY,None}@p @syntax{INVALID KEY} clauses may be specified on @syntaxref{DELETE}, @syntaxrefalt{READ,Random READ}, @syntaxref{REWRITE}, @syntaxref{START} and @syntaxref{WRITE} statements.
@p Specification of an @syntax{INVALID KEY} clause will allow your program to trap an I/O failure condition (with an I/O error code in the file's @syntaxrefalt{FILE-STATUS,SELECT} field) that has occurred due to a record-not-found condition and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).
@p An optional @syntaxidx{NOT INVALID KEY} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 6.14.4 ON EXCEPTION + NOT ON EXCEPTION                          **
@comment *********************************************************************
@newsubsection{6.14.4,ON EXCEPTION + NOT ON EXCEPTION}
@diagram{ON EXCEPTION,PD-ON-EXCEPTION,PD-ON-EXCEPTION,None}@p @syntax{EXCEPTION} clauses may be specified on @syntaxref{ACCEPT}, @syntaxref{CALL} and @syntaxref{DISPLAY} statements.
@p Specification of an exception clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2).  The program may also be terminated, depending upon the type and severity of the error.
@p An optional @syntaxidx{NOT ON EXCEPTION} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 6.14.5 ON OVERFLOW + NOT ON OVERFLOW                            **
@comment *********************************************************************
@newsubsection{6.14.5,ON OVERFLOW + NOT ON OVERFLOW}
@diagram{ON OVERFLOW,PD-ON-OVERFLOW,PD-ON-OVERFLOW,None}@p @syntax{OVERFLOW} clauses may be specified on @syntaxref{CALL}, @syntaxref{STRING} and @syntaxref{UNSTRING} statements.
@p An @syntax{ON OVERFLOW} clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2).  The program may also be terminated, depending upon the type and severity of the error.
@p An optional @syntaxidx{NOT ON OVERFLOW} clause will cause @term{imperative-statement-2} to be executed if the statement's execution was successful.
@comment *********************************************************************
@comment ** 6.14.6 ON SIZE ERROR + NOT ON SIZE ERROR                        **
@comment *********************************************************************
@newsubsection{6.14.6,ON SIZE ERROR + NOT ON SIZE ERROR}
@diagram{ON SIZE ERROR,PD-ON-SIZE-ERROR,PD-ON-SIZE-ERROR,None}@p @syntax{SIZE ERROR} clauses may be included on @syntaxref{ADD}, @syntaxref{COMPUTE}, @syntaxref{DIVIDE}, @syntaxref{MULTIPLY} and @syntaxref{SUBTRACT} statements.
@p Including an @syntax{ON SIZE ERROR} clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing @term{imperative-statement-1} (@pxref{Imperative Statement}).  Field size overflow conditions occur silently, usually without any runtime messages being generated, even though such events rarely lend themselves to generating correct results.  Division by zero errors, when no @syntax{ON SIZE ERROR} clause exists, will produce an error message (by the GnuCOBOL runtime library) to the SYSERR device (pipe 2) and will also abort the program.
@p An optional @syntaxidx{NOT ON SIZE ERROR} clause will cause @term{imperative-statement-2} to be executed if the arithmetic statement's execution was successful.
@comment *********************************************************************
@comment ** 6.14.7 ROUNDED                                                  **
@comment *********************************************************************
@newsubsection{6.14.7,ROUNDED}
@diagram{ROUNDED,PD-ROUNDED,PD-ROUNDED,None}@p GnuCOBOL provides for control over the final rounding process applied to the receiving fields on all arithmetic verbs.  Each of the arithmetic statements (@syntaxref{ADD}, @syntaxref{COMPUTE}, @syntaxref{DIVIDE}, @syntaxref{MULTIPLY} and @syntaxref{SUBTRACT}) statements allow an optional @syntax{ROUNDED} clause to be applied to each receiving data item.
@p The following rules apply to the rounding behaviour induced by this clause.
@enumerate
@p @item Rounding only applies when the result being saved to a receiving field with a @syntax{ROUNDED} clause is a non-integer value.
@p @item Absence of a @syntax{ROUNDED} clause is the same as specifying @syntax{ROUNDED MODE IS TRUNCATION}.
@p @item Use of a @syntax{ROUNDED} clause without a @syntax{MODE} specification is the same as specifying @syntax{ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO}.
@end enumerate
@* The behaviour of the eight different rounding modes is defined in the following table.  Note that a "@dots{}" indicates the last digit repeats.  The examples assume an integer receiving field.
@p @table @asis
@item @syntax{AWAY-FROM-ZERO}
@p Rounding is to the nearest value of larger magnitude.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -4 @tab +3.499@dots{} @result{} +4
@item -2.500 @result{} -3 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -3 @tab +2.499@dots{} @result{} +3
@end multitable
@item @syntax{NEAREST-AWAY-FROM-ZERO}
@p Rounding is to the nearest value (larger or smaller). If two values are equally near, the value with the larger absolute value is selected.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -3 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{NEAREST-EVEN}
@p Rounding is to the nearest value (larger or smaller).  If two values are equally near, the value whose rightmost digit is @i{even} is selected. This mode is sometimes called "Banker's rounding".
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -4 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{NEAREST-TOWARD-ZERO}
@p Rounding is to the nearest value (larger or smaller).  If two values are equally near, the value with the smaller absolute value is selected.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +4
@item -3.500 @result{} -3 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{PROHIBITED}
@p No rounding is performed.  If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the @syntaxrefalt{ACCEPT,ACCEPT FROM Runtime-Info} statement) and the results of the operation are undefined.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} Undefined @tab +3.510 @result{} Undefined
@item -3.500 @result{} Undefined @tab +3.500 @result{} Undefined
@item -3.499@dots{} @result{} Undefined @tab +3.499@dots{} @result{} Undefined
@item -2.500 @result{} Undefined @tab +2.500 @result{} Undefined
@item -2.499@dots{} @result{} Undefined @tab +2.499@dots{} @result{} Undefined
@end multitable
@item @syntax{TOWARD-GREATER}
@p Rounding is toward the nearest value whose algebraic value is larger.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -3 @tab +3.510 @result{} +4
@item -3.500 @result{} -3 @tab +3.500 @result{} +4
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +4
@item -2.500 @result{} -2 @tab +2.500 @result{} +3
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +3
@end multitable
@item @syntax{TOWARD-LESSER}
@p Rounding is toward the nearest value whose algebraic value is smaller.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -4 @tab +3.510 @result{} +3
@item -3.500 @result{} -4 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -4 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -3 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -3 @tab +2.499@dots{} @result{} +2
@end multitable
@item @syntax{TRUNCATION}
@p Rounding is to the nearest value whose magnitude is smaller.
@p @multitable @columnfractions .5 .5
@item -3.510 @result{} -3 @tab +3.510 @result{} +3
@item -3.500 @result{} -3 @tab +3.500 @result{} +3
@item -3.499@dots{} @result{} -3 @tab +3.499@dots{} @result{} +3
@item -2.500 @result{} -2 @tab +2.500 @result{} +2
@item -2.499@dots{} @result{} -2 @tab +2.499@dots{} @result{} +2
@end multitable
@end table
@comment *********************************************************************
@comment ** 6.15 Special Registers                                          **
@comment *********************************************************************
@page
@newsection{6.15,Special Registers}GnuCOBOL, like other COBOL dialects, includes a number of data items that are automatically available to a programmer without the need to actually define them in the data division.  COBOL refers to such items as registers or special registers.  The special registers available to a GnuCOBOL program are as follows:
@table @asis
@p @item @syntax{COB-CRT-STATUS}
@p PIC 9(4) --- This is the default data item allocated for use by the @statementrefalt{ACCEPT @term{screen-data-item},ACCEPT screen-data-item}, if no @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} clause was specified..
@p @item @syntax{DEBUG-ITEM}
@p Group Item --- A group item in which debugging information generated by a @syntax{USE FOR DEBUGGING} section in the declaratives area of the procedure division will place information documenting why the @syntax{USE FOR DEBUGGING} procedure was invoked.  Consult the @syntaxref{DECLARATIVES} documentation for information on the structure of this register.
@p @item @syntax{LINAGE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each selected file having a @syntaxrefalt{LINAGE,File/Sort-Description} clause.  If there are multiple files whose file descriptions have @syntax{LINAGE} clauses, any explicit references to this register will require qualification (using @syntax{OF file-name}).  The value of this register will be the current logical line number within the page body.  The value of this register cannot be modified.
@p @item @syntax{LINE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each report defined in the program (via an @syntaxrefalt{RD,REPORT SECTION}).  If there are multiple reports, any explicit references to this register not made in the report section will require qualification (@syntax{OF report-name}).  The value of this register will be the current logical line number on the current page.  The value of this register cannot be modified.
@p @item @syntax{NUMBER-OF-CALL-PARAMETERS}
@p BINARY-LONG SIGNED --- This register contains the number of arguments passed to a subroutine --- the same value that would be returned by the @subpgmref{C$NARG}.  Its value will be zero when referenced in a main program.  This register, when referenced from within a user-defined function, returns a value of one (1) if the function has any number of arguments and a zero if it has no arguments.
@p @item @syntax{PAGE-COUNTER}
@p BINARY-LONG SIGNED --- An occurrence of this register exists for each report having an @syntaxrefalt{RD,REPORT SECTION}.  If there are multiple such reports, any explicit references to this register not made in the report section will require qualification ( @syntax{OF report-name}).  The value of this register will be the current report page number.  The value of this register cannot be modified.
@p @item @syntax{RETURN-CODE}
@p BINARY-LONG SIGNED --- This register provides a numeric data item into which a subroutine may @syntaxref{MOVE} a value (which will then be available to the calling program) prior to transferring control back to the program that called it, or into which a main program may @syntax{MOVE} a value before returning control to the operating system.  Many built-in subroutines will return a value using this register.  These values are --- by convention --- used to signify success (usually with a value of 0) or failure (usually with a non-zero value) of the process the program was attempting to perform.  This register may also be modified by a subprogram as a result of that subprogram's use of the @syntaxrefalt{RETURNING,PROCEDURE DIVISION RETURNING} clause.
@p @item @syntax{SORT-RETURN}
@p BINARY-LONG SIGNED --- This register is used to report the success/fail status of a @syntaxref{RELEASE} or @syntaxref{RETURN} statement.  A value of 0 is reported on success.  A value of 16 denotes failure.  An @syntaxrefalt{AT END,AT END + NOT AT END} condition on a @syntax{RETURN} is not considered a failure.
@p @item @syntax{WHEN-COMPILED}
@p PIC X(16) --- This register contains the date and time the program was compiled in the format "mm/dd/yyhh.mm.ss".  Note that only a two-digit year is provided.
@end table
@comment *********************************************************************
@comment ** 6.16 Intrinsic Functions                                        **
@comment *********************************************************************
@page
@newsection{6.16,Intrinsic Functions}GnuCOBOL supports a wide variety of "intrinsic functions" that may be used anywhere in the PROCEDURE DIVISION where a literal is allowed.  For example:
@p @example
MOVE FUNCTION LENGTH(Employee-Last-Name) TO Employee-LN-Len
@end example
@* Note how the word @syntax{FUNCTION} is part of the syntax when you use an intrinsic function.  You can use intrinsic functions without having to include the reserved word @syntax{FUNCTION} via settings in the @syntaxref{REPOSITORY} paragraph.  You may accomplish the same thing by specifying the @switchidx{-fintrinsics} to the GnuCOBOL compiler when you compile your programs.
@p User-written functions (@pxref{Subprogram Types}) never require the @syntax{FUNCTION} keyword when they are executed, because each user-written function a program uses @i{must} be included in that program's @syntax{REPOSITORY} paragraph, which therefore makes the @syntax{FUNCTION} keyword optional.
@p The following intrinsic functions, known to other "dialects" of COBOL, are defined to GnuCOBOL as reserved words but are not otherwise implemented currently.  Any attempts to use these functions will result in a compile-time error message.
@p @example
BOOLEAN-OF-INTEGER
FORMATTED-CURRENT-DATE
INTEGER-OF-FORMATTED-DATE
CHAR-NATIONAL
FORMATTED-DATE
NATIONAL-OF
DISPLAY-OF
FORMATTED-DATETIME
STANDARD-COMPARE
EXCEPTION-FILE-N
FORMATTED-TIME
TEST-FORMATTED-DATETIME
EXCEPTION-LOCATION-N
INTEGER-OF-BOOLEAN
@end example
@* The supported intrinsic functions are listed in the following sections, along with their syntax and usage notes.
@menu
* 6.16.1:  ABS
* 6.16.2:  ACOS
* 6.16.3:  ANNUITY
* 6.16.4:  ASIN
* 6.16.5:  ATAN
* 6.16.6:  BYTE-LENGTH
* 6.16.7:  CHAR
* 6.16.8:  COMBINED-DATETIME
* 6.16.9:  CONCATENATE
* 6.16.10: COS
* 6.16.11: CURRENCY-SYMBOL
* 6.16.12: CURRENT-DATE
* 6.16.13: DATE-OF-INTEGER
* 6.16.14: DATE-TO-YYYYMMDD
* 6.16.15: DAY-OF-INTEGER
* 6.16.16: DAY-TO-YYYYDDD
* 6.16.17: E
* 6.16.18: EXCEPTION-FILE
* 6.16.19: EXCEPTION-LOCATION
* 6.16.20: EXCEPTION-STATEMENT
* 6.16.21: EXCEPTION-STATUS
* 6.16.22: EXP
* 6.16.23: EXP10
* 6.16.24: FACTORIAL
* 6.16.25: FRACTION-PART
* 6.16.26: HIGHEST-ALGEBRAIC
* 6.16.27: INTEGER
* 6.16.28: INTEGER-OF-DATE
* 6.16.29: INTEGER-OF-DAY
* 6.16.30: INTEGER-PART
* 6.16.31: LENGTH
* 6.16.32: LENGTH-AN
* 6.16.33: LOCALE-COMPARE
* 6.16.34: LOCALE-DATE
* 6.16.35: LOCALE-TIME
* 6.16.36: LOCALE-TIME-FROM-SECONDS
* 6.16.37: LOG
* 6.16.38: LOG10
* 6.16.39: LOWER-CASE
* 6.16.40: LOWEST-ALGEBRAIC
* 6.16.41: MAX
* 6.16.42: MEAN
* 6.16.43: MEDIAN
* 6.16.44: MIDRANGE
* 6.16.45: MIN
* 6.16.46: MOD
* 6.16.47: MODULE-CALLER-ID
* 6.16.48: MODULE-DATE
* 6.16.49: MODULE-FORMATTED-DATE
* 6.16.50: MODULE-ID
* 6.16.55: MODULE-PATH
* 6.16.52: MODULE-SOURCE
* 6.16.53: MODULE-TIME
* 6.16.54: MONETARY-DECIMAL-POINT
* 6.16.55: MONETARY-THOUSANDS-SEPARATOR
* 6.16.56: NUMERIC-DECIMAL-POINT
* 6.16.57: NUMERIC-THOUSANDS-SEPARATOR
* 6.16.58: NUMVAL
* 6.16.59: NUMVAL-C
* 6.16.60: NUMVAL-F
* 6.16.61: ORD
* 6.16.62: ORD-MAX
* 6.16.63: ORD-MIN
* 6.16.64: PI
* 6.16.65: PRESENT-VALUE
* 6.16.66: RANDOM
* 6.16.67: RANGE
* 6.16.68: REM
* 6.16.69: REVERSE
* 6.16.70: SECONDS-FROM-FORMATTED-TIME
* 6.16.71: SECONDS-PAST-MIDNIGHT
* 6.16.72: SIGN
* 6.16.73: SIN
* 6.16.74: SQRT
* 6.16.75: STANDARD-DEVIATION
* 6.16.76: STORED-CHAR-LENGTH
* 6.16.77: SUBSTITUTE
* 6.16.78: SUBSTITUTE-CASE
* 6.16.79: SUM
* 6.16.80: TAN
* 6.16.81: TEST-DATE-YYYYMMDD
* 6.16.82: TEST-DAY-YYYYDDD
* 6.16.83: TEST-NUMVAL
* 6.16.84: TEST-NUMVAL-C
* 6.16.85: TEST-NUMVAL-F
* 6.16.86: TRIM
* 6.16.87: UPPER-CASE
* 6.16.88: VARIANCE
* 6.16.89: WHEN-COMPILED
* 6.16.90: YEAR-TO-YYYY
@end menu
@comment *********************************************************************
@comment ** 6.16.1 ABS                                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.1,ABS}
@diagram{ABS Function,FN-ABS,FN-ABS,None}@p This function determines and returns the absolute value of the @term{number} (a numeric literal or data item) supplied as an argument.
@comment *********************************************************************
@comment ** 6.16.2 ACOS                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.2,ACOS}
@diagram{ACOS Function,FN-ACOS,FN-ACOS,None}@p The @syntax{ACOS} function determines and returns the trigonometric arc-cosine, or inverse cosine, of the @term{cosine} value (a numeric literal or data item) supplied as an argument.
@p The result will be an angle, expressed in radians.  You may convert this to an angle measured in degrees, as follows:
@p @center @syntax{COMPUTE @term{degrees} = ( @term{radians} * 180 ) / FUNCTION PI}
@comment *********************************************************************
@comment ** 6.16.3 ANNUITY                                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.3,ANNUITY}
@diagram{ANNUITY Function,FN-ANNUITY,FN-ANNUITY,None}@p This function returns a numeric value approximating the ratio of an annuity paid at the specified @term{interest-rate} (numeric data item or literal) for each of the specified @term{number-of-periods} (numeric data items or literals).
@p The @term{interest-rate} is the rate of interest paid at each payment.  If you only have an annual interest rate and you wish to compute monthly annuity payments, divide the annual interest rate by 12 and use that value for @term{interest-rate} on this function.
@p Multiply the result of this function times the desired principal amount to determine the amount of each period's payment.
@p A note for the financially challenged: an annuity is basically a reverse loan; an accountant would take the result of this function multiplied by -1 times the principal amount to compute a loan payment you are making.

@comment *********************************************************************
@comment ** 6.16.4 ASIN                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.4,ASIN}
@diagram{ASIN Function,FN-ASIN,FN-ASIN,None}@p The @syntax{ASIN} function determines and returns the trigonometric arc-sine, or inverse sine, of the @term{sine} value (a numeric literal or data item) supplied as an argument.
@p The result will be an angle, expressed in radians.  You may convert this to an angle measured in degrees, as follows:
@p @center @syntax{COMPUTE @term{degrees} = ( @term{radians} * 180 ) / FUNCTION PI}
@comment *********************************************************************
@comment ** 6.16.5 ATAN                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.5,ATAN}
@diagram{ATAN Function,FN-ATAN,FN-ATAN,None}@p Use this function to determine and return the trigonometric arc-tangent, or inverse tangent, of the @term{tangent} value (a numeric literal or data item) supplied as an argument.
@p The result will be an angle, expressed in radians.  You may convert this to an angle measured in degrees, as follows:
@p @center @syntax{COMPUTE @term{degrees} = ( @term{radians} * 180 ) / FUNCTION PI}
@comment *********************************************************************
@comment ** 6.16.6 BYTE-LENGTH                                              **
@comment *********************************************************************
@page
@newsubsection{6.16.6,BYTE-LENGTH}
@diagram{BYTE-LENGTH Function,FN-BYTE-LENGTH,FN-BYTE-LENGTH,None}@p @syntax{BYTE-LENGTH} returns the length --- in bytes --- of the specified @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal).  This intrinsic function is identical to the @syntaxref{LENGTH-AN} function.  Note that the value returned by this function is not necessarily the number of @i{characters} comprising @term{string}, but rather the number of actual @i{bytes} required to store it.
@p For example, if @term{string} is encoded using a double-byte character set such as UNICODE (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like ASCII or EBCDIC), then calling this function with a @term{string} argument whose @syntaxref{PICTURE} is @syntax{X(4)} would return a value of 8 rather than the value 4.
@p Contrast this with the @syntaxref{LENGTH} function.
@comment *********************************************************************
@comment ** 6.16.7 CHAR                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.7,CHAR}
@diagram{CHAR Function,FN-CHAR,FN-CHAR,None}@p This function returns the character in the ordinal position specified by the @term{integer} argument (a numeric integer literal or data item with a value of 1 or greater) from the @syntaxrefalt{COLLATING SEQUENCE,OBJECT-COMPUTER} being used by the program.
@p For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set --- an exclamation-point ("!").  If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.
@p If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.
@p The following code is an alternative approach when you just wish to convert a number to its ASCII equivalent:
@p @example
01  Char-Value.
    05 Numeric-Value        USAGE BINARY-CHAR.
@dots{}
    MOVE numeric-character-value TO Numeric-Value
@end example
@* The @syntax{Char-Value} item now has the corresponding ASCII character value.
@comment *********************************************************************
@comment ** 6.16.8 COMBINED-DATETIME                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.8,COMBINED-DATETIME}
@diagram{COMBINED-DATETIME Function,FN-COMBINED-DATETIME,FN-COMBINED-DATETIME,None}@p This function returns a 12-digit numeric result, the first seven digits of which are the integer value of the @term{days} argument (a numeric data item or literal) and the last five of which are the integer value of the @term{seconds} argument (also a numeric data item or literal).
@p If a @term{days} value less than 1 or greater than 3067671 is specified, or if a @term{seconds} value less than 1 or greater than 86400 is specified, a value of 0 is returned and a runtime error will result.
@comment *********************************************************************
@comment ** 6.16.9 CONCATENATE                                              **
@comment *********************************************************************
@page
@newsubsection{6.16.9,CONCATENATE}
@diagram{CONCATENATE Function,FN-CONCATENATE,FN-CONCATENATE,None}@p This function concatenates the @term{string-1}, @term{string-2}, @dots{} (group items, @syntax{USAGE DISPLAY} elementary items and/or alphanumeric literals) together into a single string result.
@p If a numeric literal or @syntax{PIC 9} identifier is specified as an argument, decimal points, if any, will be removed and negative signs in @syntax{PIC S9} fields or numeric literals will be inserted as defined by the @syntaxref{SIGN IS} clause (or absence thereof) of the field.  Numeric literals are processed as if @syntax{SIGN IS TRAILING SEPARATE} were in effect.
@comment *********************************************************************
@comment ** 6.16.10 COS                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.10,COS}
@diagram{COS Function,FN-COS,FN-COS,None}@p The @syntax{COS} function determines and returns the trigonometric cosine of the @term{angle} (a numeric literal or data item) supplied as an argument.
@p The @term{angle} is assumed to be a value expressed in radians.  If you need to determine the cosine of an angle measured in degrees, you first need to convert that angle to radians as follows:
@p @center @syntax{COMPUTE @term{radians} = ( @term{degrees} * FUNCTION PI) / 180}
@comment *********************************************************************
@comment ** 6.16.11 CURRENCY-SYMBOL                                         **
@comment *********************************************************************
@page
@newsubsection{6.16.11,CURRENCY-SYMBOL}
@diagram{CURRENCY-SYMBOL Function,FN-CURRENCY-SYMBOL,FN-CURRENCY-SYMBOL,None}@p The @syntax{CURRENCY-SYMBOL} function returns the currency symbol character currently in effect for the locale under which your program is running.  On UNIX systems, your locale is established via the @envvarruntimeref{LANG} environment variable.  On Windows, the Control Panel's "Regional and Language Options" define the locale.
@p Changing the currency symbol via the @syntaxref{SPECIAL-NAMES} paragraph's @syntax{CURRENCY SYMBOL} setting will @i{not} affect the value returned by this function.
@comment *********************************************************************
@comment ** 6.16.12 CURRENT-DATE                                            **
@comment *********************************************************************
@page
@newsubsection{6.16.12,CURRENT-DATE}
@diagram{CURRENT-DATE Function,FN-CURRENT-DATE,FN-CURRENT-DATE,None}@p Returns the current date and time as the following 21-character structure:
@p @example
01  CURRENT-DATE-AND-TIME.
    05 CDT-Year                PIC 9(4).
    05 CDT-Month               PIC 9(2). *> 01-12
    05 CDT-Day                 PIC 9(2). *> 01-31
    05 CDT-Hour                PIC 9(2). *> 00-23
    05 CDT-Minutes             PIC 9(2). *> 00-59
    05 CDT-Seconds             PIC 9(2). *> 00-59
    05 CDT-Hundredths-Of-Secs  PIC 9(2). *> 00-99
    05 CDT-GMT-Diff-Hours      PIC S9(2)
                               SIGN LEADING SEPARATE.
    05 CDT-GMT-Diff-Minutes    PIC 9(2). *> 00 or 30
@end example
@* Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.13 DATE-OF-INTEGER                                         **
@comment *********************************************************************
@page
@newsubsection{6.16.13,DATE-OF-INTEGER}
@diagram{DATE-OF-INTEGER Function,FN-DATE-OF-INTEGER,FN-DATE-OF-INTEGER,None}@p This function returns a numeric calendar date in yyyymmdd (i.e. Gregorian) format.  The date is determined by adding the number of days specified as @term{integer} (a numeric integer data item or literal) to the date December 31, 1600.  For example, @syntax{DATE-OF-INTEGER(1)} returns 16010101 while @syntax{DATE-OF-INTEGER(150000)} returns 20110908.
@p A value less than 1 or greater than 3067671 (9999/12/31) will return a result of 0.
@comment *********************************************************************
@comment ** 6.16.14 DATE-TO-YYYYMMDD                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.14,DATE-TO-YYYYMMDD}
@diagram{DATE-TO-YYYYMMDD Function,FN-DATE-TO-YYYYMMDD,FN-DATE-TO-YYYYMMDD,None}@p You can use this function to convert the six-digit Gregorian date specified as @term{yymmdd} (a numeric integer data item or literal) to an eight-digit format (yyyymmdd).
@p The optional @term{yy-cutoff} (a numeric integer data item or literal) argument is the year cutoff used to delineate centuries; if the year component of the date meets or exceeds this cutoff value, the result will be 19yymmdd; if the year component of the date is less than the cutoff value, the result will be 20yymmdd.  The default cutoff value if no second argument is given will be 50.
@comment *********************************************************************
@comment ** 6.16.15 DAY-OF-INTEGER                                          **
@comment *********************************************************************
@page
@newsubsection{6.16.15,DAY-OF-INTEGER}
@diagram{DAY-OF-INTEGER Function,FN-DAY-OF-INTEGER,FN-DAY-OF-INTEGER,None}@p This function returns a calendar date in yyyyddd (i.e. Julian) format.  The date is determined by adding the number of days specified as integer (a numeric integer data item or literal) to December 31, 1600.  For example, @syntax{DAY-OF-INTEGER(1)} returns 1601001 while @syntax{DAY-OF-INTEGER(250000)} returns 2011251.
@p A value less than 1 or greater than 3067671 (9999/12/31) will return a result of 0.
@comment *********************************************************************
@comment ** 6.16.16 DAY-TO-YYYYDDD                                          **
@comment *********************************************************************
@page
@newsubsection{6.16.16,DAY-TO-YYYYDDD}
@diagram{DAY-TO-YYYYDDD Function,FN-DAY-TO-YYYYDDD,FN-DAY-TO-YYYYDDD,None}@p You can use this function to convert the five-digit Julian date specified as @term{yyddd} (a numeric integer data item or literal) to a seven-digit numeric Julian format (yyyyddd).
@p The optional @term{yy-cutoff} argument (a numeric integer data item or literal) is the year cutoff used to delineate centuries; if the year component of the date meets or exceeds this cutoff value, the result will be 19yyddd; if the year component of the date is less than the cutoff, the result will be 20yyddd.  The default cutoff value if no second argument is given will be 50.
@comment *********************************************************************
@comment ** 6.16.17 E                                                       **
@comment *********************************************************************
@page
@newsubsection{6.16.17,E}
@diagram{E Function,FN-E,FN-E,None}@p This function returns the mathematical constant "E" (the base of natural logarithms).  The maximum precision with which this value may be returned is 2.7182818284590452353602874713526625.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.18 EXCEPTION-FILE                                          **
@comment *********************************************************************
@page
@newsubsection{6.16.18,EXCEPTION-FILE}
@diagram{EXCEPTION-FILE Function,FN-EXCEPTION-FILE,FN-EXCEPTION-FILE,None}@p This function returns I/O exception information from the most-recently executed input or output statement.  The information is returned as a 34-character string, where the first two characters are the two-digit file status value (@pxref{File Status Codes}) and the remaining 32 are the @term{file-name-1} specification from the file's @syntaxref{SELECT} statement.
@p The name returned after the file status information will be returned only if the returned file status value is not 00.
@p Since this function has no arguments, no parenthesis should be specified.
@p The documentation of the @subpgmref{CBL_ERROR_PROC} built-in subroutine illustrates the use of this function.
@comment *********************************************************************
@comment ** 6.16.19 EXCEPTION-LOCATION                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.19,EXCEPTION-LOCATION}
@diagram{EXCEPTION-LOCATION Function,FN-EXCEPTION-LOCATION,FN-EXCEPTION-LOCATION,None}@p This function returns exception information from the most-recently failing statement.  The information is returned to a 1023 character string in one of the following formats, depending on the nature of the failure:
@itemize @bullet
@p @item primary-entry-point-name; paragraph OF section; statement-number
@p @item primary-entry-point-name; section; statement-number
@p @item primary-entry-point-name; paragraph; statement-number
@p @item primary-entry-point-name; statement-number
@end itemize
@* Since this function has no arguments, no parenthesis should be specified.
@p The program must be compiled with the @switchidx{-debug}, @switchidx{-ftraceall} or @switchidx{-g} for this function to return any meaningful information.
@p The documentation of the @subpgmref{CBL_ERROR_PROC} built-in subroutine illustrates the use of this function.
@comment *********************************************************************
@comment ** 6.16.20 EXCEPTION-STATEMENT                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.20,EXCEPTION-STATEMENT}
@diagram{EXCEPTION-STATEMENT Function,FN-EXCEPTION-STMT,FN-EXCEPTION-STMT,None}@p This function returns the most-recent COBOL statement that generated an exception condition.
@p Since this function has no arguments, no parenthesis should be specified.
@p The program must be compiled with the @switchidx{-debug}, @switchidx{-ftraceall} or @switchidx{-g} for this function to return any meaningful information.
@p The documentation of the @subpgmref{CBL_ERROR_PROC} built-in subroutine illustrates the use of this function.
@comment *********************************************************************
@comment ** 6.16.21 EXCEPTION-STATUS                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.21,EXCEPTION-STATUS}
@diagram{EXCEPTION-STATUS Function,FN-EXCEPTION-STATUS,FN-EXCEPTION-STATUS,None}@p This function returns the error type (a text string --- see column 2 of the upcoming table for the possible values) from the most-recent COBOL statement that generated an exception condition.
@p Since this function has no arguments, no parenthesis should be specified.
@p The documentation of the @subpgmref{CBL_ERROR_PROC} built-in subroutine illustrates the use of this function.
@p The following are the error type strings, and their corresponding exception codes and descriptions.
@anchoridx{Error Exception Codes}@anchoridx{Error Type Strings}
@multitable @columnfractions .075 .35 .575
@headitem Code @tab Error Type @tab Description
@p @item 0101 @tab EC-ARGUMENT-FUNCTION @tab Function argument error
@p @item 0202 @tab EC-BOUND-ODO @tab OCCURS @dots{} DEPENDING ON data item out of bounds
@p @item 0204 @tab EC-BOUND-PTR @tab Data-pointer contains an address that is out of bounds
@p @item 0205 @tab EC-BOUND-REF-MOD @tab Reference modifier out of bounds
@p @item 0207 @tab EC-BOUND-SUBSCRIPT @tab Subscript out of bounds
@p @item 0303 @tab EC-DATA-INCOMPATIBLE @tab Incompatible data exception
@p @item 0500 @tab EC-I-O @tab input-output exception
@p @item 0501 @tab EC-I-O-AT-END @tab I-O status "1x"
@p @item 0502 @tab EC-I-O-EOP @tab An end of page condition occurred
@p @item 0504 @tab EC-I-O-FILE-SHARING @tab I-O status "6x"
@p @item 0505 @tab EC-I-O-IMP @tab I-O status "9x"
@p @item 0506 @tab EC-I-O-INVALID-KEY @tab I-O status "2x"
@p @item 0508 @tab EC-I-O-LOGIC-ERROR @tab I-O status "4x"
@p @item 0509 @tab EC-I-O-PERMANENT-ERROR @tab I-O status "3x"
@p @item 050A @tab EC-I-O-RECORD-OPERATION @tab I-O status "5x"
@p @item 0601 @tab EC-IMP-ACCEPT @tab Implementation-defined accept condition
@p @item 0602 @tab EC-IMP-DISPLAY @tab Implementation-defined display condition
@p @item 0A00 @tab EC-OVERFLOW @tab Overflow condition
@p @item 0A02 @tab EC-OVERFLOW-STRING @tab STRING overflow condition
@p @item 0A03 @tab EC-OVERFLOW-UNSTRING @tab UNSTRING overflow condition
@p @item 0B05 @tab EC-PROGRAM-NOT-FOUND @tab Called program not found
@p @item 0D03 @tab EC-RANGE-INSPECT-SIZE @tab Size of replace item in inspect differs
@p @item 1000 @tab EC-SIZE @tab Size error exception
@p @item 1004 @tab EC-SIZE-OVERFLOW @tab Arithmetic overflow in calculation
@p @item 1005 @tab EC-SIZE-TRUNCATION @tab Significant digits truncated in store
@p @item 1007 @tab EC-SIZE-ZERO-DIVIDE @tab Division by zero
@p @item 1202 @tab EC-STORAGE-NOT-ALLOC @tab The data-pointer specified in a FREE statement does not identify currently allocated storage
@p @item 1203 @tab EC-STORAGE-NOT-AVAIL @tab The amount of storage requested by an ALLOCATE statement is not available
@end multitable
@comment *********************************************************************
@comment ** 6.16.22 EXP                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.22,EXP}
@diagram{EXP Function,FN-EXP,FN-EXP,None}@p Computes and returns the value of the mathematical constant "e" raised to the power specified by @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.23 EXP10                                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.23,EXP10}
@diagram{EXP10 Function,FN-EXP10,FN-EXP10,None}@p Computes and returns the value of 10 raised to the power specified by @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.24 FACTORIAL                                               **
@comment *********************************************************************
@page
@newsubsection{6.16.24,FACTORIAL}
@diagram{FACTORIAL Function,FN-FACTORIAL,FN-FACTORIAL,None}@p This function computes and returns the factorial value of @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.25 FRACTION-PART                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.25,FRACTION-PART}
@diagram{FRACTION-PART Function,FN-FRACTION-PART,FN-FRACTION-PART,None}@p This function returns that portion of @term{number} (a numeric data item or a numeric literal) that occurs to the right of the decimal point.  @syntax{FRACTION-PART(3.1415)}, for example, returns a value of 0.1415.  This function is equivalent to the expression:
@p @center @t{@term{number} -- FUNCTION INTEGER-PART(@term{number})}
@comment *********************************************************************
@comment ** 6.16.26 HIGHEST-ALGEBRAIC                                       **
@comment *********************************************************************
@page
@newsubsection{6.16.26,HIGHEST-ALGEBRAIC}
@diagram{HIGHEST-ALGEBRAIC Function,FN-HIGHEST-ALGEBRAIC,FN-HIGHEST-ALGEBRAIC,None}@p This function returns the highest (i.e. largest or farthest away from 0 in a positive direction if @term{numeric-identifier} is signed) value that could possibly be stored in the specified @term{numeric-identifier}.
@comment *********************************************************************
@comment ** 6.16.27 INTEGER                                                 **
@comment *********************************************************************
@page
@newsubsection{6.16.27,INTEGER}
@diagram{INTEGER Function,FN-INTEGER,FN-INTEGER,None}@p The @syntax{INTEGER} function returns the greatest integer value that is less than or equal to @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.28 INTEGER-OF-DATE                                         **
@comment *********************************************************************
@page
@newsubsection{6.16.28,INTEGER-OF-DATE}
@diagram{INTEGER-OF-DATE Function,FN-INTEGER-OF-DATE,FN-INTEGER-OF-DATE,None}@p This function converts @term{date} (a numeric integer data item or literal) --- presumed to be a Gregorian calendar form standard date (YYYYMMDD) --- to internal date form (the number of days that have transpired since 1600/12/31).
@p Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the @syntaxref{DATE-OF-INTEGER} or @syntaxref{DAY-OF-INTEGER} function.
@comment *********************************************************************
@comment ** 6.16.29 INTEGER-OF-DAY                                          **
@comment *********************************************************************
@page
@newsubsection{6.16.29,INTEGER-OF-DAY}
@diagram{INTEGER-OF-DAY Function,FN-INTEGER-OF-DAY,FN-INTEGER-OF-DAY,None}@p This function converts @term{date} (a numeric integer data item or literal) --- presumed to be a Julian calendar form standard date (YYYYDDD) --- to internal date form (the number of days that have transpired since 1600/12/31).
@p Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the @syntaxref{DATE-OF-INTEGER} or @syntaxref{DAY-OF-INTEGER} function.
@comment *********************************************************************
@comment ** 6.16.30 INTEGER-PART                                            **
@comment *********************************************************************
@page
@newsubsection{6.16.30,INTEGER-PART}
@diagram{INTEGER-PART Function,FN-INTEGER-PART,FN-INTEGER-PART,None}@p Returns the integer portion of the value of @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.31 LENGTH                                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.31,LENGTH}
@diagram{LENGTH Function,FN-LENGTH,FN-LENGTH,None}@p Returns the length --- in characters --- of @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal).
@p The value returned by this function is not the number of @i{bytes} of storage occupied by string, but rather the number of actual @i{characters} making up the string.  For example, if @term{string} is encoded using a double-byte character set such as UNICODE (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like ASCII or EBCDIC), then calling this function with a @term{string} argument whose @syntax{PICTURE is X(4)} would return a value of 4 rather than the value 8 (the actual number of bytes of storage occupied by that item).
@p Contrast this function with the @syntaxref{BYTE-LENGTH} and @syntaxref{LENGTH-AN} functions.
@comment *********************************************************************
@comment ** 6.16.32 LENGTH-AN                                               **
@comment *********************************************************************
@page
@newsubsection{6.16.32,LENGTH-AN}
@diagram{LENGTH-AN Function,FN-LENGTH-AN,FN-LENGTH-AN,None}@p This function returns the length --- in bytes of storage --- of @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal).
@p This intrinsic function is identical to the @syntaxref{BYTE-LENGTH} function.
@p Note that the value returned by this function is not the number of @i{characters} making up the @term{string}, but rather the number of actual @i{bytes} of storage required to store @term{string}.  For example, if @term{string} is encoded using a double-byte character set such as UNICODE (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like ASCII or EBCDIC), then calling this function with a @term{string} argument whose @syntax{PICTURE is X(4)} would return a value of 8 rather than the value 4.
@p Contrast this with the @syntaxref{LENGTH} function.
@comment *********************************************************************
@comment ** 6.16.33 LOCALE-COMPARE                                          **
@comment *********************************************************************
@page
@newsubsection{6.16.33,LOCALE-COMPARE}
@diagram{LOCALE-COMPARE Function,FN-LOCALE-COMPARE,FN-LOCALE-COMPARE,None}@p The @syntax{LOCALE-COMPARE} function returns a character indicating the result of comparing @term{argument-1} and @term{argument-2} using a culturally-preferred ordering defined by a @term{locale}.
@p Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data.  If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.
@p The two arguments will be compared, character by character, against each other until their relationship to each other can be determined.  The comparison is made according to the cultural rules in effect for the specified @term{locale} name or for the current locale if no @term{locale} argument is specified.  Once that relationship is determined, a one-character alphanumeric value will be returned as follows:
@itemize
@p @item "<" --- If @term{argument-1} is determined to be less than @term{argument-2}
@p @item "=" --- If the two arguments are equal to each other
@p @item ">" --- If @term{argument-1} is determined to be greater than @term{argument-2}
@end itemize
@p @xref{LOCALE Names}, for a list of typically-available locale names.
@comment *********************************************************************
@comment ** 6.16.34 LOCALE-DATE                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.34,LOCALE-DATE}
@diagram{LOCALE-DATE Function,FN-LOCALE-DATE,FN-LOCALE-DATE,None}@p Converts the eight-digit Gregorian @term{date} (a numeric integer data item or literal) from yyyymmdd format to the format appropriate to the current locale.  On a Windows system, this will be the "short date" format as set using Control Panel.
@p You may include an optional second argument to specify the @term{locale} name (group item or @syntax{PIC X} identifier) you'd like to use for date formatting.  If used, this second argument @i{must} be an identifier.  Locale names are specified using UNIX-standard names.
@comment *********************************************************************
@comment ** 6.16.35 LOCALE-TIME                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.35,LOCALE-TIME}
@diagram{LOCALE-TIME Function,FN-LOCALE-TIME,FN-LOCALE-TIME,None}@p Converts the four- (hhmm) or six-digit (hhmmss) @term{time} (a numeric integer data item or literal) to a format appropriate to the current locale.  On a Windows system, this will be the "time" format as set using Control Panel.
@p You may include an optional @term{locale} name (a group item or @syntax{PIC X} identifier) you'd like to use for time formatting.  If used, this second argument @i{must} be an identifier.  Locale names are specified using UNIX-standard names.
@comment *********************************************************************
@comment ** 6.16.36 LOCALE-TIME-FROM-SECONDS                                **
@comment *********************************************************************
@page
@newsubsection{6.16.36,LOCALE-TIME-FROM-SECONDS}
@diagram{LOCALE-TIME-FROM-SECONDS Function,FN-LOC-TM-FROM-SECS,FN-LOC-TM-FROM-SECS,None}@p Converts the number of @term{seconds} since midnight (a numeric integer data item or literal) to a format appropriate to the current locale.  On a Windows system, this will be the "time" format as set using Control Panel.
@p You may include an optional @term{locale} name (a group item or @syntax{PIC X} identifier) you'd like to use for time formatting.  If used, this second argument @i{must} be an identifier.  Locale names are specified using UNIX-standard names.
@p @xref{LOCALE Names}, for a list of typically-available locale names.
@comment *********************************************************************
@comment ** 6.16.37 LOG                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.37,LOG}
@diagram{LOG Function,FN-LOG,FN-LOG,None}@p Computes and returns the natural logarithm (base "e") of @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.38 LOG10                                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.38,LOG10}
@diagram{LOG10 Function,FN-LOG10,FN-LOG10,None}@p Computes and returns the base 10 logarithm of @term{number} (a numeric literal or data item).
@comment *********************************************************************
@comment ** 6.16.39 LOWER-CASE                                              **
@comment *********************************************************************
@page
@newsubsection{6.16.39,LOWER-CASE}
@diagram{LOWER-CASE Function,FN-LOWER-CASE,FN-LOWER-CASE,None}@p This function returns the value of @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal), converted entirely to lower case.
@p What constitutes a "letter" (or upper/lower case too, for that manner) may be influenced through the use of a @syntaxrefalt{CHARACTER CLASSIFICATION,OBJECT-COMPUTER}.
@comment *********************************************************************
@comment ** 6.16.40 LOWEST-ALGEBRAIC                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.40,LOWEST-ALGEBRAIC}
@diagram{LOWEST-ALGEBRAIC Function,FN-LOWEST-ALGEBRAIC,FN-LOWEST-ALGEBRAIC,None}@p This function returns the lowest (i.e. smallest or farthest away from 0 in a negative direction if @term{numeric-identifier} is signed) value that could possibly be stored in the specified @term{numeric-identifier}.
@comment *********************************************************************
@comment ** 6.16.41 MAX                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.41,MAX}
@diagram{MAX Function,FN-MAX,FN-MAX,None}@p This function returns the maximum value from the specified list of numbers (each @term{number-n} may be a numeric data item or a numeric literal).
@comment *********************************************************************
@comment ** 6.16.42 MEAN                                                    **
@comment *********************************************************************
@page
@newsubsection{6.16.42,MEAN}
@diagram{MEAN Function,FN-MEAN,FN-MEAN,None}@p This function returns the statistical mean value of the specified list of numbers (each @term{number-n} may be a numeric data item or a numeric literal).
@comment *********************************************************************
@comment ** 6.16.43 MEDIAN                                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.43,MEDIAN}
@diagram{MEDIAN Function,FN-MEDIAN,FN-MEDIAN,None}@p This function returns the statistical median value of the specified list of numbers (each @term{number-n} may be a numeric data item or a numeric literal).
@comment *********************************************************************
@comment ** 6.16.44 MIDRANGE                                                **
@comment *********************************************************************
@page
@newsubsection{6.16.44,MIDRANGE}
@diagram{MIDRANGE Function,FN-MIDRANGE,FN-MIDRANGE,None}@p The @syntax{MIDRANGE} (middle range) function returns a numeric value that is the arithmetic mean (average) of the values of the minimum and maximum numbers from the supplied list.  Each @term{number-n} may be a numeric data items or a numeric literal.
@comment *********************************************************************
@comment ** 6.16.45 MIN                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.45,MIN}
@diagram{MIN Function,FN-MIN,FN-MIN,None}@p This function returns the minimum value from the specified list of numbers (each @term{number-n} may be a numeric data item or a numeric literal).
@comment *********************************************************************
@comment ** 6.16.46 MOD                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.46,MOD}
@diagram{MOD Function,FN-MOD,FN-MOD,None}@p This function returns the value of @term{value} modulo @term{modulus} (essentially the remainder from the division of @term{value} by @term{modulus}).  Both arguments may be numeric data items or numeric literals.  Either (or both) may have a non-integer value.
@comment *********************************************************************
@comment ** 6.16.47 MODULE-CALLER-ID                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.47,MODULE-CALLER-ID}
@diagram{MODULE-CALLER-ID Function,FN-MODULE-CALLER-ID,FN-MODULE-CALLER-ID,None}@p This function returns the null string if it is executed within a main program.  When executed with a subprogram, it returns the entry-point name of the program that called the subprogram.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.48 MODULE-DATE                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.48,MODULE-DATE}
@diagram{MODULE-DATE Function,FN-MODULE-DATE,FN-MODULE-DATE,None}@p This function Returns the date the GnuCOBOL program that is executing the function was compiled, in the form yyyymmdd.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.49 MODULE-FORMATTED-DATE                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.49,MODULE-FORMATTED-DATE}
@diagram{MODULE-FORMATTED-DATE Function,FN-MODULE-FMTD-DATE,FN-MODULE-FMTD-DATE,None}@p This function returns the fully-formatted date and time when the program executing the function was compiled.  The exact format of this returned string value may vary depending on the operating system and GnuCOBOL build type.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.50 MODULE-ID                                               **
@comment *********************************************************************
@page
@newsubsection{6.16.50,MODULE-ID}
@diagram{MODULE-ID Function,FN-MODULE-ID,FN-MODULE-ID,None}@p This function returns the primary entry-point name (i.e. the @syntax{PROGRAM-ID} or @syntax{FUNCTION-ID} of the program.  @xref{IDENTIFICATION DIVISION}, for information on those clauses.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.55 MODULE-PATH                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.55,MODULE-PATH}
@diagram{MODULE-PATH Function,FN-MODULE-PATH,FN-MODULE-PATH,None}@p This function returns the full path to the executable version of this GnuCOBOL program.  The filename component of this value will be exactly as typed on the command line, down to the use of upper- and lower-case letters and presence (or absence) of any extension.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.52 MODULE-SOURCE                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.52,MODULE-SOURCE}
@diagram{MODULE-SOURCE Function,FN-MODULE-SOURCE,FN-MODULE-SOURCE,None}@p The filename of the source code of the program (as specified on the "cobc" command when the program was compiled) is returned by this function.
@p The discussion of the @syntaxref{MODULE-TIME} function includes a sample program that uses this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.53 MODULE-TIME                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.53,MODULE-TIME}
@diagram{MODULE-TIME Function,FN-MODULE-TIME,FN-MODULE-TIME,None}@p This function returns the time the GnuCOBOL program was compiled, in the form hhmmss.
@p Since this function has no arguments, no parenthesis should be specified.
@p The following sample program uses all the MODULE- Functions:
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DEMOMODULE.
ENVIRONMENT DIVISION.
CONFIGURATION SECTION.
REPOSITORY.
    FUNCTION ALL INTRINSIC.
PROCEDURE DIVISION.
000-Main.
    DISPLAY "MODULE-CALLER-ID      = [" MODULE-CALLER-ID "]"
    DISPLAY "MODULE-DATE           = [" MODULE-DATE "]"
    DISPLAY "MODULE-FORMATTED-DATE = [" MODULE-FORMATTED-DATE "]"
    DISPLAY "MODULE-ID             = [" MODULE-ID "]"
    DISPLAY "MODULE-PATH           = [" MODULE-PATH "]"
    DISPLAY "MODULE-SOURCE         = [" MODULE-SOURCE "]"
    DISPLAY "MODULE-TIME           = [" MODULE-TIME "]"
    STOP RUN
    .
@end example
@* The program produces this output when executed:
@p @example
MODULE-CALLER-ID      = []
MODULE-DATE           = [20120614]
MODULE-FORMATTED-DATE = [Jun 14 2012 15:07:45]
MODULE-ID             = [DEMOMODULE]
MODULE-PATH           = [E:\Programs\Demos\DEMOMODULE.exe]
MODULE-SOURCE         = [DEMOMODULE.cbl]
MODULE-TIME           = [150745]
@end example
@comment *********************************************************************
@comment ** 6.16.54 MONETARY-DECIMAL-POINT                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.54,MONETARY-DECIMAL-POINT}
@diagram{MONETARY-DECIMAL-POINT Function,FN-MON-DECIMAL-POINT,FN-MON-DECIMAL-POINT,None}@p @syntax{MONETARY-DECIMAL-POINT} returns the character used to separate the integer portion from the fractional part of a monetary currency value according to the rules currently in effect for the locale under which your program is running.
@p On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the @envvarruntimeref{LANG} environment variable.  On Windows, the Control Panel's Regional and Language Options define the locale.
@p Using the @syntaxrefalt{DECIMAL-POINT IS COMMA,SPECIAL-NAMES} clause in your program will not affect the value returned by this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.55 MONETARY-THOUSANDS-SEPARATOR                            **
@comment *********************************************************************
@page
@newsubsection{6.16.55,MONETARY-THOUSANDS-SEPARATOR}
@diagram{MONETARY-THOUSANDS-SEPARATOR Function,FN-MON-THOUSANDS-SEP,FN-MON-THOUSANDS-SEP,None}@p This function returns the character used to separate the thousands digit groupings of monetary currency values according to the rules currently in effect for the locale under which your program is running.
@p On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the @envvarruntimeref{LANG} environment variable.  On Windows, the Control Panel's Regional and Language Options define the locale.
@p Using the @syntaxrefalt{DECIMAL-POINT IS COMMA,SPECIAL-NAMES} clause in your program will not affect the value returned by this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.56 NUMERIC-DECIMAL-POINT                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.56,NUMERIC-DECIMAL-POINT}
@diagram{NUMERIC-DECIMAL-POINT Function,FN-NUM-DECIMAL-POINT,FN-NUM-DECIMAL-POINT,None}@p This function returns the character used to separate the integer portion of a non-integer numeric item from the fractional part according to the rules currently in effect for the locale under which your program is running.
@p On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the @envvarruntimeref{LANG} environment variable.  On Windows, the Control Panel's Regional and Language Options define the locale.
@p Using the @syntaxrefalt{DECIMAL-POINT IS COMMA,SPECIAL-NAMES} clause in your program will not affect the value returned by this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.57 NUMERIC-THOUSANDS-SEPARATOR                             **
@comment *********************************************************************
@page
@newsubsection{6.16.57,NUMERIC-THOUSANDS-SEPARATOR}
@diagram{NUMERIC-THOUSANDS-SEPARATOR Function,FN-NUM-THOUSANDS-SEP,FN-NUM-THOUSANDS-SEP,None}@p This function returns the character used to separate the thousands digit groupings of numeric values according to the rules currently in effect for the locale under which your program is running.
@p On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the @envvarruntimeref{LANG} environment variable.  On Windows, the Control Panel's Regional and Language Options define the locale.
@p Using the @syntaxrefalt{DECIMAL-POINT IS COMMA,SPECIAL-NAMES} clause in your program will not affect the value returned by this function.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.58 NUMVAL                                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.58,NUMVAL}
@diagram{NUMVAL Function,FN-NUMVAL,FN-NUMVAL,None}@p The @syntax{NUMVAL} function converts a @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) to its corresponding numeric value.
@p The @term{string} must have any of the following formats, where '#' represents a sequence of one or more decimal digits:
@p @center # @ @ -# @ @ +# @ @ #- @ @ #+ @ @ #CR @ @ #DB @ @ #CR
@p @center #.# @ @ -#.# @ @ +#.# @ @ #.#- @ @ #.#+ @ @ #.#CR @ @ #.#DB
@p There must be at least one digit character in the string.
@p Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.
@comment *********************************************************************
@comment ** 6.16.59 NUMVAL-C                                                **
@comment *********************************************************************
@page
@newsubsection{6.16.59,NUMVAL-C}
@diagram{NUMVAL-C Function,FN-NUMVAL-C,FN-NUMVAL-C,None}@p This function converts a @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) representing a currency value to its corresponding numeric value.
@p The optional @term{symbol} character represents the currency symbol (a single-character group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) that may be used as the currency character in @term{string}.  If no @term{symbol} is specified, the value that would be returned by the @intrinsicref{CURRENCY-SYMBOL} will be used.
@p @term{string} may have any of the following formats, where '#' represents a sequence of one or more decimal digits and '$' represents the @term{symbol} character:
@p @center # @ @ -# @ @ +# @ @ #- @ @ #+ @ @ #CR @ @ #DB @ @ #CR
@p @center #.# @ @ -#.# @ @ +#.# @ @ #.#- @ @ #.#+ @ @ #.#CR @ @ #.#DB
@p @center $# @ @ -$# @ @ +$# @ @ $#- @ @ $#+ @ @ $#CR @ @ $#DB @ @ $#CR
@p @center $#.# @ @ -$#.# @ @ +$#.# @ @ $#.#- @ @ $#.#+ @ @ $#.#CR @ @ $#.#DB
@p There must be at least one digit character in the string.
@p Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.
@comment *********************************************************************
@comment ** 6.16.60 NUMVAL-F                                                **
@comment *********************************************************************
@page
@newsubsection{6.16.60,NUMVAL-F}
@diagram{NUMVAL-F Function,FN-NUMVAL-F,FN-NUMVAL-F,None}@p This function converts a @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) representing a floating-point value to its corresponding numeric value.
@p @center # @ @ -# @ @ +# @ @ #E# @ @ -#E# @ @ +#E#
@p @center #E+# @ @ -#E+# @ @ +#E+# @ @ #E-# @ @ -#E-# @ @ +#E-#
@p @center #.# @ @ -#.# @ @ +#.# @ @ #.#E# @ @ -#.#E# @ @ +#.#E#
@p @center #.#E+# @ @ -#.#E+# @ @ +#.#E+# @ @ #.#E-# @ @ -#.#E-# @ @ +#.#E-#
@p There must be at least one digit character both before and after the @syntax{E} in the string.
@p Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.
@comment *********************************************************************
@comment ** 6.16.61 ORD                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.61,ORD}
@diagram{ORD Function,FN-ORD,FN-ORD,None}@p This function returns the ordinal position in the program character set (usually ASCII) corresponding to the 1st character of the @term{char} argument (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal).
@p For example, assuming the program is using the standard ASCII collating sequence, @syntax{ORD('!')} returns 34 because "!" is the 34th ASCII character.  If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.
@p The following code is an alternative approach when you just wish to convert an ASCII character to its numeric equivalent:
@p @example
01  Char-Value.
    05 Numeric-Value        USAGE BINARY-CHAR.
@dots{}
    MOVE "character" TO Char-Value
@end example
@p @syntax{Numeric-Value} now has the numeric value of @syntax{character}.
@comment *********************************************************************
@comment ** 6.16.62 ORD-MAX                                                 **
@comment *********************************************************************
@page
@newsubsection{6.16.62,ORD-MAX}
@diagram{ORD-MAX Function,FN-ORD-MAX,FN-ORD-MAX,None}@p This function returns the ordinal position in the argument list corresponding to the @term{char-n} whose 1st character has the highest position in the program collating sequence (usually ASCII).
@p For example, assuming the program is using the standard ASCII collating sequence, @syntax{ORD-MAX('Z', 'z', '!')} returns 2 because the 2nd character in the argument list (the ASCII character 'z') occurs after 'Z' and '!' in the program collating sequence.  Each @term{char-n} argument may be a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal.
@comment *******************************************************************
@comment ** 6.16.63 ORD-MIN                                                 **
@comment *********************************************************************
@page
@newsubsection{6.16.63,ORD-MIN}
@diagram{ORD-MIN Function,FN-ORD-MIN,FN-ORD-MIN,None}@p This function returns the ordinal position in the argument list corresponding to the @term{char-n} whose 1st character has the lowest position in the program collating sequence (usually ASCII).
@p For example, assuming the program is using the standard ASCII collating sequence, @syntax{ORD-MIN('Z', 'z', '!')} returns 3 because the 3rd character in the argument list (the ASCII character '!') occurs before 'Z' and 'z' in the program collating sequence.  Each @term{char-n} argument may be a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal.
@comment *********************************************************************
@comment ** 6.16.64 PI                                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.64,PI}
@diagram{PI Function,FN-PI,FN-PI,None}@p This function returns the mathematical constant "PI".  The maximum precision with which this value may be returned is 3.1415926535897932384626433832795029.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.65 PRESENT-VALUE                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.65,PRESENT-VALUE}
@diagram{PRESENT-VALUE Function,FN-PRESENT-VALUE,FN-PRESENT-VALUE,None}@p The @syntax{PRESENT-VALUE} function returns a value that approximates the present value of a series of future period-end amounts specified by the various @term{value-n} arguments at a discount rate specified by the @term{rate} argument.
@p All arguments are numeric data items and/or numeric literals.
@iftex
@p The following equation summarizes how present value is calculated, where 'N' is the number of @term{value} arguments:
@tex
$$ presentvalue = \sum_{i=1}^N
\left (value_i
\over (1+rate)^i\right) $$
@end tex
@end iftex
@comment *********************************************************************
@comment ** 6.16.66 RANDOM                                                  **
@comment *********************************************************************
@page
@newsubsection{6.16.66,RANDOM}
@diagram{RANDOM Function,FN-RANDOM,FN-RANDOM,None}@p This function returns a pseudo-random non-integer value in the range 0 to 1 (for example, 0.123456789).
@p The purpose of the optional @term{seed} argument, is to initialize the chain of pseudo-random numbers that will be returned by the function.  Not only will calls to this function using the same @term{seed} value return the same pseudo-random number, but so will all subsequent executions of the function without a @term{seed}.  This is actually a good thing when you are testing your program because you can rely on always receiving the same sequence of "random" numbers if you always start using the same @term{seed}.
@p The @term{seed} may be any form of literal or data item.  If @term{seed} is numeric, its numeric value will serve as the seed value.  If @term{seed} is alphanumeric, a value for it will be determined as if it were used as an argument to @syntaxref{NUMVAL}.
@p Take, for example, the following sample program:
@verbatim
    IDENTIFICATION DIVISION.
    PROGRAM-ID. DEMORANDOM.
    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01  Pseudo-Random-Number        USAGE COMP-1.
    PROCEDURE DIVISION.
    000-Main.
        MOVE FUNCTION RANDOM(1) TO Pseudo-Random-Number
        DISPLAY Pseudo-Random-Number
        PERFORM 4 TIMES
            MOVE FUNCTION RANDOM    TO Pseudo-Random-Number
            DISPLAY Pseudo-Random-Number
        END-PERFORM
        STOP RUN
        .
@end verbatim
@* Every time this program is executed, it will produce the same output, because the same sequence of pseudo-random numbers will be generated:
@verbatim
    0.41
    0.18467
    0.63340002
    0.26499999
    0.19169
@end verbatim
@* It is worth mentioning that if the @i{first} execution of @syntax{RANDOM} in your program lacks a @term{seed} argument, the result will be exactly as if that execution were coded with a @term{seed} argument value of 1.
@p Once your program has been thoroughly tested, you'll want different sequences to be generated each time the program runs.  One possible way to accomplish this is to use a @term{seed} that is likely to be different every time the program is executed, as is likely to be the case if the first @syntax{MOVE} statement in the previous example were replaced by this:
@p @verbatim
    MOVE RANDOM(FUNCTION CURRENT-DATE(1:16))
      TO Pseudo-Random-Number
@end verbatim
@* The first 16 characters returned by the @syntaxref{CURRENT-DATE} function will be a number in the format "YYYYMMDDhhmmssnn", where "YYYYMMDD" is the current calendar date and "hhmmssnn" is the current time of day to the one one-hundredth of a second.  Since two different executions of the program will never get identical @syntax{CURRENT-DATE} values (unless they are executed in extremely close time frames to one another), using those first sixteen characters as the @syntax{RANDOM} seed will guarantee that receiving a duplicate sequence of pseudo-random numbers in two different executions of the program will be HIGHLY unlikely.
@comment *********************************************************************
@comment ** 6.16.67 RANGE                                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.67,RANGE}
@diagram{RANGE Function,FN-RANGE,FN-RANGE,None}@p The @syntax{RANGE} function returns a value that is equal to the value of the maximum @term{number-n} in the argument list minus the value of the minimum @term{number-n} argument.
@p All @term{number-n} arguments are numeric data items and/or numeric literals.
@comment *********************************************************************
@comment ** 6.16.68 REM                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.68,REM}
@diagram{REM Function,FN-REM,FN-REM,None}@p This function returns a numeric value that is the remainder of @term{number} divided by @term{divisor}.  Both arguments must be numeric data items or numeric literals.
@comment *********************************************************************
@comment ** 6.16.69 REVERSE                                                 **
@comment *********************************************************************
@page
@newsubsection{6.16.69,REVERSE}
@diagram{REVERSE Function,FN-REVERSE,FN-REVERSE,None}@p This function returns the byte-by-byte reversed value of the specified @term{string} (a group item, USAGE DISPLAY elementary item or alphanumeric literal).
@comment *********************************************************************
@comment ** 6.16.70 SECONDS-FROM-FORMATTED-TIME                             **
@comment *********************************************************************
@page
@newsubsection{6.16.70,SECONDS-FROM-FORMATTED-TIME}
@diagram{SECONDS-FROM-FORMATTED-TIME Function,FN-SECS-FROM-FMTD-TM,FN-SECS-FROM-FMTD-TM,None}@p This function decodes the string @term{time} --- whose value represents a formatted time --- and returns the total number of seconds that string represents.
@p The @term{time} string must contain hours, minutes and seconds.  The time argument may be specified as a group item, @syntax{USAGE DISPLAY} elementary item or an alphanumeric literal.
@p The @term{format} argument is a string (a group item, @syntax{USAGE DISPLAY} elementary item or an alphanumeric literal) documenting the format of @term{time} using "hh", "mm" and "ss" to denote where the respective time information can be found.  Any other characters found in @term{format} represent character positions that will be ignored.  For example, a format of @syntax{hhmmss} indicates that @term{time} will be treated as a six-digit string value where the first two characters are the number of hours, the next two represent minutes and the last two represent seconds.  A @term{format} of @syntax{hh:mm:ss}, however, describes @term{time} as an eight-character string where characters 3 and 6 will be ignored.
@comment *********************************************************************
@comment ** 6.16.71 SECONDS-PAST-MIDNIGHT                                   **
@comment *********************************************************************
@page
@newsubsection{6.16.71,SECONDS-PAST-MIDNIGHT}
@diagram{SECONDS-PAST-MIDNIGHT Function,FN-SECS-PAST-MIDNIGHT,FN-SECS-PAST-MIDNIGHT,None}@p This function returns the current time of day expressed as the total number of elapsed seconds since midnight.
@p Since this function has no arguments, no parenthesis should be specified.
@comment *********************************************************************
@comment ** 6.16.72 SIGN                                                    **
@comment *********************************************************************
@page
@newsubsection{6.16.72,SIGN}
@diagram{SIGN Function,FN-SIGN,FN-SIGN,None}@p The @syntax{SIGN} function returns a -1 if the value of @term{number} (a numeric literal or numeric data item) is negative, a zero if the value of @term{number} is exactly zero and a 1 if the value of @term{number} if greater than 0.
@comment *********************************************************************
@comment ** 6.16.73 SIN                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.73,SIN}
@diagram{SIN Function,FN-SIN,FN-SIN,None}@p This function determines and returns the trigonometric sine of the specified @term{angle} (a numeric literal or numeric data item).
@p The @term{angle} is assumed to be a value expressed in radians.  If you need to determine the sine of an angle measured in degrees, you first need to convert that angle to radians as follows:
@p @center @syntax{COMPUTE @term{radians} = ( @term{degrees} * FUNCTION PI) / 180}
@comment *********************************************************************
@comment ** 6.16.74 SQRT                                                    **
@comment *********************************************************************
@page
@newsubsection{6.16.74,SQRT}
@diagram{SQRT Function,FN-SQRT,FN-SQRT,None}@p The @syntax{SQRT} function returns a numeric value that approximates the square root of @term{number} (a numeric data item or numeric literal with a non-negative value).
@p The following two statements produce identical results:
@p @example
01  Result           PIC 9(4).9(10).
@dots{}
    MOVE FUNCTION SQRT(15) TO Result
    COMPUTE Result = 15 ^ 0.5
@end example
@comment *********************************************************************
@comment ** 6.16.75 STANDARD-DEVIATION                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.75,STANDARD-DEVIATION}
@diagram{STANDARD-DEVIATION Function,FN-STANDARD-DEVIATION,FN-STANDARD-DEVIATION,None}@p This function returns the statistical standard deviation of the list of @term{number-n} arguments (numeric data items or numeric literals).
@comment *********************************************************************
@comment ** 6.16.76 STORED-CHAR-LENGTH                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.76,STORED-CHAR-LENGTH}
@diagram{STORED-CHAR-LENGTH Function,FN-STORED-CHAR-LENGTH,FN-STORED-CHAR-LENGTH,None}@p Returns the length --- in bytes --- of the specified @syntax{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal), minus the total number of trailing spaces, if any.
@comment *********************************************************************
@comment ** 6.16.77 SUBSTITUTE                                              **
@comment *********************************************************************
@page
@newsubsection{6.16.77,SUBSTITUTE}
@diagram{SUBSTITUTE Function,FN-SUBSTITUTE,FN-SUBSTITUTE,None}@p This function parses the specified @term{string}, replacing all occurrences of the @term{from-n} strings with the corresponding @term{to-n} strings.
@p The @term{from-n} strings must match sequences in @term{string} exactly with regard to value and case.
@p A @term{from-n} string does not have to be the same length as its corresponding @term{to-n} string.
@p All arguments are group items, @term{USAGE DISPLAY} elementary items or alphanumeric literals.
@p A null @term{to-n} string will be treated as a single space.
@comment *********************************************************************
@comment ** 6.16.78 SUBSTITUTE-CASE                                         **
@comment *********************************************************************
@page
@newsubsection{6.16.78,SUBSTITUTE-CASE}
@diagram{SUBSTITUTE-CASE Function,FN-SUBSTITUTE-CASE,FN-SUBSTITUTE-CASE,None}@p The @syntax{SUBSTITUTE-CASE} function operates the same as the @syntaxref{SUBSTITUTE} function, except that @term{from-n} string matching is performed without regard to case.
@p All arguments are group items, @syntax{USAGE DISPLAY} elementary items or alphanumeric literals.
@comment *********************************************************************
@comment ** 6.16.79 SUM                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.79,SUM}
@diagram{SUM Function,FN-SUM,FN-SUM,None}@p The @syntax{SUM} function returns a value that is the sum of the @term{number-n} arguments (these may be numeric data items or numeric literals).
@comment *********************************************************************
@comment ** 6.16.80 TAN                                                     **
@comment *********************************************************************
@page
@newsubsection{6.16.80,TAN}
@diagram{TAN Function,FN-TAN,FN-TAN,None}@p This function determines and returns the trigonometric tangent of the specified @term{angle} (a numeric literal or numeric data item).
@p The @term{angle} is assumed to be a value expressed in radians.  If you need to determine the tangent of an angle measured in degrees, you first need to convert that angle to radians as follows:
@p @center @syntax{COMPUTE @term{radians} = ( @term{degrees} * FUNCTION PI) / 180}
@comment *********************************************************************
@comment ** 6.16.81 TEST-DATE-YYYYMMDD                                      **
@comment *********************************************************************
@page
@newsubsection{6.16.81,TEST-DATE-YYYYMMDD}
@diagram{TEST-DATE-YYYYMMDD Function,FN-TEST-DATE-YYYYMMDD,FN-TEST-DATE-YYYYMMDD,None}@p This function determines if the supplied @term{date} argument (a numeric integer data item or literal) is a valid date.
@p A valid date is one of the form yyyymmdd in the range 1601/01/01 to 9999/12/31, with no more than the expected maximum number of days in the month, accounting for leap year.
@p If the @term{date} is valid, a 0 value is returned.  If it isn't, a value of 1, 2 or 3 is returned signalling the problem lies with the year, month or day, respectively.
@comment *********************************************************************
@comment ** 6.16.82 TEST-DAY-YYYYDDD                                        **
@comment *********************************************************************
@page
@newsubsection{6.16.82,TEST-DAY-YYYYDDD}
@diagram{TEST-DAY-YYYYDDD Function,FN-TEST-DAY-YYYYDDD,FN-TEST-DAY-YYYYDDD,None}@p This function determines if the supplied @term{date} (a numeric integer data item or literal) is a valid date.
@p A valid date is one of the form yyyyddd in the range 1601001 to 9999365.  Leap year is accounted for in determining the maximum number of days in a year.
@p If the date is valid, a 0 value is returned.  If it isn't, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.
@comment *********************************************************************
@comment ** 6.16.83 TEST-NUMVAL                                             **
@comment *********************************************************************
@page
@newsubsection{6.16.83,TEST-NUMVAL}
@diagram{TEST-NUMVAL Function,FN-TEST-NUMVAL,FN-TEST-NUMVAL,None}@p The @syntax{TEST-NUMVAL} function evaluates the specified @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) for being appropriate for use as the @term{string} argument to a @syntaxref{NUMVAL} function, returning to a integer a zero value if it is appropriate otherwise if one or more characters are in error, the position of the first character in error or the length of the field plus one for other cases such as all spaces.
@p Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string "+.".
@comment *********************************************************************
@comment ** 6.16.84 TEST-NUMVAL-C                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.84,TEST-NUMVAL-C}
@diagram{TEST-NUMVAL-C Function,FN-TEST-NUMVAL-C,FN-TEST-NUMVAL-C,None}@p This function evaluates the specified @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) for being appropriate for use as the @term{string} argument to a @syntaxref{NUMVAL-C} function, returning to a integer a zero value if it is appropriate otherwise if one or more characters are in error, the position of the first character in error or the length of the field plus one for other cases such as all spaces.
@p Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string "+.".
@p The optional @term{symbol} argument serves the same function --- and has the same default and possible values --- as the corresponding argument of the @syntax{NUMVAL-C} function.
@comment *********************************************************************
@comment ** 6.16.85 TEST-NUMVAL-F                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.85,TEST-NUMVAL-F}
@diagram{TEST-NUMVAL-F Function,FN-TEST-NUMVAL-F,FN-TEST-NUMVAL-F,None}@p This function evaluates the specified @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal) for being appropriate for use as the @term{string} argument to a @syntaxref{NUMVAL-F} function, returning to a integer a zero value if it is appropriate otherwise if one or more characters are in error, the position of the first character in error ot the length of the field plus one for other cases such as all spaces.
@p Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string "+.".
@comment *********************************************************************
@comment ** 6.16.86 TRIM                                                    **
@comment *********************************************************************
@page
@newsubsection{6.16.86,TRIM}
@diagram{TRIM Function,FN-TRIM,FN-TRIM,None}@p This function removes @syntaxidx{LEADING} or @syntaxidx{TRAILING} spaces from the specified @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal).
@p The second argument is specified as a keyword, not a quoted string or identifier.  If no second argument is specified, @i{both} leading and trailing spaces will be removed.  The case (upper, lower or mixed) of this argument is irrelevant.
@comment *********************************************************************
@comment ** 6.16.87 UPPER-CASE                                              **
@comment *********************************************************************
@page
@newsubsection{6.16.87,UPPER-CASE}
@diagram{UPPER-CASE Function,FN-UPPER-CASE,FN-UPPER-CASE,None}@p This function returns the value of @term{string} (a group item, @syntax{USAGE DISPLAY} elementary item or alphanumeric literal), converted entirely to upper case.
@p What constitutes a "letter" (or upper/lower case too, for that manner) may be influenced through the use of a @syntaxrefalt{CHARACTER CLASSIFICATION,OBJECT-COMPUTER}.
@comment *********************************************************************
@comment ** 6.16.88 VARIANCE                                                **
@comment *********************************************************************
@page
@newsubsection{6.16.88,VARIANCE}
@diagram{VARIANCE Function,FN-VARIANCE,FN-VARIANCE,None}@p This function returns the statistical variance of the specified list of @term{number-n} arguments (these may be numeric data items or numeric literals).
@comment *********************************************************************
@comment ** 6.16.89 WHEN-COMPILED                                           **
@comment *********************************************************************
@page
@newsubsection{6.16.89,WHEN-COMPILED}
@diagram{WHEN-COMPILED Function,FN-WHEN-COMPILED,FN-WHEN-COMPILED,None}@p The @syntax{WHEN-COMPILED} intrinsic function, not to be confused with the @syntaxrefalt{WHEN-COMPILED,Special Registers} special register, returns the date and time the program was compiled, in ASCII.
@p Since this function has no arguments, no parenthesis should be specified.
@p Unlike the @syntax{WHEN-COMPILED} special register, which has an ASCII value of the compilation date/time in the format "mm/dd/yyhh.mm.ss", the @syntax{WHEN-COMPILED} intrinsic function returns the compilation date/time as an ASCII string in the format "yyyymmddhhmmssnnooooo", where "yyyymmdd" is the date, "hhmmss" is the time, "nn" is the hundredths of a second component of the compilation time, if available (or "00" if it isn't) and "ooooo" is the time zone offset from GMT.
@p If the @switch{-fintrinsics=WHEN-COMPILED} or @switch{-fintrinsics=ALL} is specified to the compiler or the @syntaxref{REPOSITORY} paragraph specifies either @syntax{FUNCTION WHEN-COMPILED INTRINSIC} or @syntax{FUNCTION ALL INTRINSIC}, then references to @syntax{WHEN-COMPILED} (without a leading @syntax{FUNCTION} keyword will always reference this intrinsic function and there will be no way to access the @syntax{WHEN-COMPILED} special register.
@comment *********************************************************************
@comment ** 6.16.90 YEAR-TO-YYYY                                            **
@comment *********************************************************************
@page
@newsubsection{6.16.90,YEAR-TO-YYYY}
@diagram{YEAR-TO-YYYY Function,FN-YEAR-TO-YYYY,FN-YEAR-TO-YYYY,None}@p @syntax{YEAR-TO-YYYY} converts @term{yy} --- a two-digit year --- to a four-digit format (yyyy).
@p The optional @term{yy-cutoff} argument is the year cutoff used to delineate centuries; if @term{yy} meets or exceeds this cutoff value, the result will be 19yy; if @term{yy} is less than the cutoff, the result will be 20yy.  The default cutoff value if no second argument is given will be 50.
@p Both arguments must be numeric data items or numeric literals.
@comment *********************************************************************
@comment ** 6.17 GnuCOBOL Statements                                       **
@comment *********************************************************************
@page
@newsection{6.17,GnuCOBOL Statements}
@menu
* 6.17.1:  ACCEPT
@detailmenu
*   6.17.1.1: ACCEPT FROM CONSOLE
*   6.17.1.2: ACCEPT FROM COMMAND-LINE
*   6.17.1.3: ACCEPT FROM ENVIRONMENT
*   6.17.1.4: ACCEPT screen-data-item
*   6.17.1.5: ACCEPT FROM DATE/TIME
*   6.17.1.6: ACCEPT FROM Screen-Info
*   6.17.1.7: ACCEPT FROM Runtime-Info
*   6.17.1.8: ACCEPT OMITTED
*   6.17.1.9: ACCEPT FROM EXCEPTION-STATUS
@end detailmenu
* 6.17.2:  ADD
@detailmenu
*   6.17.2.1: ADD TO
*   6.17.2.2: ADD GIVING
*   6.17.2.3: ADD CORRESPONDING
@end detailmenu
* 6.17.3:  ALLOCATE
* 6.17.4:  ALTER
* 6.17.5:  CALL
* 6.17.6:  CANCEL
* 6.17.7:  CLOSE
* 6.17.8:  COMMIT
* 6.17.9:  COMPUTE
* 6.17.10: CONTINUE
* 6.17.11: DELETE
* 6.17.12: DISPLAY
@detailmenu
*   6.17.12.1: DISPLAY UPON device
*   6.17.12.2: DISPLAY UPON COMMAND-LINE
*   6.17.12.3: DISPLAY UPON ENVIRONMENT-NAME
*   6.17.12.4: DISPLAY screen-data-item
@end detailmenu
* 6.17.13: DIVIDE
@detailmenu
*   6.17.13.1: DIVIDE INTO
*   6.17.13.2: DIVIDE INTO GIVING
*   6.17.13.3: DIVIDE BY GIVING
@end detailmenu
* 6.17.14: ENTRY
* 6.17.15: EVALUATE
* 6.17.16: EXIT
* 6.17.17: FREE
* 6.17.18: GENERATE
* 6.17.19: GOBACK
* 6.17.20: GO TO
@detailmenu
*   6.17.20.1: Simple GO TO
*   6.17.20.2: GO TO DEPENDING ON
@end detailmenu
* 6.17.21: IF
* 6.17.22: INITIALIZE
* 6.17.23: INITIATE
* 6.17.24: INSPECT
* 6.17.25: MERGE
* 6.17.26: MOVE
@detailmenu
*   6.17.26.1: Simple MOVE
*   6.17.26.2: MOVE CORRESPONDING
@end detailmenu
* 6.17.27: MULTIPLY
@detailmenu
*   6.17.27.1: MULTIPLY BY
*   6.17.27.2: MULTIPLY GIVING
@end detailmenu
* 6.17.28: OPEN
* 6.17.29: PERFORM
@detailmenu
*   6.17.29.1: Procedural PERFORM
*   6.17.29.2: Inline PERFORM
@end detailmenu
* 6.17.30: READ
@detailmenu
*   6.17.30.1: Sequential READ
*   6.17.30.2: Random READ
@end detailmenu
* 6.17.31: READY TRACE
* 6.17.32: RELEASE
* 6.17.33: RESET TRACE
* 6.17.34: RETURN
* 6.17.35: REWRITE
* 6.17.36: ROLLBACK
* 6.17.37: SEARCH
* 6.17.38: SEARCH ALL
* 6.17.39: SET
@detailmenu
*   6.17.39.1: SET ENVIRONMENT
*   6.17.39.2: SET Program-Pointer
*   6.17.39.3: SET ADDRESS
*   6.17.39.4: SET Index
*   6.17.39.5: SET UP/DOWN
*   6.17.39.6: SET Condition Name
*   6.17.39.7: SET Switch
*   6.17.39.8: SET ATTRIBUTE
@end detailmenu
* 6.17.40: SORT
@detailmenu
*   6.17.40.1: File-Based SORT
*   6.17.40.2: Table SORT
@end detailmenu
* 6.17.41: START
* 6.17.42: STOP
* 6.17.43: STRING
* 6.17.44: SUBTRACT
@detailmenu
*   6.17.44.1: SUBTRACT FROM
*   6.17.44.2: SUBTRACT GIVING
*   6.17.44.3: SUBTRACT CORRESPONDING
@end detailmenu
* 6.17.45: SUPPRESS
* 6.17.46: TERMINATE
* 6.17.47: TRANSFORM
* 6.17.48: UNLOCK
* 6.17.49: UNSTRING
* 6.17.50: WRITE
@end menu
@comment *********************************************************************
@comment ** 6.17.1 ACCEPT                                                   **
@comment *********************************************************************
@newsubsection{6.17.1,ACCEPT}
@menu
* 6.17.1.1: ACCEPT FROM CONSOLE
* 6.17.1.2: ACCEPT FROM COMMAND-LINE
* 6.17.1.3: ACCEPT FROM ENVIRONMENT
* 6.17.1.4: ACCEPT screen-data-item
* 6.17.1.5: ACCEPT FROM DATE/TIME
* 6.17.1.6: ACCEPT FROM Screen-Info
* 6.17.1.7: ACCEPT FROM Runtime-Info
* 6.17.1.8: ACCEPT OMITTED
* 6.17.1.9: ACCEPT FROM EXCEPTION-STATUS
@end menu
@comment *********************************************************************
@comment ** 6.17.1.1 ACCEPT FROM CONSOLE                                    **
@comment *********************************************************************
@newunit{6.17.1.1,ACCEPT FROM CONSOLE}
@diagram{ACCEPT FROM CONSOLE,PD-ACCEPT-1,PD-ACCEPT-1,None}@p This format of the @statement{ACCEPT} is used to read a value from the console window or the standard input device and store it into a data item (@term{identifier-1}).
@enumerate
@comment Syntactical Specifications:
@p @item If no @syntax{FROM} clause is specified, @syntax{FROM CONSOLE} is assumed.
@comment Semantic Specifications:
@p @item The specified @term{mnemonic-name-1} must either be one of the built-in device names @syntax{CONSOLE}, @syntax{STDIN}, @syntax{SYSIN} or @syntax{SYSIPT}, or a user-defined (@pxref{SPECIAL-NAMES}) mnemonic name @i{attached} to one of those four device names.
@p @item Input will be read either from the console window (@syntax{CONSOLE}) or from the system-standard input (pipe 0 = @syntax{STDIN}, @syntax{SYSIN} or @syntax{SYSIPT}) and will be saved in @term{identifier-1}.
@p @item If @term{identifier-1} is a numeric data item, the character value read from the console or standard-input device will be parsed according to the rules for input to the @intrinsicref{NUMVAL}, except that none of the trailing sign formats are honoured.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.2 ACCEPT FROM COMMAND-LINE                               **
@comment *********************************************************************
@page
@newunit{6.17.1.2,ACCEPT FROM COMMAND-LINE}
@diagram{ACCEPT FROM COMMAND-LINE,PD-ACCEPT-2,PD-ACCEPT-2,None}@p This format of the @statement{ACCEPT} is used to retrieve information from the programs command-line.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item When you accept from the @syntaxidx{COMMAND-LINE} option, you will retrieve the entire set of arguments entered on the command line that executed the program, exactly as they were specified.  Parsing that returned data into its meaningful information will be your responsibility.
@p @item By accepting from @syntaxidx{ARGUMENT-NUMBER}, you will be asking the GnuCOBOL run-time system to parse the arguments from the command-line and return the number of arguments found.  Parsing will be conducted according to the following rules:
@enumerate A
@p @item Arguments will be separated by treating spaces and/or tab characters as the delimiters between arguments.  The number of such delimiters separating two non-blank argument values is irrelevant.
@p @item Strings enclosed in double-quote characters (") will be treated as a single argument, regardless of how many spaces or tab characters (if any) might be embedded within those quotation characters.
@p @item On Windows systems, single-quote, or apostrophe characters (') will be treated just like any other data character and will NOT delineate argument strings.
@end enumerate
@item By accepting from @syntaxidx{ARGUMENT-VALUE}, you will be asking the GnuCOBOL run-time system to parse the arguments from the command-line and return the "current" argument.  You specify which argument number is "current" via the @syntax{ARGUMENT-NUMBER} option on the @statementrefalt{DISPLAY,DISPLAY UPON COMMAND-LINE}.  Parsing of arguments will be conducted according to the rules set forth above.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to retrieve an @syntax{ARGUMENT-VALUE}.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.3 ACCEPT FROM ENVIRONMENT                                **
@comment *********************************************************************
@page
@newunit{6.17.1.3,ACCEPT FROM ENVIRONMENT}
@diagram{ACCEPT FROM ENVIRONMENT,PD-ACCEPT-3,PD-ACCEPT-3,None}@p This format of the @statement{ACCEPT} is used to retrieve environment variable values.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item By accepting from @syntaxidx{ENVIRONMENT-VALUE}, you will be asking the GnuCOBOL run-time system to retrieve the value of the environment variable whose name is currently in the @syntaxidx{ENVIRONMENT-NAME} register.  A value may be placed into the @syntax{ENVIRONMENT-NAME} register using the @syntax{ENVIRONMENT-NAME} option of the @statementrefalt{DISPLAY,DISPLAY UPON ENVIRONMENT-NAME}.
@p @item A simpler approach to retrieving an environment variables value is to use the @syntaxidx{ENVIRONMENT} option, where you specify the environment variable whose value is to be retrieved right on the @syntax{ACCEPT} statement itself.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to an attempt to retrieve the value of a non-existent environment variable or the successful retrieval of an environment variable's value, respectively.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.4 ACCEPT screen-data-item                                **
@comment *********************************************************************
@page
@newunit{6.17.1.4,ACCEPT screen-data-item}
@diagram{ACCEPT screen-data-item,PD-ACCEPT-4,PD-ACCEPT-4,PD-ACCEPT-4}@p This format of the @statement{ACCEPT} is used to retrieve data from a formatted console window screen.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{IS}, @syntax{NUMBER} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{COLUMN}, @syntax{COL} and @syntax{POSITION} are interchangeable.
@p @item The reserved words @syntax{TIMEOUT} and @syntax{TIME-OUT} are interchangeable.
@comment Semantic Specifications:
@p @item If @term{identifier-1} is defined in the @syntaxref{SCREEN SECTION}, any @syntax{AT}, @term{Attribute-Specification}, @syntax{LOWER}, @syntax{UPPER} or @syntax{SCROLL} clauses will be ignored.  In these cases, an implied @syntaxrefalt{DISPLAY,DISPLAY screen-data-item} of @term{identifier-1} will occur before input is accepted.  Coding an explicit @syntax{DISPLAY identifier-1} before an @syntax{ACCEPT identifier-1} is redundant and will incur the performance penalty of painting the screen contents twice.
@p @item The various @syntax{AT} clauses provide a means of positioning the cursor to a specific spot on the screen before the screen is read.  One or the other (but not both) may be used, as follows:
@enumerate A
@p @item The @syntax{LINE} and @syntax{COLUMN} clauses provide one mechanism for specifying the line and column position to which the cursor will be positioned before allowing the user to enter data.  In the absence of one or the other, a value of 1 will be assumed for the one that is missing.  The author's personal preference, however, is to explicitly code both.
@p @item The @term{literal-3} or @term{identifier-4} value, if specified, must be a four- or six-digit value with the 1st half of the number indicating the line where the cursor should be positioned and the second half indicating the column.  You may code only one of each clause on any @syntax{ACCEPT}.
@end enumerate
@item @syntax{WITH} options (including the various individual @term{Attribute-Specifications}) should be coded only once.
@p @item The following @term{Attribute-Specification} clauses are allowed on the @syntax{ACCEPT} statement --- these are the same as those allowed for @syntax{SCREEN SECTION} data items.  A particular @term{Attribute-Specification} may be used only once in any @syntax{ACCEPT}:
@itemize @bullet
@p @item @syntaxref{AUTO}, @syntaxref{AUTO-SKIP}, @syntaxref{AUTOTERMINATE}, @syntax{TAB}
@p @item @syntaxref{BACKGROUND-COLOR}
@p @item @syntaxref{BEEP}, @syntaxref{BELL}
@p @item @syntaxref{BLINK}
@p @item @syntaxref{FOREGROUND-COLOR}
@p @item @syntaxref{FULL}, @syntaxref{LENGTH-CHECK}
@p @item @syntaxref{HIGHLIGHT}
@p @item @syntaxref{LEFTLINE}
@p @item @syntaxref{LOWLIGHT}
@p @item @syntaxref{OVERLINE}
@p @item @syntaxref{PROMPT}
@p @item @syntaxref{PROTECTED}
@p @item @syntaxref{REQUIRED}, @syntaxref{EMPTY-CHECK}
@p @item @syntaxref{REVERSE-VIDEO}
@p @item @syntaxref{SECURE}, @syntaxref{NO-ECHO}
@p @item @syntaxref{UNDERLINE}
@end itemize
@item The @syntaxidx{SCROLL} option will cause the entire contents of the screen to be scrolled @syntax{UP} or @syntax{DOWN} by the specified number of lines before any value is displayed on the screen.  It is syntactically allowable to specify a @syntax{SCROLL UP} clause as well as a @syntax{SCROLL DOWN} clause.  In such an instance, it is the last one specified that will be honoured.  If no @syntax{LINES} specification is made, @syntax{1 LINE} will be assumed.
@p @item The @syntaxidx{TIMEOUT} option will cause the @syntax{ACCEPT} to wait no more than the specified number of seconds for input.  The wait count may be specified as a positive integer or a numeric data item with a positive value.
@p @item This format of the @syntax{ACCEPT} statement will be terminated by any of the following events:
@enumerate A
@p @item When the 'Enter' key is pressed.
@p @item Expiration of the @syntax{TIMEOUT} timer --- this will be treated as if the Enter key had been pressed with no data being entered.
@p @item When a function key (Fn) is pressed.
@p @item The pressing of the PgUp or PgDn keys, if the @envvarruntimeref{COB_SCREEN_EXCEPTIONS} is set to any non-blank value.
@p @item The pressing of the Esc key if @i{both} the @envvarruntime{COB_SCREEN_ESC} as well as @envvarruntime{COB_SCREEN_EXCEPTIONS} are set to any non-blank value.
@p @item The pressing of the Up-arrow, Down-Arrow or PrtSc (Print Screen) keys.  These keys are not detectable on Windows systems, however.
@end enumerate
@item The following apply when @term{identifier-1} is defined in the @syntax{SCREEN SECTION}:
@enumerate A
@p @item Alphanumeric data entered into @term{identifier-1} or any screen data item subordinate to it @i{must} be consistent with the @syntaxref{PICTURE} clause of that item.  This will be enforced at runtime by the @syntax{ACCEPT} statement.
@p @item If @term{identifier-1} or any screen data item subordinate to it are defined as numeric, entered data must be acceptable as @intrinsicref{NUMVAL} input (no decimal points are allowed, however).  The value stored into the screen data item will be as if the input were passed to that function.
@p @item If @term{identifier-1} or any screen data item subordinate to it are defined as numeric edited, entered data must be acceptable as @intrinsicref{NUMVAL-C} input (again, no decimal points are allowed).  The value stored into the screen data item will be as if the input were passed to that function.
@end enumerate
@item The following apply when @term{identifier-1} is @i{not} defined in the @syntax{SCREEN SECTION}:
@enumerate A
@p @item Alphanumeric data entered into @term{identifier-1} @i{should} be consistent with the @syntaxref{PICTURE} clause of that item, although that will not be enforced by the @syntax{ACCEPT} statement.  You may use @syntaxref{Class Conditions} after the data is accepted to enforce the data type.
@p @item If @term{identifier-1} is defined as numeric, entered data must be acceptable as @intrinsicref{NUMVAL} input (no decimal points are allowed, however).  The value stored into @term{identifier-1} will be as if the input were passed to that function.
@p @item If @term{identifier-1} is defined as numeric edited, entered data must be acceptable as @intrinsicref{NUMVAL-C} input (again, no decimal points are allowed).  The value stored into @term{identifier-1} will be as if the input were passed to that function.
@end enumerate
@item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of the screen I/O attempt.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@p After this format of the @syntax{ACCEPT} statement is executed, the program's @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} identifier will be populated with one of the following:
@p @anchoridx{CRT STATUS Codes}
@multitable @columnfractions .15 .85
@headitem Code @tab Meaning
@item 0000 @tab ENTER key pressed
@item 1001--1064 @tab F1--F64, respectively, were pressed
@item 2001 @tab PgUp was pressed
@item 2002 @tab PgDn,was pressed
@item 2003 @tab Up Arrow was pressed
@item 2004 @tab Down-Arrow was pressed
@item 2006 @tab PrtSc (Print Screen) was pressed
@item 2005 @tab Esc was pressed
@item 8000 @tab No data is available on screen ACCEPT
@item 9000 @tab Fatal screen I/O error
@end multitable
@item The actual key pressed to generate a function key (Fn) will depend on the type of terminal device you're using (PC, Macintosh, VT100, etc.) and what type of enhanced display driver was configured with the version of GnuCOBOL you're using.  For example, on a GnuCOBOL build for a Windows PC using MinGW and PDCurses, F1-F12 are the actual F-keys on the PC keyboard, F13-F24 are entered by shifting the F-keys, F25-F36 are entered by holding Ctrl while pressing an F-key and F37-F48 are entered by holding Alt while pressing an F-key.  On the other hand, a GnuCOBOL implementation built for Windows using Cygwin and NCurses treats the PCs F1-F12 keys as the actual F1-F12, while shifted F-keys will enter F11-F20.  With Cygwin/NCurses, Ctrl- and Alt-modified F-keys aren't recognized.  Neither are Shift-F11 or Shift-F12.
@p @item Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings.  Windows Cygwin/NCurses builds recognize numeric keypad inputs properly.  Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.
@item The optional @syntax{EXCEPTION-STATUS} clause may be used to detect exceptions from a prior arthmetic verb such as COMPUTE to recover any errors produced. These are recovered using the function @syntax{EXCEPTION-STATUS}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.5 ACCEPT FROM DATE/TIME                                  **
@comment *********************************************************************
@page
@newunit{6.17.1.5,ACCEPT FROM DATE/TIME}
@diagram{ACCEPT FROM DATE/TIME,PD-ACCEPT-5,PD-ACCEPT-5,None}@p This format of the @statement{ACCEPT} is used to retrieve the current system date, time or current day of the week and store it into a data item.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The data retrieved from the system and the format in which it is structured will vary, as follows:
@multitable @columnfractions .3 .5 .2
@p @headitem Syntax @tab Data Retrieved @tab Format
@item @syntax{DATE} @tab Current date in Gregorian form @tab yymmdd
@item @syntax{DATE YYYYMMDD} @tab Current date in Gregorian form @tab yyyymmdd
@item @syntax{DAY} @tab Current date in Julian form @tab yyddd
@item @syntax{DAY YYYYDDD} @tab Current date in Julian form @tab yyyyddd
@item @syntax{TIME} @tab Time, including hundredths of a second (nn) @tab hhmmssnn
@end multitable
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.6 ACCEPT FROM Screen-Info                                **
@comment *********************************************************************
@page
@newunit{6.17.1.6,ACCEPT FROM Screen-Info}
@diagram{ACCEPT FROM Screen-Info,PD-ACCEPT-6,PD-ACCEPT-6,None}@p This format of the @statement{ACCEPT} is used to retrieve information about the console window or about the user's interactions with it.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{LINES} and @syntax{LINE-NUMBER} are interchangeable.
@p @item The reserved words @syntax{COLS} and @syntax{COLUMNS} are interchangeable.
@comment Semantic Specifications:
@p @item The following points pertain to the use of the @syntaxidx{LINES} and @syntaxidx{COLUMNS} options:
@enumerate A
@p @item The @syntaxidx{LINES} and @syntaxidx{COLUMNS} options will retrieve the respective components of the size of the console display.
@p @item When the console is running in a windowed environment, this will be the sizing of the window in which the program is executing, in terms of horizontal (@syntax{COLUMNS}) or vertical (@syntax{LINES}) character counts --- not pixels.
@p @item When the system is not running a windowing environment, the physical console screen attributes will be returned.
@p @item Values of 0 will be returned if GnuCOBOL was not generated to include screen I/O.
@p @item See the documentation on the @subpgmref{CBL_GET_SCR_SIZE} for another way to retrieve this information.
@end enumerate
@item The @syntaxidx{ESCAPE KEY} option may be used after the @statementref{ACCEPT FROM Screen-Info} has executed.  The result returned will be the four-digit @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} identifier value.  @xref{CRT STATUS Codes}, for the specific code values.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.7 ACCEPT FROM Runtime-Info                               **
@comment *********************************************************************
@page
@newunit{6.17.1.7,ACCEPT FROM Runtime-Info}
@diagram{ACCEPT FROM Runtime-Info,PD-ACCEPT-7,PD-ACCEPT-7,None}@p This format of the @statement{ACCEPT} is used to retrieve run-time information such as the most-recent error exception code and the current user's user name.
@enumerate
@comment Syntactical Specifications:
@p @item The following points pertain to the use of the @syntaxidx{EXCEPTION STATUS} option:
@enumerate A
@p @item @term{identifier-1} must be defined as a @syntax{PIC X(4)} item.
@p @item @xref{Error Exception Codes}, for a complete list of the exception codes and their meanings.
@p @item An alternative to the use of @syntax{ACCEPT FROM Runtime-Info} is to use the @intrinsicref{EXCEPTION-STATUS}.
@end enumerate
@item The following points pertain to the use of the @syntaxidx{USER NAME} option:
@enumerate A
@p @item The returned result is the userid that was used to login to the system with, and not any actual first and/or last name of the user in question (unless, of course, that is the information used as a logon id).
@p @item @term{identifier-1} should be defined large enough to receive the longest user-name on the system.
@p @item If insufficient space is allocated, the returned value will be truncated.
@p @item If excess space is allocated, the returned value will be padded with spaces (to the right).
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.8 ACCEPT OMITTED                                         **
@comment *********************************************************************
@page
@newunit{6.17.1.8,ACCEPT OMITTED}
@diagram{ACCEPT OMITTED,PD-ACCEPT-8,PD-ACCEPT-8,None}@p This format of the @statement{ACCEPT} will wait for a keyboard event that terminates input; function keys, or Enter/Return, among others. CRT STATUS (COB-CRT-STATUS @syntaxrefalt{CRT STATUS,SPECIAL-NAMES} if not explicitly defined) is set with the keycode, listed in copy/screenio.cpy. It also handles a few other keycode terminations not normally used to complete an extended accept.
@enumerate
@comment Syntactical Specifications:
@p @item The following are examples of keycodes that can be used:
@verbatim
COB-SCR-INSERT
COB-SCR-DELETE
COB-SCR-BACKSPACE
COB-SCR-KEY-HOME
COB-SCR-KEY-END
@end verbatim
@p @item You can used extended attributes, useful for setting timeouts or positioning.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.1.9 ACCEPT FROM EXCEPTION-STATUS                           **
@comment *********************************************************************
@page
@newunit{6.17.1.9,ACCEPT FROM EXCEPTION-STATUS}
@diagram{ACCEPT FROM EXCEPTION-STATUS,PD-ACCEPT-9,PD-ACCEPT-9,None}@p This format of the @statement{ACCEPT} will receive the status for any exceptions resulting from a previous valid verb.
@enumerate
@comment Syntactical Specifications:
@p @item The following is an example of usage:
@verbatim
 In WS:
 01  exception-status  pic 9(4).
..
 In PD:

 ACCEPT unexpected-rounding  FROM EXCEPTION-STATUS
 IF unexpected-rounding NOT EQUAL "0000" THEN
    DISPLAY "Unexpected rounding. Code " unexpected-rounding
             UPON SYSERR
 END-IF
@end verbatim
@end enumerate
@comment *********************************************************************
@comment ** 6.17.2 ADD                                                      **
@comment *********************************************************************
@page
@newsubsection{6.17.2,ADD}
@menu
* 6.17.2.1: ADD TO
* 6.17.2.2: ADD GIVING
* 6.17.2.3: ADD CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 6.17.2.1 ADD TO                                                 **
@comment *********************************************************************
@newunit{6.17.2.1,ADD TO}
@diagram{ADD TO,PD-ADD-1,PD-ADD-1,None}@p This format of the @statement{ADD} generates an intermediate arithmetic sum of the values of all @term{identifier-1} and @term{literal-1}) items. The value of each @term{identifier-2} will be replaced, in turn, by the sum of that @term{identifier-2}s value and the intermediate sum.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while @term{literal-1} must be a numeric literal.
@p @item An @term{identifier-1} data item may also be coded as an @term{identifier-2} --- note, however, that the value of such a data item will therefore be included @i{twice} in the result.
@comment Semantic Specifications:
@p @item The contents of each @term{identifier-1} will remain unchanged by this statement.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.2.2 ADD GIVING                                             **
@comment *********************************************************************
@page
@newunit{6.17.2.2,ADD GIVING}
@diagram{ADD GIVING,PD-ADD-2,PD-ADD-2,None}@p This format of the @syntax{ADD} statement generates the arithmetic sum of the values of all @term{identifier-1}, @term{literal-1}) and @term{identifier-2} (if any) items and then saves that sum to each @term{identifier-3}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while @term{literal-1} must be a numeric literal; @term{identifier-3} may be either a numeric or numeric edited data item.
@p @item An @term{identifier-1} or @term{identifier-2} data item may be used as an @term{identifier-3}, if desired.
@comment Semantic Specifications:
@p @item The contents of each @term{identifier-1} and @term{identifier-2} will remain unchanged by this statement, unless they happen to also be specified as an @term{identifier-3}.
@p @item The current value in each @term{identifier-3} at the start of the statement's execution is irrelevant, since the contents of each @term{identifier-3} will simply be replaced with the computed sum.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-3} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.2.3 ADD CORRESPONDING                                      **
@comment *********************************************************************
@page
@newunit{6.17.2.3,ADD CORRESPONDING}
@diagram{ADD CORRESPONDING,PD-ADD-3,PD-ADD-3,None}@p This format of the @statement{ADD} generates code equivalent to individual @syntaxref{ADD TO} statements for corresponding matches of data items found subordinate to the two identifiers.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for information on how corresponding matches will be found between @term{identifier-1} and @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-3} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.3 ALLOCATE                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.3,ALLOCATE}
@diagram{ALLOCATE,PD-ALLOCATE,PD-ALLOCATE,None}@p The @syntax{ALLOCATE} statement is used to dynamically allocate memory at run-time.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{INITIALIZED} and @syntax{INITIALISED} are interchangeable.
@p @item Both @term{identifier-1} and @syntax{RETURNING @term{identifier-2}} may not be specified in the same statement.
@comment Semantic Specifications:
@p @item If used, @term{expression-1} must be an arithmetic expression with a non-zero positive integer value.
@p @item If used, @term{identifier-1} should be an 01-level item defined in working-storage or local-storage with the @syntaxref{BASED} attribute.  It may be an 01 item defined in the linkage section without the @syntax{BASED} attribute, but using such a data item is not recommended.
@p @item If used, @term{identifier-2} should be a @syntaxrefalt{POINTER,USAGE} data item.
@p @item The optional @syntaxidx{RETURNING} clause will return the address of the allocated memory block into the specified @syntax{USAGE POINTER} @term{identifier-2} data item.  When this option is used, knowledge of the originally-requested size of the allocated memory block will be retained by the program in case a @syntaxref{FREE} statement is ever issued against @term{identifier-2}.
@p @item When the @term{identifier-1} option is used in conjunction with @syntaxidx{INITIALIZED} (or it's internationalized alternative @syntax{INITIALISED}), the allocated memory block will be initialized as if an @syntaxrefalt{INITIALIZE @term{identifier-1} WITH FILLER ALL TO VALUE THEN TO DEFAULT,INITIALIZE} were executed.
@p @item When the @syntax{@term{expression-1} CHARACTERS} option is used, @syntax{INITIALIZED} will initialize the allocated memory block to binary zeros.  If @syntax{INITIALIZED} is not used, the initial contents of allocated memory will be left to whatever rules of memory allocation are in effect for the operating system the program is running under.
@p @item There are two basic ways in which this statement is used.  The simplest is:
@p @example
ALLOCATE My-01-Item
@end example
@* With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the @syntax{BASED} attribute) will be allocated.  The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.
@p A second (and equivalent) approach is:
@p @example
ALLOCATE LENGTH OF My-01-Item CHARACTERS RETURNING The-Pointer
SET ADDRESS OF My-01-Item TO The-Pointer
@end example
@item Referencing a @syntax{BASED} data item either before its storage has been allocated or after its storage has been released (via the @statement{FREE}) will lead to "unpredictable results".  That's how reference manuals and standards specifications talk about this situation.  In the author's experience, the results are all too predictable --- the program aborts from an attempt to reference an unallocated area of memory.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.4 ALTER                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.4,ALTER}
@diagram{ALTER,PD-ALTER,PD-ALTER,None}@p The @statement{ALTER} was used in the early years of the COBOL language to edit the object code of a program @strong{at execution time}, changing a @syntaxrefalt{GO TO,Simple GO TO} statement to branch to a spot in the program different than where the @syntax{GO TO} statement was originally compiled for.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{PROCEED} and @syntax{TO} (the one @i{after} @syntax{PROCEED}) are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item @term{procedure-name-1} must contain only a single statement, and that statement must be a simple @syntax{GO TO}.
@comment Semantic Specifications:
@p @item The effect of this statement will be as if the generated machine-language code for the @syntax{GO TO} statement in @term{procedure-name-1} is changed so that the @syntax{GO TO} statement now transfers control to @term{procedure-name-2}, rather than to whatever procedure name was specified in the program source code.
@p @item Support for the @syntax{ALTER} verb has been added to GnuCOBOL for the purpose of enabling GnuCOBOL to pass those National Institute of Standards and Technology (NIST) tests for the COBOL programming language that require support for @syntax{ALTER}.
@p @item Because of the catastrophic effect this statement has on program readability and therefore the programmer's ability to debug problems with program logic, the use of @syntax{ALTER} in new programs is @strong{STRONGLY} discouraged.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.5 CALL                                                     **
@comment *********************************************************************
@page
@newsubsection{6.17.5,CALL}
@diagram{CALL,PD-CALL,PD-CALL,None}
@diagram{CALL Argument,PD-CALL-Arg,PD-CALL-Arg,None}@p The @statement{CALL} is used to transfer control to a subroutine.  @xref{Sub-Programming}, for the specifics of using subprograms with GnuCOBOL programs.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{EXCEPTION} and @syntax{OVERFLOW} are interchangeable.
@p @item The reserved words @syntax{GIVING} and @syntax{RETURNING} are interchangeable.
@comment Semantic Specifications:
@p @item The expectation is that the subroutine will eventually return control back to the calling program, at which point the CALLing program will resume execution starting with the statement immediately following the @syntax{CALL}.  Subprograms are not required to return to their callers, however, and are free to halt program execution if they wish.
@p @item The @term{mnemonic-name-1} / @syntaxidx{STATIC} / @syntaxidx{STDCALL} option, if used, affects the linkage conventions that will be used to the subroutine being called, as follows:
@enumerate A
@p @item The @syntax{STATIC} option will cause the linkage to the subroutine to be performed in such a way as to require the subroutine to be statically-linked with the calling program.  Note that this enables static-linking to be used on a subroutine-by-subroutine selective basis.
@p @item The @syntax{STDCALL} option allows system-standard calling conventions (as opposed to GnuCOBOL calling conventions) to be used when calling a subroutine.  The definition of what constitutes "system standard" may vary from operating system to operating system.  Use of this requires special knowledge about the linkage requirements of subroutines you are intending to @syntax{CALL}.  Subroutines written in GnuCOBOL do not need this option.
@p @item The @term{mnemonic-name-1} option allows a custom-defined calling convention to be used.  Such mnemonic names are defined using the @syntaxrefalt{CALL-CONVENTION,SPECIAL-NAMES} clause.  That clause associates a decimal integer value with @term{mnemonic-name-1} such that the individual bits set on or off in the binary equivalent of the integer affect linkage to the subroutine as described in the following chart.  Those rows of the chart marked with a "No" in the "Supported" column represent bit positions (switch settings) in the integer value that are currently accepted (to provide compatibility to other COBOL implementations) if coded, but are otherwise unsupported.
@p Note that bit 0 is the right-most bit in the binary value.
@p @multitable @columnfractions .05 .15 .4 .4
@headitem Bit @tab Supported @tab Meaning if 0 @tab Meaning if 1
@item 0 @tab No @tab Arguments will be passed in right-to-left sequence @tab Arguments will be passed in left-to-right sequence.
@item
@item 1 @tab No @tab The calling program will flush processed arguments from the argument stack.@tab The called program (subroutine) will flush processed arguments from the argument stack.
@item
@item 2 @tab Yes @tab The @registerrefalt{RETURN-CODE,Special Registers} will be updated in addition to any @syntax{RETURNING} or @syntax{GIVING} data item. @tab The @registertext{RETURN-CODE} will not be updated (but any @syntax{RETURNING} or @syntax{GIVING} data item still will).
@item
@item 3 @tab Yes @tab If CALL "literal" is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.  @tab If CALL "literal" is used, the subroutine can only be located and linked with the calling program at compilation time.
@item
@item 4 @tab No @tab OS/2 "OPTLINK" conventions will not be used to CALL the subprogram. @tab OS/2 "OPTLINK" conventions will be used to CALL the subprogram.
@item
@item 5 @tab No @tab Windows 16-bit "thunking" will not be in effect. @tab Windows 16-bit "thunking" will be used to call the subroutine as a DLL.
@item
@item 6 @tab Yes @tab The STDCALL convention will not be used. @tab The STDCALL convention, required to use the Microsoft Win32 API,  will be used.
@end multitable
@* Using the @syntax{STDCALL} option on a @syntax{CALL} statement is equivalent to using @syntax{CALL-CONVENTION 8} (only bit 3 set).
@p Using the @syntax{STATIC} option on a @syntax{CALL} statement is equivalent to using @syntax{CALL CONVENTION 64} (only bit 6 set).
@end enumerate
@item The value of @term{literal-1} or @term{identifier-1} is the entry-point of the subprogram you wish to call.
@p @item When you call a subroutine using @term{identifier-1}, you are forcing the runtime system to call a dynamically-loadable subprogram.  The contents of @term{identifier-1} will be the entry-point name within that module.  If this is the @i{first} call to any entry-point within the module being made at run-time, the contents of @term{identifier-1} must be the primary entry-point name of the module (which must also match the filename, minus any OS-mandated extension) of the executable file comprising the module).
@p @item You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing.  This is accomplished through the use of the @envvarruntimeref{COB_PRE_LOAD}.  If used, this will only pre-load those modules invoked via @syntax{CALL @term{literal-1}}, as the runtime contents of @term{identifier-1} cannot be predicted.
@p @item If the subprogram being called is a GnuCOBOL program, and if that program had the @syntaxrefalt{INITIAL,IDENTIFICATION DIVISION} attribute specified on its @syntax{PROGRAM-ID} clause, all of the subprogram's data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.
@p This [re]-initialization behaviour will @i{always} apply to any subprogram's local-storage (if any), regardless of the use (or not) of @syntax{INITIAL}.
@p @item The @syntaxidx{USING} clause defines a list of arguments that may be passed from the calling program to the subprogram.  The manner in which any given argument is passed to the subroutine depends upon the @syntax{BY} clause (if any) coded (or implied) for that argument, as follows:
@enumerate A
@p @item @syntaxidx{BY REFERENCE} passes the @i{address} of the argument to the subprogram.  If the subprogram changes the contents of that argument, the change will be "visible" to the calling program.
@p @item @syntaxidx{BY CONTENT} passes the @i{address} of a @i{copy} of the argument to the subprogram.  If the subprogram changes the value of such an argument, the change only affects the copy back in the calling program, not the original version.
@p @item @syntaxidx{BY VALUE} passes the @i{actual numeric value} of the literal or identifiers contents as the argument.  This feature exists to provide compatibility with C, C++ and other languages and would not normally be used when calling GnuCOBOL subprograms.  Only numeric literals or numeric data items should be passed in this manner.
@p @item If an argument lacks a @syntax{BY} clause, the most-recently encountered @syntax{BY} specification on that @syntax{CALL} statement will be assumed.  If the first argument specified on a @syntax{CALL} lacks a @syntax{BY} clause, @syntax{BY REFERENCE} will be assumed.
@end enumerate
@item No more than 36 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it.  If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the @syntax{COB_MAX_FIELD_PARAMS} in the @syntax{common.h} file (found in the @syntax{libcob} folder) before you run @syntax{make} to build the compiler and run-time library.
@p @item The @syntaxidx{RETURNING} clause allows you to specify a numeric data item into which the subroutine should return a numeric value.  If you use this clause on the @syntax{CALL}, the subroutine should include a @syntaxrefalt{RETURNING,PROCEDURE DIVISION RETURNING} clause on its procedure division header.  Of course, a subroutine may pass a value of any kind back in any argument passed @syntax{BY REFERENCE}.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses (or @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} --- they are interchangeable) may be used to detect and react to the failure or success, respectively, of an attempt to @syntax{CALL} the subroutine.  Failure, in this context, is defined as the inability to either locate or load the object code of the subroutine at execution time.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.6 CANCEL                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.6,CANCEL}
@diagram{CANCEL,PD-CANCEL,PD-CANCEL,None}@p The @statement{CANCEL} unloads the dynamically-loadable subprogram module containing the entry-point specified as @term{literal-1} or @term{identifier-1} from memory.
@enumerate
@p @item If a dynamically-loadable module unloaded by the @statement{CANCEL} is subsequently re-executed, all data division storage for that module will once again be in it's initial state.
@p @item Whether the @statement{CANCEL} actually physically unloads a dynamically-loaded module or simply marks it as logically-unloaded depends on the use and value of the @envvarruntimeref{COB_PHYSICAL_CANCEL}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.7 CLOSE                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.7,CLOSE}
@diagram{CLOSE,PD-CLOSE,PD-CLOSE,PD-CLOSE}@p The @statement{CLOSE} terminates the program's access to the specified file(s).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{FOR} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{REEL} and @syntax{UNIT} are interchangeable.
@comment Semantic Specifications:
@p @item The @syntax{CLOSE} statement may only be executed against files that have been successfully opened.
@p @item A successful @syntax{CLOSE} will write any remaining unwritten record buffers to the file (similar to an @statementref{UNLOCK}) and release any file locks for the file, regardless of open mode.  A closed file will then be no longer available for subsequent I/O statements until it is once again OPENED.
@p @item When a @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{LINE ADVANCING} file is closed, a final delimiter sequence will be written to the file to signal the termination point of the final data record in the file.  This will only be necessary if the final record written to the file was written with the @syntaxrefalt{AFTER ADVANCING,WRITE} option.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.8 COMMIT                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.8,COMMIT}
@diagram{COMMIT,PD-COMMIT,PD-COMMIT,None}@p The @statement{COMMIT} performs an @syntax{UNLOCK} against every currently-open file, but does not close any of the files.
@p See the @statementref{UNLOCK} for additional details.
@comment *********************************************************************
@comment ** 6.17.9 COMPUTE                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.9,COMPUTE}
@diagram{COMPUTE,PD-COMPUTE,PD-COMPUTE,None}@p The @statement{COMPUTE} provides a means of easily performing complex arithmetic operations with a single statement, instead of using cumbersome and possibly confusing sequences of @syntax{ADD}, @syntax{SUBTRACT}, @syntax{MULTIPLY} and @syntax{DIVIDE} statements.  @syntax{COMPUTE} also allows the use of exponentiation --- an arithmetic operation for which no other statement exists in COBOL.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved word @syntax{EQUAL} is interchangeable with the use of @syntax{=}.
@comment Semantic Specifications:
@p @item Each @term{identifier-1} must be a numeric or numeric-edited data item.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-1} will control how non-integer results will be saved.
@p @item @xref{Arithmetic Expressions}, for more information on arithmetic expressions.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined either as having an @term{identifier-3} with an insufficient number of digit positions available to the left of any implied decimal point or attempting to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.10 CONTINUE                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.10,CONTINUE}
@diagram{CONTINUE,PD-CONTINUE,PD-CONTINUE,None}@p The @statement{CONTINUE} is a no-operation statement that may be coded anywhere an imperative statement (@pxref{Imperative Statement}) may be coded.
@enumerate
@p @item The @syntax{CONTINUE} statement has no effect on the execution of the program.
@p @item This statement (perhaps in combination with an appropriate comment or two) makes a convenient "place holder" --- particularly in @syntaxrefalt{ELSE,IF} or @syntaxrefalt{WHEN,EVALUATE} clauses where no code is currently expected to be needed, but a place for code to handle the conditions in question is to be reserved in case it's ever needed.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.11 DELETE                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.11,DELETE}
@diagram{DELETE,PD-DELETE,PD-DELETE,None}@p The @statement{DELETE} logically deletes a record from a COBOL file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{KEY} and @syntax{RECORD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntax{ORGANIZATION} of @term{file-name-1} cannot be @syntaxref{ORGANIZATION LINE SEQUENTIAL}.
@p @item The @term{file-name-1} file cannot be a sort/merge work file (a file described using a @syntaxrefalt{SD,File/Sort-Description}).
@p @item For files in the @syntax{SEQUENTIAL} access mode, the last input-output statement executed against @term{file-name-1} prior to the execution of the @syntax{DELETE} statement must have been a successfully executed sequential-format @statementrefalt{READ,Sequential READ}.  That @syntax{READ} will therefore identify the record to be deleted.
@p @item If @term{file-name-1} is a @syntax{RELATIVE} file whose @syntaxrefalt{ACCESS MODE,ORGANIZATION RELATIVE} is either @syntax{RANDOM} or @syntax{DYNAMIC}, the record to be deleted is the one whose relative record number is currently the value of the field specified as the files @syntaxidx{RELATIVE KEY} in it's @statement{SELECT}.
@p @item If @term{file-name-1} is an @syntax{INDEXED} file whose @syntaxrefalt{ACCESS MODE,ORGANIZATION INDEXED} is @syntax{RANDOM} or @syntax{DYNAMIC}, the record to be deleted is the one whose primary key is currently the value of the field specified as the @syntaxidx{RECORD KEY} in the file's @syntax{SELECT} statement.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, of an attempt to delete a record.  @xref{INVALID KEY + NOT INVALID KEY}, for additional information.
@p @item No @syntax{INVALID KEY} or @syntax{NOT INVALID KEY} clause may be specified for a file who's @syntax{ACCESS MODE IS SEQUENTIAL}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.12 DISPLAY                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.12,DISPLAY}
@menu
* 6.17.12.1: DISPLAY UPON device
* 6.17.12.2: DISPLAY UPON COMMAND-LINE
* 6.17.12.3: DISPLAY UPON ENVIRONMENT-NAME
* 6.17.12.4: DISPLAY screen-data-item
@end menu
@comment *********************************************************************
@comment ** 6.17.12.1 DISPLAY UPON device                                   **
@comment *********************************************************************
@newunit{6.17.12.1,DISPLAY UPON device}
@diagram{DISPLAY UPON device,PD-DISPLAY-1,PD-DISPLAY-1,None}@p This format of the @statement{DISPLAY} displays the specified identifier contents and/or literal values on the system output device specified via the @syntax{UPON} clause.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{ON} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item If no @syntaxidx{UPON} clause is specified, @syntax{UPON CONSOLE} will be assumed.  If the @syntax{UPON} clause @i{is} specified, @term{mnemonic-name-1} must be one of the built-in output device names @syntax{CONSOLE}, @syntax{PRINTER}, @syntax{STDERR}, @syntax{STDOUT}, @syntax{SYSERR}, @syntax{SYSLIST}, @syntax{SYSLST} or @syntax{SYSOUT} or a mnemonic name assigned to one of those devices via the @syntaxref{SPECIAL-NAMES} paragraph.
@p When displaying upon the @syntax{STDERR} or @syntax{SYSERR} devices or to a @term{mnemonic-name-1} attached to one of those two devices, the output will be written to output pipe #2, which will normally cause the output to appear in the console output window.  You may, if desired, redirect that output to a file by appending @syntax{2> filename} to the end of the command that executes the program.  This applies to both Windows (any type) or Unix versions of GnuCOBOL.
@p When displaying upon the @syntax{CONSOLE}, @syntax{PRINTER}, @syntax{STDOUT}, @syntax{SYSLIST}, @syntax{SYSLST} or @syntax{SYSOUT} devices or to a @term{mnemonic-name-1} attached to one of them, the output will be written to output pipe #1, which will normally cause the output to appear in the console output window.  You may, if desired, redirect that output to a file by appending @syntax{1> filename} or simply @syntax{> filename} to the end of the command that executes the program.  This applies to both Windows (any type) or Unix versions of GnuCOBOL.
@p @item The @syntaxidx{NO ADVANCING} clause, if used, will suppress the carriage-return / line-feed sequence that is normally added to the end of any console display.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified device.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.12.2 DISPLAY UPON COMMAND-LINE                             **
@comment *********************************************************************
@page
@newunit{6.17.12.2,DISPLAY UPON COMMAND-LINE}
@diagram{DISPLAY UPON COMMAND-LINE,PD-DISPLAY-2,PD-DISPLAY-2,None}@p This form of the @statement{DISPLAY} may be used to specify the command-line argument number to be retrieved by a subsequent @statementrefalt{ACCEPT FROM ARGUMENT-VALUE,ACCEPT FROM COMMAND-LINE} or to specify a new value for the command-line arguments themselves.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item By displaying a numeric integer value UPON @syntaxidx{ARGUMENT-NUMBER}, you will specify which argument (by its relative number) will be retrieved by a subsequent @statement{ACCEPT FROM ARGUMENT-VALUE}.
@p @item Executing a @syntax{DISPLAY UPON COMMAND-LINE} will influence subsequent @syntax{ACCEPT FROM COMMAND-LINE} statements (which will then return the  value you displayed), but will not influence subsequent @syntax{ACCEPT FROM ARGUMENT-VALUE} statements --- these will continue to return the original program execution parameters.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified item.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.12.3 DISPLAY UPON ENVIRONMENT-NAME                         **
@comment *********************************************************************
@page
@newunit{6.17.12.3,DISPLAY UPON ENVIRONMENT-NAME}
@diagram{DISPLAY UPON ENVIRONMENT-NAME,PD-DISPLAY-3-Info,PD-DISPLAY-3-TeX,None}@p This form of the @statement{DISPLAY} can be used to create or modify environment variables.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{ON} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item To create or change an environment variable will require two @syntax{DISPLAY} statements.  The following example sets the environment variable "MY_ENV_VAR" to a value of "Demonstration Value":
@p @example
DISPLAY "MY_ENV_VAR" UPON ENVIRONMENT-NAME
DISPLAY "Demonstration Value" UPON ENVIRONMENT-VALUE
@end example
@item Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. @syntaxrefalt{CALL 'SYSTEM',SYSTEM}) but will not be known to the shell or console window that started the GnuCOBOL program.
@p @item Consider using @syntaxref{SET ENVIRONMENT} in lieu of @syntax{DISPLAY} to set environment variables as it is much simpler.
@p @item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of an attempt to display output to the specified item.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.12.4 DISPLAY screen-data-item                              **
@comment *********************************************************************
@page
@newunit{6.17.12.4,DISPLAY screen-data-item}
@diagram{DISPLAY screen-data-item,PD-DISPLAY-4,PD-DISPLAY-4,PD-DISPLAY-4}@p This format of the @statement{DISPLAY} presents data onto a formatted screen.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AFTER}, @syntax{LINE}, @syntax{LINES}, @syntax{NUMBER} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{COLUMN} and @syntax{POSITION} are interchangeable.
@p @item The reserved words @syntax{LINE} and @syntax{LINES} are interchangeable.
@p @item The reserved words @syntax{TIMEOUT} and @syntax{TIME-OUT} are interchangeable.
@comment Semantic Specifications:
@p @item If @term{identifier-1} is defined in the @syntaxref{SCREEN SECTION}, any @syntax{AT}, @term{Attribute-Specification} and @syntax{WITH} clauses will be ignored.  All field definition, cursor positioning and screen control will occur as a result of the screen section definition of @term{identifier-1}.
@p @item The following points apply if @term{identifier-1} is not defined in the screen section:
@enumerate A
@p @item The purpose of the @syntax{AT} clause is to define where on the screen @term{identifier-1} should be displayed.  @xref{ACCEPT screen-data-item}, for additional information.
@p @item The purpose of the @syntax{WITH} clause is to define the visual attributes that should be applied to @term{identifier-1} when it is displayed on the screen as well as other presentation-control characteristics.
@p @item The following @term{Attribute-Specification} clauses are allowed on the @syntax{DISPLAY} statement --- these are the same as those allowed for @syntax{SCREEN SECTION} data items.  A particular @term{Attribute-Specification} may be used only once in any @syntax{DISPLAY}:
@itemize @bullet
@p @item @syntaxref{BACKGROUND-COLOR}
@p @item @syntaxref{BEEP}, @syntaxref{BELL}
@p @item @syntaxref{BLANK}
@p @item @syntaxref{BLINK}
@p @item @syntaxref{ERASE}
@p @item @syntaxref{FOREGROUND-COLOR}
@p @item @syntaxref{HIGHLIGHT}
@p @item @syntaxref{LOWLIGHT}
@p @item @syntaxref{OVERLINE}
@p @item @syntaxref{REVERSE-VIDEO}
@p @item @syntaxref{UNDERLINE}
@end itemize
@item @xref{ACCEPT screen-data-item}, for additional information on the other @syntax{WITH} clause options.
@end enumerate
@item The optional @syntax{ON EXCEPTION} and @syntax{NOT ON EXCEPTION} clauses may be used to detect and react to the failure or success, respectively, of the screen I/O attempt.  @xref{ON EXCEPTION + NOT ON EXCEPTION}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.13 DIVIDE                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.13,DIVIDE}
@menu
* 6.17.13.1: DIVIDE INTO
* 6.17.13.2: DIVIDE INTO GIVING
* 6.17.13.3: DIVIDE BY GIVING
@end menu
@comment *********************************************************************
@comment ** 6.17.13.1 DIVIDE INTO                                           **
@comment *********************************************************************
@newunit{6.17.13.1,DIVIDE INTO}
@diagram{DIVIDE INTO,PD-DIVIDE-1,PD-DIVIDE-1,None}@p This format of the @statement{DIVIDE} will divide a numeric value (specified as a literal or numeric data item) into one or more numeric data items, replacing the value in each of those data items with the result(s).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items and @term{literal-1} must be a numeric literal.
@p @item A division operation will be performed for each @term{identifier-2}, in turn.  Each of the results of those divisions will be saved to the corresponding @term{identifier-2} data item(s).
@p @item Should any @term{identifier-2} be an integer numeric data item, the result computed when that @term{identifier-2} is divided by @term{literal-1} or @term{identifier-1} will also be an integer --- any remainder from that division will be discarded.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being numeric truncation caused by an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.13.2 DIVIDE INTO GIVING                                    **
@comment *********************************************************************
@page
@newunit{6.17.13.2,DIVIDE INTO GIVING}
@diagram{DIVIDE INTO GIVING,PD-DIVIDE-2,PD-DIVIDE-2,None}@p This format of the @statement{DIVIDE} will divide one numeric value (specified as a literal or numeric data item) into another numeric value (also specified as a literal or numeric data item) and will then replace the contents of one or more receiving data items with the results of that division.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while both @term{identifier-3} and @term{identifier-4} must be numeric (edited or unedited) data items.
@p @item Both @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item If the @syntaxidx{REMAINDER} clause is coded, there may be only one @term{identifier-3} specified.
@p @item The result obtained when the value of @term{literal-2} or @term{identifier-2} is divided by the value of @term{literal-1} or @term{identifier-1} is computed; this result is then moved into each @term{identifier-3}, in turn, applying the rules defined by the @syntaxref{ROUNDED} clause (if any) for that @term{identifier-3} to the move.
@p @item If a @syntax{REMAINDER} clause is specified, the value of the one and only @term{identifier-3} (as stated earlier, if @syntax{REMAINDER} is specified there may only be a single @term{identifier-3} coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of @term{literal-1} or @term{identifier-1}; that result is then subtracted from the value of @term{literal-2} or @term{identifier-2} and @i{that} result is the value which is moved to @term{identifier-4}.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.13.3 DIVIDE BY GIVING                                      **
@comment *********************************************************************
@page
@newunit{6.17.13.3,DIVIDE BY GIVING}
@diagram{DIVIDE BY GIVING,PD-DIVIDE-3,PD-DIVIDE-3,None}@p This format of the @statement{DIVIDE} will divide one numeric value (specified as a literal or numeric data item) into another numeric value (also specified as a literal or numeric data item) and will then replace the contents of one or more receiving data items with the results of that division.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items while both @term{identifier-3} and @term{identifier-4} must be numeric (edited or unedited) data items.
@p @item Both @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item If the @syntaxidx{REMAINDER} clause is coded, there may be only one @term{identifier-3} specified.
@p @item The result obtained when the value of @term{literal-1} or @term{identifier-1} is divided by the value of @term{literal-2} or @term{identifier-2} is computed; this result is then moved into each @term{identifier-3}, in turn, applying the rules defined by the @syntaxref{ROUNDED} clause (if any) for that @term{identifier-3} to the move.
@p @item If a @syntax{REMAINDER} clause is specified, the value of the one and only @term{identifier-3} (as stated earlier, if @syntax{REMAINDER} is specified there may only be a single @term{identifier-3} coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of @term{literal-2} or @term{identifier-2}; that result is then subtracted from the value of @term{literal-1} or @term{identifier-1} and @i{that} result is the value which is moved to @term{identifier-4}.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point, or an attempt to divide by zero.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.14 ENTRY                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.14,ENTRY}
@diagram{ENTRY,PD-ENTRY,PD-ENTRY,None}
@diagram{ENTRY-Argument,PD-ENTRY-Arg,PD-ENTRY-Arg,None}@p The @statement{ENTRY} is used to define an alternate entry-point into a subroutine, along with the arguments that subroutine will be expecting.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{BY} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item You may not use an @statement{ENTRY} in a nested subprogram, nor may you use it in any form of user-defined function.
@p @item The @syntaxidx{USING} clause defines the arguments the subroutine entry-point supports.  This list of arguments must match up against the @syntax{USING} clause of any @statement{CALL} that will be invoking the subroutine using this entry-point.
@p @item Each @term{ENTRY-Argument} specified on the @statement{ENTRY} must be defined in the linkage section of the subroutine in which the @statement{ENTRY} exists.
@p @item The @term{literal-1} value will specify the entry-point name of the subroutine.  It must be specified exactly on @syntax{CALL} statements (with regard to the use of upper- and lower-case letters) as it is specified on the @statement{ENTRY}.
@p @item The meaning of @syntaxidx{REFERENCE}, @syntaxidx{CONTENT} and @syntaxidx{VALUE} are the same as the equivalent specifications on the @statementref{CALL}.  Whatever specification will be used for an argument on the @syntax{CALL} to this entry-point should match the specification used in the corresponding @term{ENTRY-Argument}.  The same rules regarding the presence or absence of a @syntax{BY} clause on a @statement{CALL} apply to the presence or absence of a @syntax{BY} clause on the corresponding argument of the @statement{ENTRY}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.15 EVALUATE                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.15,EVALUATE}
@diagram{EVALUATE,PD-EVALUATE,PD-EVALUATE,None}
@diagram{EVALUATE Selection Subject,PD-EVALUATE-SS,PD-EVALUATE-SS,None}
@diagram{EVALUATE Selection Object,PD-EVALUATE-SO,PD-EVALUATE-SO,None}@p The @statement{EVALUATE} provides a means of defining processing that should take place under any number of mutually-exclusive conditions.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item There must be at least one @syntaxidx{WHEN} clause (in addition to any @syntaxidx{WHEN OTHER} clause) specified on any @statement{EVALUATE}.
@p @item There must be at least one @term{Selection-Subject} specified on the @statement{EVALUATE}.  Any number of additional @term{Selection-Subject} clauses may be specified, using the @syntaxidx{ALSO} reserved word to separate each from the prior.
@p @item Each @syntax{WHEN} clause (other than the @syntaxidx{WHEN OTHER} clause, if any) must have the same number of @term{Selection-Object} clauses as there are @term{Selection-Subject} clauses.
@p @item When using @syntaxidx{THRU}, the values on both sides of the @syntax{THRU} must be the same class (both numeric, both alphanumeric, etc.).
@p @item A @term{partial-expression} is one of the following:
@enumerate A
@p @item A Class Condition without a leading @term{identifier-1} (@pxref{Class Conditions}).
@p @item A Sign Condition without a leading @term{identifier-1} (@pxref{Sign Conditions}).
@p @item A Relation Condition with nothing to the left of the relational operator (@pxref{Relation Conditions}).
@end enumerate
@comment Semantic Specifications:
@item At execution time, each @term{Selection-Subject} on the @statement{EVALUATE} will have its value matched against that of the corresponding @term{Selection-Object} on a @syntax{WHEN} clause, in turn, until:
@enumerate A
@p @item A @syntax{WHEN} clause has @i{each} of its @term{Selection-Object}(s) successfully matched by the corresponding @term{Selection-Subject}; this will be referred to as the '@i{Selected WHEN clause}'.
@p @item The complete list of @syntax{WHEN} clauses (except for the @syntax{WHEN OTHER} clause, if any) has been exhausted.  In this case, there is no '@i{Selected WHEN Clause}'.
@end enumerate
@item If a '@i{Selected WHEN Clause}' was identified:
@enumerate A
@p @item The @term{imperative-statement-1} (@pxref{Imperative Statement}) immediately following the '@i{Selected WHEN Clause}' will be executed.  If the '@i{Selected WHEN Clause}' is lacking an @term{imperative-statement-1}, the first @term{imperative-statement-1} found after any following @syntax{WHEN} clause will be executed.
@p @item Once the @term{imperative-statement-1} has been executed, or no @term{imperative-statement-1} was found anywhere after the '@i{Selected WHEN Clause}', control will proceed to the statement following the @syntax{END-EVALUATE} or, if there is no @syntax{END-EVALUATE}, the first statement that follows the next period.  If, however, the @term{imperative-statement-1} included a @statement{GO TO}, and that @syntax{GO TO} was executed, then control will transfer to the procedure named on the @syntax{GO TO} instead.
@end enumerate
@item If no '@i{Selected WHEN Clause}' was identified:
@enumerate A
@p @item The @syntax{WHEN OTHER} clause's @term{imperative-statement-other} will be executed, if such a clause was coded.
@p @item Control will then proceed to the statement following the @syntax{END-EVALUATE} or the first statement that follows the next period if there is no @syntax{END-EVALUATE}.  If,however, the @term{imperative-statement-other} included a @statement{GO TO}, and that @syntax{GO TO} was executed, then control will transfer to the procedure named on the @syntax{GO TO} instead.
@end enumerate
@item In order for a @term{Selection-Subject} to match the corresponding @term{Selection-Object} on a @syntax{WHEN} clause, at least one of the following must be true:
@enumerate A
@p @item The @term{Selection-Object} is @syntaxidx{ANY}
@p @item The implied Relation Condition @syntax{@term{Selection-Subject} = @term{Selection Object}} is TRUE --- @xref{Relation Conditions}, for the rules on how the comparison will be made.
@p @item The value of the @term{Selection-Subject} falls within the range of values specified by the @syntax{THRU} clause of the @term{Selection-Object}
@p @item If the @term{Selection-Object} is a @term{partial-expression}, then the conditional expression that would be represented by coding @syntax{@term{Selection-Subject} @term{Selection-Object}} evaluates to TRUE
@end enumerate
@item Here is a sample program that illustrates the EVALUATE statement.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DEMOEVALUATE.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Test-Digit                  PIC 9(1).
    88 Digit-Is-Odd VALUE 1, 3, 5, 7, 9.
    88 Digit-Is-Prime VALUE 1, 3, 5, 7.
PROCEDURE DIVISION.
P1. PERFORM UNTIL EXIT
    DISPLAY "Enter a digit (0 Quits): "
        WITH NO ADVANCING
    ACCEPT Test-Digit
    IF Test-Digit = 0
        EXIT PERFORM
    END-IF
    EVALUATE Digit-Is-Odd ALSO Digit-Is-Prime
    WHEN TRUE ALSO FALSE
        DISPLAY Test-Digit " is ODD"
            WITH NO ADVANCING
    WHEN TRUE ALSO TRUE
        DISPLAY Test-Digit " is PRIME"
            WITH NO ADVANCING
    WHEN FALSE ALSO ANY
        DISPLAY Test-Digit " is EVEN"
            WITH NO ADVANCING
    END-EVALUATE
    EVALUATE Test-Digit
    WHEN < 5
        DISPLAY " and it's small too"
    WHEN < 8
        DISPLAY " and it's medium too"
    WHEN OTHER
        DISPLAY " and it's large too"
    END-EVALUATE
END-PERFORM
DISPLAY "Bye!"
STOP RUN
.
@end example
@* Console output when run (user input follows the colons on the prompts for input):
@p @example
Enter a digit (0 Quits): 1
1 is PRIME and it's small too
Enter a digit (0 Quits): 2
2 is EVEN and it's small too
Enter a digit (0 Quits): 3
3 is PRIME and it's small too
Enter a digit (0 Quits): 4
4 is EVEN and it's small too
Enter a digit (0 Quits): 5
5 is PRIME and it's medium too
Enter a digit (0 Quits): 6
6 is EVEN and it's medium too
Enter a digit (0 Quits): 7
7 is PRIME and it's medium too
Enter a digit (0 Quits): 8
8 is EVEN and it's large too
Enter a digit (0 Quits): 9
9 is ODD and it's large too
Enter a digit (0 Quits): 0
Bye!
@end example
@end enumerate
@comment *********************************************************************
@comment ** 6.17.16 EXIT                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.16,EXIT}
@diagram{EXIT,PD-EXIT,PD-EXIT,None}@p The @statement{EXIT} is a multi-purpose statement; it may provide a common end point for a series of procedures, exit an in-line PERFORM, paragraph or section or it may mark the logical end of a subprogram, returning control back to the calling program.
@enumerate
@comment Syntactical Specifications:
@p @item The @statement{EXIT PROGRAM} is not legal anywhere within a user-defined function.
@p @item The @statement{EXIT FUNCTION} cannot be used anywhere within a subroutine.
@p @item Neither @syntax{EXIT PROGRAM} nor @syntax{EXIT FUNCTION} may be used within a @syntax{USE GLOBAL} routine in @syntaxref{DECLARATIVES}.
@comment Semantic Specifications:
@p @item The following points describe the @statement{EXIT} with none of the optional clauses:
@enumerate A
@p @item When this form of an @statement{EXIT} is used, it must be the only statement in the procedure (paragraph or section) in which it occurs.
@p @item This usage of the @statement{EXIT} simply provides a common "GO TO" end point for a series of procedures, as may be seen in the following example:
@p @example
01  Switches.
    05 Input-File-Switch PIC X(1).
       88 EOF-On-Input-File VALUE Y FALSE N.
@dots{}
    SET EOF-On-Input-File TO FALSE.
    PERFORM 100-Process-A-Transaction THRU 199-Exit
        UNTIL EOF-On-Input-File.
@dots{}
100-Process-A-Transaction.
    READ Input-File AT END
        SET EOF-On-Input-File TO TRUE
        GO TO 199-Exit
    END-READ.
    IF Input-Rec of Input-File = SPACES
        GO TO 199-Exit  *> IGNORE BLANK RECORDS!
    END-IF.
    <<@term{process the record just read}>>
199-Exit.
    EXIT.
@end example
@item In this case, the @statement{EXIT} takes no other run-time action.
@end enumerate
@item The following points apply to the @syntax{EXIT PARAGRAPH} and @syntax{EXIT SECTION} statements:
@enumerate A
@p @item If an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} resides in a paragraph @i{within} the scope of a procedural @syntaxrefalt{PERFORM,Procedural PERFORM}, control will be returned back to the @syntax{PERFORM} for evaluation of any @syntax{TIMES}, @syntax{VARYING} and/or @syntax{UNTIL} clauses.
@p @item If an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} resides @i{outside} the scope of a procedural @syntax{PERFORM}, control simply transfers to the first executable statement in the next paragraph (@syntax{EXIT PARAGRAPH}) or section (@syntax{EXIT SECTION}).
@p @item The following shows how the previous example could have been coded without a @syntax{GO TO} by utilizing an @statement{EXIT PARAGRAPH}.
@p @example
01  Switches.
    05 Input-File-Switch PIC X(1).
       88 EOF-On-Input-File VALUE Y FALSE N.
@dots{}
    SET EOF-On-Input-File TO FALSE.
    PERFORM 100-Process-A-Transaction
        UNTIL EOF-On-Input-File.
@dots{}
100-Process-A-Transaction.
    READ Input-File AT END
        SET EOF-On-Input-File TO TRUE
        EXIT PARAGRAPH
    END-READ.
    IF Input-Rec of Input-File = SPACES
        EXIT PARAGRAPH *> IGNORE BLANK RECORDS!
    END-IF.
    <<@term{process the record just read}>>
@end example
@end enumerate
@item The following points apply to the @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements:
@enumerate A
@p @item The @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements are intended to be used in conjunction with an in-line @statementrefalt{PERFORM,Inline PERFORM}.
@p @item An @statement{EXIT PERFORM CYCLE} will terminate the current iteration of the in-line @syntax{PERFORM}, giving control to any @syntax{TIMES}, @syntax{VARYING} and/or @syntax{UNTIL} clauses for them to determine if another cycle needs to be performed.
@p @item An @statement{EXIT PERFORM} will terminate the in-line PERFORM outright, transferring control to the first statement following the @syntax{END-PERFORM} (if there is one) or to the next sentence following the @syntax{PERFORM} if there is no @syntax{END-PERFORM}.
@p @item This last example shows the final modification to the previous examples by using an in-line @syntax{PERFORM} along with @syntax{EXIT PERFORM} and @syntax{EXIT PERFORM CYCLE} statements:
@p @example
PERFORM FOREVER
    READ Input-File AT END
        EXIT PERFORM
    END-READ
    IF Input-Rec of Input-File = SPACES
        EXIT PERFORM CYCLE *> IGNORE BLANK RECORDS!
    END-IF
    <<@term{process the record just read}>>
END PERFORM
@end example
@end enumerate
@item The following points apply to the @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} statements:
@enumerate A
@p @item The @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} statements terminate the execution of a subroutine (i.e.  a program that has been CALLed by another) or user-defined function, respectively, returning control back to the calling program.
@p @item An @statement{EXIT PROGRAM} returns control back to the statement following the @syntaxref{CALL} of the subprogram.  An @statement{EXIT FUNCTION} returns control back to the processing of the statement in the calling program that invoked the user-defined function.
@p @item If executed by a main program, neither the @syntax{EXIT PROGRAM} nor @syntax{EXIT FUNCTION} statements will take any action.
@p @item The COBOL2002 standard has made a common extension to the COBOL language --- the @statementref{GOBACK} --- a standard language element; the @syntax{GOBACK} statement should be strongly considered as the preferred alternative to both @syntax{EXIT PROGRAM} and @syntax{EXIT FUNCTION} for new subprograms.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.17 FREE                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.17,FREE}
@diagram{FREE,PD-FREE,PD-FREE,None}@p The @statement{FREE} releases memory previously allocated to the program by the @statementref{ALLOCATE}.
@enumerate
@comment Syntactical Specifications:
@p @item The @syntax{ADDRESS OF} clause is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this clause has no effect upon the program.
@comment Semantic Specifications:
@p @item @term{identifier-1} must have a @syntaxref{USAGE} of @syntax{POINTER}, or it must be an 01-level data item with the @syntaxref{BASED} attribute.
@p @item If @term{identifier-1} is a @syntax{USAGE POINTER} data item and it contains a valid address, the @statement{FREE} will release the memory block the pointer references.  In addition, any @syntax{BASED} data items that the pointer was used to provide an address for will become un-based and therefore un-usable.  If @term{identifier-1} did not contain a valid address, no action will be taken.
@p @item If @term{identifier-1} is a @syntax{BASED} data item and that data item is currently based (meaning it currently has memory allocated to it), its memory is released and @term{identifier-1} will become un-based and therefore un-usable.  If @term{identifier-1} was not based, no action will be taken.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.18 GENERATE                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.18,GENERATE}
@diagram{GENERATE,PD-GENERATE,PD-GENERATE,None}@p The @statement{GENERATE} presents data to a report.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The following points apply when @term{identifier-1} is specified:
@enumerate A
@p @item @term{identifier-1} must be the name of a @syntaxrefalt{DETAIL,RWCS Lexicon} report group.
@p @item If necessary, @term{identifier-1} may be qualified with a report name.
@p @item The file in whose @syntax{FD} a @syntax{REPORT} clause exists for the report in which @term{identifier-1} is a detail group must be opened for @syntax{OUTPUT} or @syntax{EXTEND} at the time the @syntax{GENERATE} is executed.  @xref{OPEN}, for information on file open modes.
@p @item The report in which @term{identifier-1} is a @syntax{DETAIL} group must have been successfully initiated via the @statementref{INITIATE} and not yet terminated via the @statementref{TERMINATE} at the time the @syntax{GENERATE} is executed.
@p @item If at least one @syntax{GENERATE} statement of this form is executed against a report, the report is said to be a @define{detail report}.  If no @syntax{GENERATE} statements of this form are executed against a report, the report is said to be a @define{summary report}.
@end enumerate
@item The following points apply when @term{report-name-1} is specified:
@enumerate A
@p @item @term{report-name-1} must be the name of a report having an @syntax{RD} defined for it in the report section.
@p @item There must be at least one @syntaxrefalt{CONTROL,RWCS Lexicon} group defined for @term{report-name-1}.
@p @item There cannot be more than one @syntax{DETAIL} group defined for @term{report-name-1}.
@p @item The file in whose @syntax{FD} a @syntax{REPORT @term{report-name-1}} clause exists must be open for  @syntax{OUTPUT} or @syntax{EXTEND} at the time the GENERATE is executed.
@p @item @term{report-name-1} must have been successfully initiated (via "INITIATE @term{report-name-1}") and not yet terminated (via TERMINATE) at the time the @syntax{GENERATE} is executed.  @xref{OPEN}, for information on file open modes.
@p @item The @syntax{DETAIL} group which is defined for @term{report-name-1} @i{will} be processed but will not actually be presented to any report page.  This will allow summary processing to take place.  If all @syntax{GENERATE} statements are of this form, the report is said to be a @define{summary report}.  If at least one @syntax{GENERATE @term{identifier-1}} is executed, the report is considered to be a @define{detail report}.
@end enumerate
@item When the first @syntax{GENERATE} statement for a report is executed, the contents of all control fields are saved so they may be referenced during the processing of subsequent @syntax{GENERATE} statements.
@p @item When, during the processing of  a subsequent @syntax{GENERATE}, it is determined that a control field has changed value (ie. a control break has occurred), the appropriate control footing and control heading processing will take place and a snapshot of the current values of all control fields will again be saved.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.19 GOBACK                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.19,GOBACK}
@diagram{GOBACK,PD-GOBACK,PD-GOBACK,None}@p The @statement{GOBACK} is used to logically terminate an executing program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item If executed within a subprogram (i.e. a subroutine or user-defined function), @syntax{GOBACK} behaves like an @syntax{EXIT PROGRAM} or @statement{EXIT FUNCTION}, respectively.
@p @item If executed within a main program, @syntax{GOBACK} will act as a @syntax{STOP RUN} statement.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.20 GO TO                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.20,GO TO}
@menu
* 6.17.20.1: Simple GO TO
* 6.17.20.2: GO TO DEPENDING ON
@end menu
@comment *********************************************************************
@comment ** 6.17.20.1 Simple GO TO                                          **
@comment *********************************************************************
@newunit{6.17.20.1,Simple GO TO}
@diagram{Simple GO TO,PD-GO-TO-1,PD-GO-TO-1,None}@p This form of the @statement{GO TO} unconditionally transfers control in a program to the first executable statement within the specified @term{procedure-name-1}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{TO} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item If this format of the @statement{GO TO} appears in a consecutive sequence of imperative statements (@pxref{Imperative Statement}) within a sentence, it must be the @i{final} statement in the sentence.
@comment Semantic Specifications:
@p @item If a @syntax{GO TO} is executed within the scope of@dots{}
@enumerate A
@p @item ...an in-line @syntaxref{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to @term{procedure-name-1}.
@p @item ...a procedural @syntaxref{PERFORM}, and @term{procedure-name-1} lies outside the scope of that @syntax{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to @term{procedure-name-1}.
@p @item ...a @statementref{MERGE} @syntax{OUTPUT PROCEDURE} or within the scope of either an @syntax{INPUT PROCEDURE} or @syntax{OUTPUT PROCEDURE} of a @statementrefalt{SORT,File-Based SORT}, and @term{procedure-name-1} lies outside the scope of that procedure, the @syntax{SORT} or @syntax{MERGE} operation is terminated as control of execution transfers to @term{procedure-name-1}.  Any sorted or merged data accumulated to that point is lost.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.20.2 GO TO DEPENDING ON                                    **
@comment *********************************************************************
@page
@newunit{6.17.20.2,GO TO DEPENDING ON}
@diagram{GO TO DEPENDING ON,PD-GO-TO-2,PD-GO-TO-2,None}@p This form of the @statement{GO TO} will transfer control to any one of a number of specified procedure names depending on the numeric value of the identifier specified on the statement.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{TO} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item The @syntaxref{PICTURE} and/or @syntaxref{USAGE} of the specified @term{identifier-1} must be such as to define it as a numeric, unedited, preferably unsigned integer data item.
@p @item If the value of @term{identifier-1} has the value 1, control will be transferred to the 1st specified procedure name.  If the value is 2, control will transfer to the 2nd procedure name, and so on.
@p If control of execution is transferred to a procedure named on the statement, and the @syntax{GO TO} is executed within the scope of@dots{}
@enumerate A
@p @item ...an in-line @syntaxref{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to the procedure named on the statement.
@p @item ...a procedural @syntaxref{PERFORM}, and @term{procedure-name-1} lies outside the scope of that @syntax{PERFORM}, the @syntax{PERFORM} is terminated as control of execution transfers to the procedure named on the statement.
@p @item ...a @statementref{MERGE} @syntax{OUTPUT PROCEDURE} or within the scope of either an @syntax{INPUT PROCEDURE} or @syntax{OUTPUT PROCEDURE} of a @statementrefalt{SORT,File-Based SORT}, and @term{procedure-name-1} lies outside the scope of that procedure, the @syntax{SORT} or @syntax{MERGE} operation is terminated as control of execution transfers to the procedure named on the statement.  Any sorted or merged data accumulated to that point is lost.
@end enumerate
@item If the value of @term{identifier-1} is less than 1 or exceeds the total number of procedure names specified on the statement, control will simply fall through into the next statement following the @syntax{GO TO}.
@p @item The following example shows how @syntax{GO TO ... DEPENDING ON} may be used in a real application situation, and compares it against an alternative --- @syntaxref{EVALUATE}.
@verbatim
GO TO DEPENDING ON Example        Equivalent EVALUATE Example
================================= =================================
    GO TO                         EVALUATE Acct-Type
      ACCT-TYPE-1                 WHEN 1
      ACCT-TYPE-2                     <<< Handle Acct Type 1 >>>
      ACCT-TYPE-3                 WHEN 2
    DEPENDING ON Acct-Type.           <<< Handle Acct Type 2 >>>
    <<< Invalid Acct Type >>>     WHEN 3
    GO TO All-Done.                   <<< Handle Acct Type 3 >>>
Acct-Type-1.                      WHEN OTHER
    <<< Handle Acct Type 1 >>>        <<< Invalid Acct Type >>>
    GO TO All-Done.               END-EVALUATE.
Acct-Type-2.
    <<< Handle Acct Type 2 >>>
    GO TO All-Done.
Acct-Type-3.
    <<< Handle Acct Type 3 >>>
All-Done.
@end verbatim
@item Current programming philosophy would prefer the use of the @statement{EVALUATE} to that of this form of the @statement{GO TO}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.21 IF                                                      **
@comment *********************************************************************
@page
@newsubsection{6.17.21,IF}
@diagram{IF,PD-IF,PD-IF,None}@p The @statement{IF} is used to conditionally execute an imperative statement (@pxref{Imperative Statement}) or to select one of two different imperative statements to execute based upon the TRUE/FALSE value of a conditional expression.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{THEN} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item  You cannot use both @syntax{NEXT SENTENCE} and the @syntax{END-IF} scope terminator in the same @syntax{IF} statement.
@comment Semantic Specifications:
@p @item If @term{conditional-expression} evaluates to TRUE, @term{imperative-statement-1} will be executed regardless of whether or not an @syntaxidx{ELSE} clause is present.  Once @term{imperative-statement-1} has been executed, control falls into the first statement following the @syntax{END-IF} or to the first statement of the next sentence if there is no @syntax{END-IF} clause.
@p @item If the optional @syntax{ELSE} clause is present and conditional-expression evaluates to false, then (and only then) @term{imperative-statement-2} will be executed. Once @term{imperative-statement-2} has been executed, control falls into the first statement following the @syntax{END-IF} or to the first statement of the next sentence if there is no @syntax{END-IF} clause.
@p @item The clause @syntaxidx{NEXT SENTENCE} may be substituted for either imperative-statement, but not both.  If control reaches a @syntax{NEXT SENTENCE} clause due to the truth or falsehood of @term{conditional-expression}, control will be transferred to the first statement of the next sentence found in the program (the first statement after the next period).
@p @syntax{NEXT SENTENCE} was needed for COBOL programs that were coded according to pre-1985 standards that wish to nest one @statement{IF} inside another.  @xref{Use of VERB/END-VERB Constructs}, for an explanation of why @syntax{NEXT SENTENCE} was necessary.
@p Programs coded for 1985 (and beyond) standards don't need it, instead using the explicit scope-terminator @syntax{END-IF} to inform the compiler where @term{imperative-statement-2} (or @term{imperative-statement-1} if there is no @syntax{ELSE} clause coded) ends.  New GnuCOBOL programs should be coded to use the @syntax{END-IF} scope terminator for @syntax{IF} statements.  @xref{Use of VERB/END-VERB Constructs}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.22 INITIALIZE                                              **
@comment *********************************************************************
@page
@newsubsection{6.17.22,INITIALIZE}
@diagram{INITIALIZE,PD-INITIALIZE,PD-INITIALIZE,None}@p The @statement{INITIALIZE} initializes each @term{identifier-1} with certain specific values, depending upon the options specified.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{DATA}, @syntax{OF}, @syntax{THEN}, @syntax{TO} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{INITIALIZE} and @syntax{INITIALISE} are interchangeable.
@p @item The @syntax{WITH FILLER}, @syntax{REPLACING} and @syntax{DEFAULT} clauses are meaningful only if @term{identifier-1} is a group item.  They are accepted if it's an elementary item, but will serve no purpose.  The @syntax{VALUE} clause is meaningful in both cases.
@p @item A @term{category-name-1} and/or @term{category-name-2} may be any of the following:
@table @asis
@p @item @syntaxidx{ALPHABETIC}
@p The @syntaxref{PICTURE} of the data item only contains @syntax{A} symbols.
@p @item @syntaxidx{ALPHANUMERIC}
@p The @syntax{PICTURE} of the data item contains only @syntax{X} or a combination of @syntax{A} and @syntax{9} symbols.
@p @item @syntaxidx{ALPHANUMERIC-EDITED}
@p The @syntax{PICTURE}  of the data item contains only @syntax{X} or a combination of @syntax{A} and @syntax{9} symbols plus at least one @syntax{B}, @syntax{0} (zero) or @syntax{/} symbol.
@p @item @syntaxidx{NUMERIC}
@p The data item is one that is described with a picture less @syntaxref{USAGE} or has a @syntax{PICTURE} composed of nothing but @syntax{P}, @syntax{9}, @syntax{S} and @syntax{V} symbols.
@p @item @syntaxidx{NUMERIC-EDITED}
@p The @syntax{PICTURE} of the data item contains nothing but the symbol @syntax{9} and at least one of the editing symbols @syntax{$}, @syntax{+}, @syntax{-}, @syntax{CR}, @syntax{DB}, @syntax{.}, @syntax{,}, @syntax{*} or @syntax{Z}.
@p @item @syntaxidx{NATIONAL}
@p The data item is one containing nothing but the @syntax{N} symbol.
@p @item @syntaxidx{NATIONAL-EDITED}
@p The data item contains nothing but @syntax{N}, @syntax{B}, @syntax{/} and @syntax{0} symbols.
@end table
@comment Semantic Specifications:
@item From the sequence of @term{identifier-1} data items specified on the @statement{INITIALIZE}, a list of initialized fields referred to as the @i{field list} in the remainder of this section, will include:
@enumerate A
@p @item Every @term{identifier-1} that is an elementary item, including any that may have the @syntaxref{REDEFINES} clause in their descriptions.
@p @item Every non-FILLER elementary item subordinate to @term{identifier-1}, provided that elementary item neither contains a @syntax{REDEFINES} clause in its definition nor belongs to a group item @i{subordinate to} @term{identifier-1} which contains a @syntax{REDEFINES} clause in its definition.
@p @item If the optional @syntaxidx{WITH FILLER} clause is included on the @statement{INITIALIZE}, then every FILLER elementary item subordinate to each @term{identifier-1} will be included as well, provided that elementary item neither contains a @syntax{REDEFINES} clause in its definition nor belongs to a group item @i{subordinate to} @term{identifier-1} which contains a @syntax{REDEFINES} clause in its definition..
@end enumerate
@item Once a field list has been determined, each item in that field list will be initialized as if an individual @syntaxref{MOVE} statement to that effect had been coded.  The rules for initialization are as follows:
@p @item If no @syntaxidx{VALUE}, @syntaxidx{REPLACING} or @syntaxidx{DEFAULT} clauses are coded, each member of the field list will be initialized as if the figurative constant @syntax{ZERO} (if the field list item is numeric or numeric-edited) or @syntax{SPACES} (otherwise) were being moved to it.
@p @item If a @syntax{VALUE} clause is specified on the @statement{INITIALIZE}, each qualifying member of the field list having a compile-time @syntaxref{VALUE} specified in it's definition will be initialized to that value.  Field list members with @syntax{VALUE} clauses will qualify for this treatment as follows:
@enumerate A
@p @item If the @syntax{ALL} keyword was specified on the @syntax{VALUE} clause, all members of the field list with @syntax{VALUE} clauses will qualify.
@p @item If @term{category-name-1} is specified instead of @syntax{ALL}, only those members of the field list with @syntax{VALUE} clauses that also meet the criteria set down for the specified @term{category-name} (see the list above) will qualify.
@p @item If you need to apply @syntax{VALUE} initialization to multiple @term{category-name-1} values, you will need to use multiple @syntax{INITIALIZE} statements.
@end enumerate
@item If a @syntax{REPLACING} clause is specified on the @statement{INITIALIZE}, each qualifying member of the field list that was not already initialized by a @syntax{VALUE} clause, if any, will be initialized to the specified @term{literal-1} or @term{identifier-1} value.
@p Only those as-yet uninitialized list members meeting the criteria set forth for the specified @term{category-name-2} will qualify for this initialization.
@p If you need to apply @syntax{REPLACING} initialization to multiple @term{category-name-2} values, you may repeat the syntax after the reserved word @syntax{REPLACING}, as necessary.
@p @item If a @syntax{DEFAULT} clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).
@p @item The following example may help your understanding of how the @statement{INITIALIZE} works.  The sample code makes use of the COBDUMP program to dump the storage that is (or is not) being initialized.  @xref{COBDUMP,COBDUMP,COBDUMP,gnucobsp,GnuCOBOL Sample Programs}, for a source and cross-reference listing of the COBDUMP program.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DemoInitialize.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Item-1.
    05 I1-A VALUE ALL '*'.
       10 FILLER                PIC X(1).
       10 I1-A-1                PIC 9(1) VALUE 9.
    05 I1-B                     USAGE BINARY-CHAR.
    05 I1-C                     PIC A(1) VALUE 'C'.
    05 I1-D                     PIC X/X VALUE 'ZZ'.
    05 I1-E                     OCCURS 2 TIMES PIC 9.
PROCEDURE DIVISION.
000-Main.
    DISPLAY "MOVE HIGH-VALUES TO Item-1"
        PERFORM 100-Init-Item-1
        CALL "COBDUMP" USING Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1"
        INITIALIZE Item-1
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 WITH @syntax{FILLER}"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 WITH @syntax{FILLER}
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 ALL TO VALUE"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 ALPHANUMERIC TO VALUE
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    DISPLAY "INITIALIZE Item-1 REPLACING NUMERIC BY 1"
        MOVE HIGH-VALUES TO Item-1
        INITIALIZE Item-1 REPLACING NUMERIC BY 1
        CALL "COBDUMP" USING Item-1
        PERFORM 100-Init-Item-1
        DISPLAY " "

    STOP RUN
    .

100-Init-Item-1.
    MOVE HIGH-VALUES TO Item-1
    .
@end example
@* When executed, this program produces the following output:
@p @smallexample
MOVE HIGH-VALUES TO Item-1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF FF FF FF FF FF FF FF FF                      .........

INITIALIZE Item-1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF 30 00 20 20 2F 20 30 30                      .0.  / 00

INITIALIZE Item-1 WITH @syntax{FILLER}
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 20 30 00 20 20 2F 20 30 30                       0.  / 00

INITIALIZE Item-1 ALL TO VALUE
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 2A 2A FF 43 5A 5A 20 FF FF                      **.CZZ ..

INITIALIZE Item-1 REPLACING NUMERIC BY 1
<-Addr-> Byte <---------------- Hexadecimal ----------------> <---- Char ---->
======== ==== =============================================== ================
00404058    1 FF 31 01 FF FF FF FF 31 31                      .1.....11
@end smallexample
@end enumerate
@comment *********************************************************************
@comment ** 6.17.23 INITIATE                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.23,INITIATE}
@diagram{INITIATE,PD-INITIATE,PD-INITIATE,None}@p The @statement{INITIATE} starts Report-Writer Control System (RWCS) processing for a report.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Each @term{report-name-1} must be the name of a report having an @syntaxrefalt{RD,REPORT SECTION} defined for it.
@p @item The file in whose @syntaxrefalt{FD,File/Sort-Description} a @syntax{REPORT @term{report-name-1}} clause exists must be open for @syntax{OUTPUT} or @syntax{EXTEND} at the time the @statement{INITIATE} is executed.  @xref{OPEN}, for more information on file open modes.
@p @item The @statement{INITIATE} will initialize all of the following for each report named on the statement:
@itemize @bullet
@p @item All sum counters, if any, will be set to 0
@p @item The report's @registerrefalt{LINE-COUNTER,Special Registers} will be set to 0
@p @item The report's @register{PAGE-COUNTER} will be set to 1
@end itemize
@item No report content will actually presented to the report file as a result of a successful @statement{INITIATE} --- that will not occur until the first @statementref{GENERATE} is executed.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.24 INSPECT                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.24,INSPECT}
@diagram{INSPECT,PD-INSPECT,PD-INSPECT,None}@p The @statement{INSPECT} is used to perform various counting and/or data-alteration operations against strings.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{INITIAL} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this words has no effect upon the program.
@p @item If a @syntaxidx{CONVERTING} clause is specified, neither the @syntaxidx{TALLYING} nor @syntaxidx{REPLACING} clauses may be used.
@p @item If either the @syntax{TALLYING} or @syntax{REPLACING} clauses are specified, the @syntax{CONVERTING} clause cannot be used.
@p @item If both the @syntax{TALLYING} and @syntax{REPLACING} clauses are specified, they must be specified in the order shown.
@p @item All literals and identifiers must be explicitly or implicitly defined as alphanumeric or alphabetic.
@p @item If @term{function-reference-1} is specified, it must be an invocation of an intrinsic function that returns a @i{string} result.  Additionally, only the @syntax{TALLYING} clause may be specified.
@p @item If @term{literal-1} is specified, only the @syntax{TALLYING} clause may be specified.
@comment Semantic Specifications:
@p @item Whichever is specified --- @term{literal-1}, @term{identifier-1} or @term{function-reference-1} --- that item will be referred to in the discussions that follows as the '@i{inspect subject}'.
@p @item The three optional clauses control the operation of this statement as follows:
@enumerate A
@p @item The @syntax{CONVERTING} clause replaces one or more individual characters found in the inspect subject with a different character in much the same manner as is possible with the @statementref{TRANSFORM}.
@p @item The @syntax{REPLACING} clause replaces one or more sub strings located in the inspect subject with a different, but equally-sized replacement sub string.  If you need to replace a sub string with another of a @i{different} length, consider using either the @intrinsicref{SUBSTITUTE} or the @intrinsicref{SUBSTITUTE-CASE}.
@p @item The @syntax{TALLYING} clause counts the number of occurrences of one or more strings of characters in the inspect subject.
@end enumerate
@item The optional @syntax{INITIAL} clauses may be used to limit the range of characters in the inspect subject that the  @syntax{CONVERTING}, @syntax{REPLACING} or @syntax{TALLYING} instruction in which they occur will apply.  We call this the '@i{target range}' of the inspect subject.  The target range is defined as follows:
@enumerate A
@p @item If there is no @syntax{INITIAL} clause specified, the target range is the entire inspect subject.
@p @item Either a @syntax{BEFORE} phrase, an @syntax{AFTER} phrase or both may be specified.  They may be specified in any order.
@p @item The starting point of the target range will be the first character following the sub string identified by the @syntax{AFTER} specification.  The ending point will be the last character immediately preceding the sub string identified by the @syntax{BEFORE} specification.
@p @item If no @syntax{AFTER} is specified, the first character position of the target range will be character position #1 of the inspect subject.
@p @item If no @syntax{BEFORE} is specified, the last character position of the target range will be the last character position of the inspect subject.
@end enumerate
@item The following points apply to the use of the @syntax{TALLYING} clause:
@enumerate A
@p @item While there will typically be only be a single set of counting instructions on an @syntax{INSPECT}:
@p @example
INSPECT Character-String
    TALLYING C-ABC FOR ALL "ABC"
@end example
@* There could be multiple counting instructions specified:
@p @example
INSPECT Character-String
    TALLYING C-ABC FOR ALL "ABC"
             C-BCDE FOR ALL "BCDE"
@end example
@* When there @i{are} multiple instructions, the one specified first will take priority over the one specified second, (and so forth) as the @syntax{INSPECT} proceeds forward through the inspect subject, character-by-character.
@p With the above example, if the inspect subject were @syntax{--ABCDEF----BCDEF--}, the final result of the counting would be that C-ABC would be incremented by 1 while C-BCDE would be incremented only once; although the human eye clearly sees two "BCDE" sequences, the @syntax{INSPECT ... TALLYING} would only "see" the second --- the first would have been processed by the first (higher-priority) counting instruction.
@p @item Each set of counting instructions contains the following information:
@enumerate a
@p @item A target range, specified by the presence of an @syntax{AFTER INITIAL} and/or @syntax{BEFORE INITIAL} clause; the rules for specifying target ranges were covered previously.
@p @item A Target Sub string --- this is a sequence of characters to be located somewhere in the inspect subject and counted.  Target sub strings may be defined as a literal value (figurative constants are allowed) or by the contents of an identifier.  If the target sub string is specified as a figurative constant, it will be assumed to have a length of one (1) character.  The keywords before the literal or identifier control how many target sub strings could be identified from that replacement instruction, as follows:
@p @syntax{ALL} --- identifies every possible target sub string that occurs within the target range.  There are three occurrences of @syntax{ALL 'XX'} found in @syntax{aXXabbXXccXXdd}.
@p @syntax{LEADING} --- identifies only an occurrence of the target sub string found either at the first character position of the target range or immediately following a previously-found occurrence.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there is one occurrence of @syntax{LEADING 'a'} (the first character).
@p @syntax{TRAILING} --- identifies only an occurrence of the target sub string found either at the very end of the target range or toward the end, followed by nothing but other occurrences.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there are two occurrences of @syntax{TRAILING 'd'}.
@p The @syntax{CHARACTERS} option will match any one single character, regardless of what that character is.
@end enumerate
@item @term{identifier-2} will be incremented by 1 each time the target sub string is found within the target range of the inspect subject.  The @syntax{INSPECT} statement @i{will not} zero-out @term{identifier-2} at the start of execution of the @syntax{INSPECT} --- it is the programmer's responsibility to ensure that all @term{identifier-2} data items are properly initialized to the desired starting values prior to execution of the @syntax{INSPECT}.
@end enumerate
@item The following points apply to the use of the @syntax{REPLACING} clause:
@enumerate A
@p @item While there will typically be only be a single set of replacement instructions on an @syntax{INSPECT}:
@p @example
INSPECT Character-String
    REPLACING ALL "ABC" BY "DEF"
@end example
@* There could be multiple replacement instructions:
@p @example
INSPECT Character-String
    REPLACING ALL "ABC" BY "DEF"
              ALL "BCDE" BY "WXYZ"
@end example
@* When there @i{are} multiple replacement instructions, the one specified first will take priority over the one specified second, (and so forth) as the @syntax{INSPECT} proceeds forward through the inspect subject, character-by-character.
@p With the above example, if the inspect subject were @syntax{--ABCDEF----BCDEF--}, the final result of the replacement would be @syntax{--DEFDEF----WXYZF--}.
@p @item Each set of replacement instructions contains the following information:
@enumerate a
@p @item A target range, specified by the presence of an @syntax{AFTER INITIAL} and/or @syntax{BEFORE INITIAL} clause; the rules for specifying target ranges were covered previously.
@p @item A Target Sub string --- this is a sequence of characters to be located somewhere in the inspect subject and subsequently replaced with a new value.  Target sub strings, which are specified before the @syntax{BY} keyword, may be defined as a literal value (figurative constants are allowed) or by the contents of an identifier.  If the target sub string is specified as a figurative constant, it will be assumed to have a length of one (1) character.  The keywords before the literal or identifier control how many target sub strings could be identified from that replacement instruction, as follows:
@p @syntax{ALL} --- identifies every possible target sub string that occurs within the target range.  There are three occurrences of @syntax{ALL 'XX'} found in @syntax{aXXabbXXccXXdd}.
@p @syntax{FIRST} --- the first occurrence of the target sub string found within the target range.  The @syntax{FIRST 'XX'} found in @syntax{aXXabbXXccXXdd} would be the one found between the "a" and "b" characters.
@p @syntax{LEADING} --- an occurrence of the target sub string found either at the first character position of the target range or immediately following a previously-found occurrence.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there is one occurrence of @syntax{LEADING 'a'} (the first character).
@p @syntax{TRAILING} --- an occurrence of the target sub string found either at the very end of the target range or toward the end, followed by nothing but other occurrences.  There are no occurrences of @syntax{LEADING 'XX'} found in @syntax{aXXabbXXccXXdd}, but there are two occurrences of @syntax{TRAILING 'd'}.
@p The @syntax{CHARACTERS} option will match any one single character.  When you use this option, the replacement sub string (see the next item) must be exactly one character in length.
@p @item A Replacement Sub string --- this is the sequence of characters that should replace the target sub string.  Replacement sub strings are specified after the @syntax{BY} keyword.  They too may be specified as a literal, either with or without an @syntax{ALL} prefix (again, figurative constants are allowed) or the value of an identifier.  If a figurative constant is coded, the @syntax{ALL} keyword will be assumed, even if it wasn't specified.  Literals without @syntax{ALL} will either be truncated or padded with spaces on the right to match the length of the target sub string.  Literals with @syntax{ALL} or figurative constants will be repeated as necessary to match the length of the target sub string.  Identifiers specified as replacement sub strings must be defined with a length equal to that of the target sub string.
@end enumerate
@end enumerate
@item When both @syntax{REPLACING} and @syntax{TALLYING} are specified:
@enumerate A
@p @item The @syntax{INSPECT} statement will make a single pass through the sequence of characters comprising the inspect subject.  As the pointer to the current inspect target character reaches a point where it falls within the explicit or implicit target ranges specified on the operational instructions of the two clauses, the actions specified by those instructions will become eligible to be taken.  As the character pointer reaches a point where it falls past the end of target ranges, the instructions belonging to those target ranges will become disabled.
@p @item At any point in time, there may well be multiple@syntax{REPLACING} and/or @syntax{TALLYING} operational instructions  active.  Only one of the @syntax{TALLYING} and one of the @syntax{REPLACING} instructions (if any) can be executed for any one character pointer position.  In each case, it will be the first of the instructions in each category that produces a match with it's target string specification.
@p @item When both a @syntax{TALLYING} and a @syntax{REPLACING} instruction have been selected for execution, the @syntax{TALLYING} instruction will be executed first.  This guarantees that @syntax{TALLYING} will compute occurrences based upon the @i{initial} value of the inspect subject before any replacements occur.
@end enumerate
@item The following points apply to the use of the @syntax{CONVERTING} clause:
@enumerate A
@p @item A @syntax{CONVERTING} clause performs a series of single-character substitutions against a data item in much the same manner as is possible with the @statementref{TRANSFORM}.
@p @item Unlike the @syntax{TALLYING} and @syntax{REPLACING} clauses, both of which may have multiple operations specified, there may be only one @syntax{CONVERTING} operation per @syntax{INSPECT}.
@p @item If the length of @term{literal-7} or @term{identifier-8} (the "from" string) @i{exceeds} the length of @term{literal-8} or @term{identifier-9} (the "to" string), then the "to" string will be assumed to be padded to the right with enough spaces to make it the same length as the "from" string.
@p @item If the length of the "from" string @i{is less than} the length of the "to" string, then the "to" string will be truncated to the length of the "from" string.
@p @item Each character, in turn, within the "from" string will be searched for in the target range of the inspect subject.  Each located occurrence will be replaced by the corresponding character of the "to" string.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.25 MERGE                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.25,MERGE}
@diagram{MERGE,PD-MERGE-Info,PD-MERGE-TeX,PD-DUPLICATES}@p The @statement{MERGE} merges the contents of two or more files that have each been pre-sorted on a set of specified identical keys.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{sort-file-1} named on the @statement{MERGE} must be defined using a sort description (@syntaxrefalt{SD,File/Sort-Description}).  This file is referred to in the remainder of this discussion as the "merge work file".
@p @item Each @term{file-name-1}, @term{file-name-2} and @term{file-name-3} (if specified) must reference @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{ORGANIZATION SEQUENTIAL} files.  These files must be defined using a file description (@syntaxrefalt{FD,File/Sort-Description}).
@p @item The @term{identifier-1} @dots{} field(s) must be defined as field(s) within a record of @term{sort-file-1}.
@p @item The record descriptions of @term{file-name-1}, @term{file-name-2}, @term{file-name-3} (if any) and @term{sort-file-1} are assumed to be identical in layout and size.  While the actual data names used for fields in these files' records may differ, the structure of records, @syntaxref{PICTURE} of fields, @syntaxref{USAGE} of fields, size of fields and location of fields within the records should match field-by-field across all files, at least as far as the @syntax{KEY} fields are concerned.
@p @item A common programming technique when using the @statement{MERGE} is to define the records of all files involved as simple elementary items of the form @syntax{01 record-name PIC X(n).} where n is the record size.  The only file where records are actually described in detail would then be @term{sort-file-1}.
@p @item The following rules apply to the files named on the @syntax{USING} clause:
@enumerate A
@p @item None of them may be open at the time the @syntax{MERGE} is executed.
@p @item Each of those files is assumed to be already sorted according to the specifications set forth on the @statement{MERGE}'s @syntaxidx{KEY} clause.
@p @item No two of those files may be referenced on a @syntaxref{SAME RECORD AREA}, @syntax{SAME SORT AREA} or @syntax{SAME SORT-MERGE AREA} statement.
@end enumerate
@item The merging process is as follows:
@enumerate A
@p @item As the @statement{MERGE} begins execution, the first record in each of the @syntaxidx{USING} files is read automatically.
@p @item As the @statement{MERGE} executes, the current record from each of the @syntax{USING} files is examined and compared to each other according to the rules set forth by the @syntax{KEY} clause and the alphabet (@pxref{Alphabet-Name-Clause}) specified on the @syntaxidx{COLLATING SEQUENCE} clause.  The record that should be next in sequence will be written to the merge work file and the @syntax{USING} file from which that record came will be read so that its next record is available.  As end-of-file conditions are reached on @syntax{USING} files, those files will be excluded from further processing --- processing continues with the remaining files until all the contents of all of them have been exhausted.
@p @item After the merge work file has been populated, the merged data will be written to each @term{file-name-3} if the @syntaxidx{GIVING} clause was specified, or will be processed by utilizing an @syntaxidx{OUTPUT PROCEDURE}.
@p @item When @syntax{GIVING} is specified, none of the @term{file-name-3} files can be open at the time the @statement{MERGE} is executed.
@p @item When an output procedure is used, the procedure(s) specified on the @syntax{OUTPUT PROCEDURE} clause will be invoked as if by a procedural @syntaxrefalt{PERFORM,Procedural PERFORM} statement with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Merged records may be read from the merge work file --- one at a time --- within the output procedure using the @syntaxref{RETURN} statement.
@p A @statementref{GO TO} that transfers control out of the output procedure will terminate the @statement{MERGE} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an output procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the merge work file are lost.  You may, however, re-execute the @statement{MERGE} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A MERGE, OR RE-STARTING A PREVIOUSLY-CANCELLED MERGE IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An output procedure should be terminated in the same way a procedural @statement{PERFORM} would be.  Usually, this action will be taken once the @statement{RETURN} indicates that all records in the merge work file have been processed, but termination could occur at @i{any} time --- via an @statementref{EXIT} --- if required.
@p Neither a file-based @statementrefalt{SORT,File-Based SORT} nor another @statement{MERGE} may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.
@p @item Once the output procedure terminates, or the last @term{file-name-3} file has been populated with merged data, the output phase --- and the @statement{MERGE} itself --- is complete.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.26 MOVE                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.26,MOVE}
@menu
* 6.17.26.1: Simple MOVE
* 6.17.26.2: MOVE CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 6.17.26.1 Simple MOVE                                           **
@comment *********************************************************************
@newunit{6.17.26.1,Simple MOVE}
@diagram{Simple MOVE,PD-MOVE-1,PD-MOVE-1,None}@p The Simple @statement{MOVE} moves a specific value to one or more receiving data items.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The @statement{MOVE} will replace the contents of one or more receiving data items (@term{identifier-2}) with a new value --- the one specified by @term{literal-1} or @term{identifier-1}.
@p @item Only numeric data can be moved to a numeric or numeric-edited @term{identifier-2}.  A @syntax{MOVE} involving numeric data will perform any necessary format conversions that might be necessary due to differing @syntaxref{USAGE} specifications.
@p @item The contents of the @term{identifier-1} data item will not be changed, unless that same data item appears as an @term{identifier-2}.  Note that such situations will cause a warning message to be issued by the compiler, if warning messages are enabled.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.26.2 MOVE CORRESPONDING                                    **
@comment *********************************************************************
@page
@newunit{6.17.26.2,MOVE CORRESPONDING}
@diagram{MOVE CORRESPONDING,PD-MOVE-2,PD-MOVE-2,None}@p The @statement{MOVE CORRESPONDING} similarly-named items from one group item to another.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{CORRESPONDING} may be abbreviated as @syntax{CORR}.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for a discussion of how corresponding matches between two group items are established.
@p @item When corresponding matches are established, the effect of a @syntax{MOVE CORRESPONDING} on those matches will be as if a series of individual @syntax{MOVE}s were done --- one for each match.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.27 MULTIPLY                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.27,MULTIPLY}
@menu
* 6.17.27.1: MULTIPLY BY
* 6.17.27.2: MULTIPLY GIVING
@end menu
@comment *********************************************************************
@comment ** 6.17.27.1 MULTIPLY BY                                           **
@comment *********************************************************************
@newunit{6.17.27.1,MULTIPLY BY}
@diagram{MULTIPLY BY,PD-MULTIPLY-1,PD-MULTIPLY-1,None}@p The @statement{MULTIPLY BY} computes the product of one or more data items (@term{identifier-2}) and either a numeric literal or another data item.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric un-edited data items; @term{literal-1} must be a numeric literal.
@p @item The product of @term{identifier-1} or @term{literal-1} and each @term{identifier-2}, in turn, will be computed and moved to each of the @term{identifier-2} data items, replacing the prior contents.
@p @item The value of @term{identifier-1} is not altered, unless that same data item appears as an @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.27.2,MULTIPLY GIVING                                       **
@comment *********************************************************************
@page
@newunit{6.17.27.2,MULTIPLY GIVING}
@diagram{MULTIPLY GIVING,PD-MULTIPLY-2,PD-MULTIPLY-2,None}@p The @statement{MULTIPLY GIVING} computes the product of two literals and/or data items and saves that result in one or more other data items.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric un-edited data items; @term{literal-1} and @term{literal-2} must be numeric literals.
@p @item The product of @term{identifier-1} or @term{literal-1} and @term{identifier-2} or @term{literal-2} will be computed and moved to each of the @term{identifier-3} data items, replacing their old contents.
@p @item Neither the value of @term{identifier-1} nor @term{identifier-2} will be altered, unless either appears as an @term{identifier-3}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.28 OPEN                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.28,OPEN}
@diagram{OPEN,PD-OPEN,PD-OPEN,PD-OPEN}@p The @statement{OPEN} makes one or more files described in your program available for use.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{OTHER} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @syntax{SHARING} and @syntax{WITH LOCK} clauses may not both be specified in the same @statement{OPEN}.
@comment Semantic Specifications:
@p @item Any file defined in a GnuCOBOL program must be successfully opened before it or any of it's record descriptions may be referenced on:
@p A @statementref{CLOSE}
@p A @statementref{DELETE}
@p A @statementref{READ}
@p A @statementref{REWRITE}
@p A @statementref{START}
@p An @statementref{UNLOCK}
@p A @statementref{WRITE}
@p @item Any attempt to open a file that is already open will fail with a file status of 41 (@pxref{File Status Codes}).  This is a fatal error that will terminate the program.
@p @item Any open failure (including status 41) may be trapped using @syntaxref{DECLARATIVES} or an error procedure established using the @subpgmref{CBL_ERROR_PROC} built-in subroutine.  When either of these trap routines @i{exit}, however, the GnuCOBOL runtime system will still terminate the program after your trap logic is executed.  Ultimately, you cannot recover from an open failure.
@p @item @anchoridx{File OPEN Modes}The @syntaxidx{INPUT}, @syntaxidx{OUTPUT}, @syntaxidx{I-O} and @syntaxidx{EXTEND} open modes inform GnuCOBOL of the manner in which you wish to use the file, as follows:
@table @asis
@p @item @syntax{INPUT}
@p You may only read the existing contents of the file --- only the @syntax{CLOSE}, @syntax{READ}, @syntax{START} and @syntax{UNLOCK} statements will be allowed.  This enforcement takes place at execution time, not compilation time.
@p @item @syntax{OUTPUT}
@p You may only write new content (which will completely replace any previous file contents) to the file --- only the @syntax{CLOSE}, @syntax{UNLOCK} and @syntax{WRITE} statements will be allowed.  This enforcement takes place at execution time, not compilation time.
@p @item @syntax{I-O}
@p You may perform any operation you wish against the file --- all file I/O statements will be allowed.
@p @item @syntax{EXTEND}
@p You may only write new content (which will be appended after the previously existing file contents) to the file --- only the @syntax{CLOSE}, @syntax{UNLOCK} and @syntax{WRITE} statements will be allowed.  This enforcement takes place at execution time, not compilation time.  You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.
@end table
@item The @syntaxidx{SHARING} clause informs the GnuCOBOL file runtime modules how you are willing to co-exist with any other GnuCOBOL programs that may attempt to open the same file after your program does.  @xref{File Sharing}, for an explanation of the @syntax{SHARING} clause.
@p @item The @syntaxidx{WITH LOCK} option will be functional only if your GnuCOBOL build can support it.  GnuCOBOL built for MinGW or native Windows will not, because the Unix "fcntl() primitive doesn't exist in those environments.  GnuCOBOL built for Cygwin or Unix will.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.29 PERFORM                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.29,PERFORM}
@menu
* 6.17.29.1: Procedural PERFORM
* 6.17.29.2: Inline PERFORM
* 6.17.29.3: VARYING
@end menu
@comment *********************************************************************
@comment ** 6.17.29.1 Procedural PERFORM                                    **
@comment *********************************************************************
@newunit{6.17.29.1,Procedural PERFORM}
@diagram{Procedural PERFORM,PD-PERFORM-1,PD-PERFORM-1,None}@p This format of the @statement{PERFORM} is used to transfer control to one or more procedures, which will return control back when complete.  Execution of the procedure(s) can be done a single time, multiple times, repeatedly until a condition becomes TRUE or forever (with some way of breaking out of the control of the @syntax{PERFORM} or of halting program execution within the procedure(s)).
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{WITH} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item The reserved word and phrase @syntax{FOREVER} and @syntax{UNTIL EXIT} are interchangeable.
@comment Semantic Specifications:
@p @item  Both @term{procedure-name-1} and @term{procedure-name-2} must be procedure division sections or paragraphs defined in the same program as the @syntax{PERFORM} statement.  If @term{procedure-name-2} is specified, it must follow @term{procedure-name-1} in the program's source code.
@p @item The @define{perform scope} is defined as being the statements within @term{procedure-name-1}, the statements within @term{procedure-name-2} and all statements in all procedures defined between them.
@p @item @term{literal-1} must be a numeric literal or a reference to a function that returns a numeric value.  The value must be an integer greater than zero.
@p @item @term{identifier-1} must be an elementary un-edited numeric data item with an integer value greater than zero.
@p @item Without the @syntaxidx{UNTIL}, @syntaxidx{UNTIL EXIT}, @syntaxidx{TIMES}, @termrefalt{VARYING-Clause,VARYING} or @syntaxidx{FOREVER} clauses, the code within the perform scope will be executed once, after which control will return to the statement following the @syntax{PERFORM}.
@p @item  The @syntax{FOREVER} option will repeatedly execute the code within the perform scope with no conditions defined for termination of the repetition --- it will be up to the programmer to include an @statementrefalt{EXIT SECTION,EXIT} or @statement{EXIT PARAGRAPH} within the procedure(s) being performed that will break out of the loop.
@p @item The @syntax{TIMES} option will repeat the execution of the code within the perform scope a fixed number of times.  When the @syntax{PERFORM} statement begins execution, an internal repeat counter (not accessible to the programmer) will be set to the value of @term{literal-1} or the value within @term{identifier-1}.
@p If the counter has a value greater than zero, the statement(s) within the @syntax{PERFORM} scope will be executed, after which the counter will be decremented by 1 with each repetition.  Once that counter reaches zero, repetition will cease and control will fall into the next statement following the @syntax{PERFORM}.
@p If the @term{identifier-1} option was used, altering the value of that data item within the perform scope will @i{not} affect the repetition count.
@p @item The @syntax{UNTIL @term{conditional-expression-1}} option will repeat the code within the perform scope until the specified conditional expression evaluates to a TRUE value.
@p @item The optional @syntaxidx{WITH TEST} clause will control whether @syntax{UNTIL} testing occurs @syntax{BEFORE} the statements within the perform scope are executed on each iteration (creating the possibility --- if @term{conditional-expression-1} is initially TRUE --- that the statements within the perform scope will never be executed) or @syntaxidx{AFTER} (guaranteeing the statements within the perform scope will be executed at least once).
@p The default, if this clause is absent, is @syntax{WITH TEST BEFORE}.
@p This clause may not be coded when the @syntax{TIMES} clause is used.
@p @item The optional @term{VARYING-Clause} is a mechanism that creates an advanced loop-management mechanism complete with one or more numeric data items being automatically incremented (or decremented) on each loop iteration as well as the termination control of an @syntax{UNTIL} clause.  @xref{VARYING}, for the details.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.29.2 Inline PERFORM                                        **
@comment *********************************************************************
@page
@newunit{6.17.29.2,Inline PERFORM}
@diagram{Inline PERFORM,PD-PERFORM-2,PD-PERFORM-2,None}@p This format of the @statement{PERFORM} is identical in operation to the procedural @syntax{PERFORM}, except for the fact that the statement(s) comprising the perform scope (@term{imperative-statement-1}) (@pxref{Imperative Statement}) are now specified in-line with the @syntax{PERFORM} code rather than in procedures located elsewhere within the program.
@comment *********************************************************************
@comment ** 6.17.29.3 VARYING                                               **
@comment *********************************************************************
@page
@newunit{6.17.29.3,VARYING}
@diagram{VARYING,PD-PERFORM-VARYING,PD-PERFORM-VARYING,None}@p The @syntax{VARYING} clause, available on both formats of the @syntax{PERFORM} statement, is a looping mechanism that allows for the specification of one or more numeric data items that will be initialized to a programmer-specified value and automatically incremented by another programmer-specified value after each loop iteration.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item All identifiers used in a @term{VARYING-Clause} must be elementary, un-edited numeric data items.  All literals must be numeric literals.
@p @item The following points describe the sequence of events that take place as a result of the @syntax{VARYING} portion of the clause:
@enumerate A
@p @item When the @syntax{PERFORM} begins execution, the @syntax{FROM} value will be moved to @term{identifier}.
@p @item If the @syntax{PERFORM} specifies or implies @syntax{WITH TEST BEFORE}, @term{conditional-expression-1} will be evaluated and processing of the @syntax{PERFORM} will halt if the expression evaluates to TRUE.  If @syntax{WITH TEST BEFORE} was @i{not} specified or implied, or if the conditional expression evaluated to FALSE, processing proceeds with step (C).
@p @item The statements within the perform scope will be executed.  If a @syntax{GO TO} executed within the perform scope transfers control to a point outside the perform scope, processing of the @syntax{PERFORM} will halt.
@p @item When the statements within the perform scope terminate the loop iteration, by@dots{}
@itemize @bullet
@p @item @dots{}allowing the flow of execution to attempt to fall past the last statement in the perform scope, or@dots{}
@p @item @dots{}executing an @statementrefalt{EXIT PERFORM CYCLE,EXIT}, or@dots{}
@p @item @dots{}executing an @statement{EXIT PARAGRAPH} or @statement{EXIT SECTION} when there is only one paragraph (or section) in the perform scope ( this option only applies to a procedural @syntax{PERFORM})
@end itemize
@* Control will return back to the @syntax{PERFORM}, where --- if @syntax{WITH TEST AFTER} was specified --- @term{conditional-expression-1} will be evaluated and processing of the @syntax{PERFORM} will halt if the expression evaluates to TRUE.  If @syntax{WITH TEST AFTER} was @i{not} specified, or if the conditional expression evaluated to FALSE, processing continues with the next step.
@p @item The @syntax{BY} value, if any, will be added to @term{identifier-2}.  If no @syntax{BY} is specified, @term{identifier-2} will be unaffected.  You are always free to modify the value of @term{identifier-2} yourself within the perform scope.
@p @item Return to step (C).
@end enumerate
@item Most @term{VARYING-Clause}s have no @syntax{AFTER} specified.  Those that do, however, are establishing a loop-within-a-loop situation where the process described above in steps (A) through (F) will take place from the @syntax{AFTER}, and those six processing steps actually replace step (C) of the @syntax{VARYING}.  This "nesting" process can continue indefinitely, with each additional @syntax{AFTER}.
@end enumerate
@* This is the point where an example should really help you see this at work.  Observe the following code which defines a two-dimensional (3 row by 4 column) table and a pair of numeric data items to be used to subscript references to each element of the table:
@p @example
01  PERFORM-DEMO.
    05 PD-ROW             OCCURS 3 TIMES.
       10 PD-COL          OCCURS 4 TIMES
          15 PD           PIC X(1).
01  PD-Col-No             PIC 9 COMP.
01  PD-Row-No             PIC 9 COMP.
@end example
@* Let's say the 3x4 "grid" defined by the above structure has these values:
@p @example
A B C D
E F G H
I J K L
@end example
@* This code will display @syntax{ABCDEFGHIJKL} on the console output window:
@p @example
PERFORM WITH TEST AFTER
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* While this code will display @syntax{AEIBFJCGKDHL} on the console output window:
@p @example
PERFORM WITH TEST AFTER
        VARYING PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
          AFTER PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* While we're looking at sample code, this code displays @syntax{ABCEFG}:
@p @example
PERFORM
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No = 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No = 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* By removing the @syntax{WITH TEST} clause, the statement is now assuming @syntax{WITH TEST BEFORE}.  Since testing now happens @i{before} the @statement{DISPLAY} gets executed, when PD-Row-No is 3 and PD-Col-No is 4 the @statement{DISPLAY} won't be executed.
@p Most COBOL programmers, when using @syntax{WITH TEST BEFORE} explicitly or implicitly have developed the habit of using ">" rather than "=" on @syntax{UNTIL} clauses.  This would make the sample code:
@p @example
PERFORM
        VARYING PD-Row-No FROM 1 BY 1 UNTIL PD-Row-No > 3
          AFTER PD-Col-No FROM 1 BY 1 UNTIL PD-Col-No > 4
    DISPLAY PD (PD-Row-No, PD-Col-No) WITH NO ADVANCING
END-PERFORM
@end example
@* With this change, @syntax{ABCDEFGHIJKL} is once again displayed.
@comment *********************************************************************
@comment ** 6.17.30 READ                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.30,READ}
@menu
* 6.17.30.1: Sequential READ
* 6.17.30.2: Random READ
@end menu
@comment *********************************************************************
@comment ** 6.17.30.1 Sequential READ                                       **
@comment *********************************************************************
@newunit{6.17.30.1,Sequential READ}
@diagram{Sequential READ,PD-READ-1,PD-READ-1,None}@p This form of the @statement{READ} retrieves the next (or previous) record from a file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AT}, @syntax{RECORD} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @term{file-name-1} file @i{must} have been defined via an @syntaxrefalt{FD,File/Sort-Description}, not an @syntax{SD}.
@comment Semantic Specifications:
@p @item The @term{file-name-1} file must currently be open for @syntaxrefalt{INPUT,File OPEN Modes} or @syntax{I-O}.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with an @syntax{ACCESS MODE RANDOM}, this statement cannot be used.
@p @item If @term{file-name-1} was specified as @syntax{ACCESS MODE SEQUENTIAL}, this is the @i{only} format of the @statement{READ} that is available.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with @syntax{ACCESS MODE DYNAMIC}, this statement as well as a random @syntaxrefalt{READ,Random READ} may be used.
@p @item The keywords @syntaxidx{NEXT} and @syntaxidx{PREVIOUS} specify what direction of "travel" the reading process will take through the file.  If neither is specified, @syntax{NEXT} is assumed.
@p @item The @syntax{PREVIOUS} option is available only for @syntax{ORGANIZATION INDEXED} files.
@p @item When reading any sequential (any organization) or relative file, the "next" direction refers to the physical sequence of records in the file.  When reading an indexed file, the "next" and "previous" directions refer to the sequence of primary or alternate record key values in the file's records, regardless of where the records physically occur within the file.
@p @item The minimal statement @syntax{READ @term{file-name-1}} is perfectly legal according to @i{both} READ formats.  For that reason, when @syntax{ACCESS MODE DYNAMIC} has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a @i{sequential} @syntax{READ}, you must add either @syntax{NEXT} or @syntax{PREVIOUS} to the statement (otherwise it will be treated as a random @syntax{READ}).
@p @item A successful sequential READ will retrieve the next available record from @term{file-name-1}, in either a "next" or "previous" direction from the most-recently-read record, depending upon the use of the @syntax{NEXT} or @syntax{PREVIOUS} option.  The newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's @syntax{FD}.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item When an @syntax{ORGANIZATION RELATIVE} file has been successfully read, the file's @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the retrieved record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{AT END} clause, if coded, is used to detect and react to the failure of an attempt to retrieve another record from the file due to an end-of-file (i.e. no more records) condition.
@p @item The optional @syntax{NOT AT END} clause, if coded, will check checking for a file status value of 00.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.30.1 Random READ                                           **
@comment *********************************************************************
@page
@newunit{6.17.30.2,Random READ}
@diagram{Random READ,PD-READ-2,PD-READ-2,None}@p This form of the @statement{READ} retrieves an arbitrary record from an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS}, @syntax{KEY} (on the @syntax{INVALID} and @syntax{NOT INVALID} clauses), @syntax{RECORD} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The @term{file-name-1} file @i{must} have been defined via an @syntaxrefalt{FD,File/Sort-Description}, not an @syntax{SD}.
@comment Semantic Specifications:
@p @item The @term{file-name-1} file must currently be open for @syntaxrefalt{INPUT,File OPEN Modes} or @syntax{I-O}.
@p @item If the @syntax{ACCESS MODE} of @term{file-name-1} is @syntax{SEQUENTIAL}, or the @syntax{ORGANIZATION} of the file is any form of sequential, this format of the @statement{READ} cannot be used.
@p @item If the @syntax{ACCESS MODE} of @term{file-name-1} is @syntax{RANDOM}, this is the @i{only} format of the @statement{READ} that is available.
@p @item If @term{file-name-1} is an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file with @syntax{ACCESS MODE DYNAMIC}, this statement as well as a sequential @syntaxrefalt{READ,Sequential READ} may be used.
@p @item The minimal statement @syntax{READ @term{file-name-1}} is perfectly legal according to @i{both} READ formats.  For that reason, when @syntax{ACCESS MODE DYNAMIC} has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a @i{random} @syntax{READ}, you must omit the @syntax{NEXT} or @syntax{PREVIOUS} available to the sequential format of the @statement{READ} to ensure the statement @i{will} be treated as a random @syntax{READ}.
@p @item The optional @syntaxidx{KEY} clause tells the compiler how a record is to be located in the file.  If the clause is absent, and@dots{}
@enumerate A
@p @item @dots{}if the file is an @syntax{ORGANIZATION RELATIVE} file, the contents of the field declared as the file's @syntax{RELATIVE KEY} will be used to identify a record, otherwise@dots{}
@p @item @dots{}if the file is an @syntax{ORGANIZATION INDEXED} file, the contents of the field declared as the file's @syntax{RECORD KEY} will be used to identify a record.
@end enumerate
@item But, if the @syntax{KEY} clause @i{is} specified, and@dots{}
@enumerate A
@p @item @dots{}if the file is an @syntax{ORGANIZATION RELATIVE} file, the contents of @term{identifier-2} will be used as the relative record number of the record to be accessed --- @term{identifier-2} need not be the @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field of the file (although it could be if you wish).
@p @item @dots{}if the file is an @syntax{ORGANIZATION INDEXED} file, @term{identifier-2} @i{must} be the @syntaxrefalt{RECORD KEY,ORGANIZATION INDEXED} or one of the file's @syntax{ALTERNATE RECORD KEY} fields (if any) --- the current contents of that field will identify the record to be accessed.  If an alternate record key is used, and that key allows duplicate values, the record accessed will be the @i{first} one having that key value.
@end enumerate
@item Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's @syntax{FD}.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item When an @syntax{ORGANIZATION RELATIVE} file has been successfully read, the file's @syntaxrefalt{RELATIVE KEY,ORGANIZATION RELATIVE} field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the retrieved record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.31 READY TRACE                                             **
@comment *********************************************************************
@page
@newsubsection{6.17.31,READY TRACE}
@diagram{READY TRACE,PD-READY-TRACE,PD-READY-TRACE,None}@p The @statement{READY TRACE} turns procedure or procedure-and-statement tracing on.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item In order for this statement to be functional, tracing code must have been generated into the compiled program using either the @switchidx{-ftrace} (procedures only) or @switch{-ftraceall} (procedures and statements).
@p @item Tracing may be turned off at any point by executing the @statementref{RESET TRACE}.
@p @item The @envvarruntimeref{COB_SET_TRACE} provides another way to control tracing.  If this environment variable is set to a value of "Y" prior to the start of program execution, tracing starts at the point the program begins execution, as if @syntax{READY TRACE} were the first executed statement.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.32 RELEASE                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.32,RELEASE}
@diagram{RELEASE,PD-RELEASE,PD-RELEASE,None}@p The @statement{RELEASE} adds a new record to a sort work file.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item This statement is valid only within the @syntax{INPUT PROCEDURE} of a file-based @statementrefalt{SORT,File-Based SORT}.
@p @item The specified @term{record-name-1} must be a record defined to the sort description (@syntaxrefalt{SD,File/Sort-Description}) of the sort work file being processed by the current sort.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the @term{file-name-1}.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{RELEASE}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.33 RESET TRACE                                             **
@comment *********************************************************************
@page
@newsubsection{6.17.33,RESET TRACE}
@diagram{RESET TRACE,PD-RESET-TRACE,PD-RESET-TRACE,None}@p The @statement{RESET TRACE} turns procedure or procedure-and-statement tracing off.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item By default, procedure and procedure-and-statement tracing is off as programs begin execution.  The @statementref{READY TRACE} can be used to turn tracing on.
@p @item In order for this statement to be functional, tracing code must have been generated into the compiled program using either the @switchidx{-ftrace} (procedures only) or @switchidx{-ftraceall} (procedures and statements).
@p @item The @envvarruntimeref{COB_SET_TRACE} provides another way to control tracing.  If this environment variable is set to a value of "Y" prior to the start of program execution, tracing started at the point the program begins execution, as if @syntax{READY TRACE} were the first executed statement.  The @syntax{RESET TRACE} statement, if executed, will then turn off tracing.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.34 RETURN                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.34,RETURN}
@diagram{RETURN,PD-RETURN,PD-RETURN,None}@p The @statement{RETURN} reads a record from a sort- or merge work file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{AT} and @syntax{RECORD} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @statement{RETURN} is valid only within the @syntax{OUTPUT PROCEDURE} of a file-based @syntaxrefalt{SORT,File-Based SORT} or a @statementref{MERGE} statement.
@p @item The @term{sort-file-name-1} file must be a sort- or merge work file defined with a @syntaxrefalt{SD,File/Sort-Description}, not an @syntax{FD}.
@p @item A successful @syntax{RETURN} will retrieve the next available record from @term{sort-file-name-1}.  The newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file's SD.  If the optional @syntaxidx{INTO} clause is present, a copy of the just-retrieved record will be automatically moved to @term{identifier-1}.
@p @item The mandatory @syntax{AT END} clause is used to detect and react to the failure of an attempt to retrieve another record from the file due to an end-of-file (i.e. no more records) condition.
@p @item The optional @syntax{NOT AT END} clause, if coded, will check checking for a file status value of 00.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.35 REWRITE                                                 **
@comment *********************************************************************
@page
@newsubsection{6.17.35,REWRITE}
@diagram{REWRITE,PD-REWRITE,PD-REWRITE,None}@p The @statement{REWRITE} replaces a logical record on a disk file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{KEY} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item The @term{record-name-1} specified on the statement must be defined as an 01-level record subordinate to the File Description (@syntaxrefalt{FD,File/Sort-Description}) of a file that is currently open for @syntaxrefalt{I-O,File OPEN Modes}.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the @term{file-name-1}.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{REWRITE}.
@p @item This statement may not be used with @syntaxref{ORGANIZATION LINE SEQUENTIAL} files.
@p @item Rewriting a record does not cause the contents of the file to be physically updated until the next block of the file is read, a @syntaxref{COMMIT} or @statementref{UNLOCK} is issued or that file is closed.
@p @item If the file has @syntaxref{ORGANIZATION SEQUENTIAL}:
@enumerate A
@p @item The record to be rewritten will be the one retrieved by the most-recently executed @syntaxref{READ} of the file.
@p @item If the @syntax{FD} of the file contains the @syntax{RECORD CONTAINS} or @syntax{RECORD IS VARYING} clause, and that clause allows the record size to vary, the size of @term{record-name-1} cannot be altered.
@end enumerate
@item If the file has @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED}:
@enumerate A
@p @item If the file has @syntax{ACCESS MODE SEQUENTIAL}, the record to be rewritten will be the one retrieved by the most-recently executed @syntax{READ} of the file.  If the file has @syntax{ACCESS MODE RANDOM} or @syntax{ACCESS MODE DYNAMIC}, no @syntax{READ} is required before a record may be rewritten --- the @syntax{RELATIVE KEY} or @syntax{RECORD KEY} definition for the file, respectively, will specify the record to be updated.
@p @item If the @syntax{FD} of the file contains the @syntax{RECORD CONTAINS} or @syntax{RECORD IS VARYING} clause, and that clause allows the record size to vary, the size @i{can} be altered.
@end enumerate
@item The optional @syntax{LOCK} options may be used to manually control access to the re-written record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviours.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.36 ROLLBACK                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.36,ROLLBACK}
@diagram{ROLLBACK,PD-ROLLBACK,PD-ROLLBACK,None}@p The @statement{ROLLBACK} has the same effect as if an @statementref{UNLOCK} were executed against every open file in the program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item All locks currently being held for all open files will be released.
@p @item @xref{Record Locking}, to review the various record locking behaviours.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.37 SEARCH                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.37,SEARCH}
@diagram{SEARCH,PD-SEARCH,PD-SEARCH,None}@p The @statement{SEARCH} is used to sequentially search a table, stopping either once a specific value is located within the table or when the table has been completely searched.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{AT} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item The searching process will be controlled through a @define{Search Index} --- a data item with a @syntaxref{USAGE} of @syntax{INDEX}.  The search index is either the @term{index-name-1} identifier specified on the @syntaxidx{VARYING} clause or --- if no @syntax{VARYING} is specified --- the @syntax{USAGE INDEX} data item implicitly created by an @syntaxrefalt{INDEXED BY,OCCURS} clause in the table's definition.
@p @item At the time the @syntax{SEARCH} statement is executed, the current value of the search index data item will define the starting position in the table where the searching process will begin.  Typically, one initializes that index to a value of 1 before starting the @syntax{SEARCH} via @syntax{SET @term{search-index} TO 1}.
@p @item Each of the @term{conditional-expression-n}s on the @syntax{WHEN} clause(s) should involve a data element within the table, subscripted using the search index.
@p @item The searching process is as follows:
@enumerate A
@p @item Each @term{conditional-expression-n} will be evaluated, in turn, until either one evaluates to a value of TRUE or all have evaluated to FALSE.
@p @item The @term{imperative-statement-n} (@pxref{Imperative Statement}) specified on the @syntax{WHEN} clause whose @term{conditional-expression-n} evaluated to TRUE will be executed; after that, the search will be considered complete and control will fall into the first executable statement following the @syntax{SEARCH}.
@p @item If all @term{conditional-expression-n}s evaluated to FALSE:
@itemize @bullet
@p @item The search index will be incremented by 1
@p @item If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the @term{imperative-statement-1} on the optional @syntaxidx{AT END} clause, if any, will be executed.  After that, control will fall into the first executable statement following the @syntax{SEARCH}.
@p @item If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).
@end itemize
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.38 SEARCH ALL                                              **
@comment *********************************************************************
@page
@newsubsection{6.17.38,SEARCH ALL}
@diagram{SEARCH ALL,PD-SEARCH-ALL,PD-SEARCH-ALL,None}@p The @statement{SEARCH ALL} performs a binary, or half-interval, search against a sorted table.  This is generally @i{significantly} faster than performing a sequential @syntax{SEARCH} of a table, especially if the table contains a large number of entries.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{AT} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item To be eligible for searching via @syntax{SEARCH ALL}:
@enumerate A
@p @item The @syntax{OCCURS} clause of @term{table-name-1} must contain the following elements:
@itemize @bullet
@p @item An @syntaxidx{INDEXED BY} entry to define an implicit search index data item with a @syntaxref{USAGE} of @syntax{INDEX}.
@p @item An @syntaxidx{ASCENDING KEY} or @syntaxidx{DESCENDING KEY} clause to specify the field within the table by which all entries in the table are sorted.
@end itemize
@item Just because the table has one or more @syntax{KEY} clauses doesn't mean the data is actually @i{in} that sequence in the table --- the actual sequence of the data @i{must} agree with the KEY clause(s)!  A table-based @syntaxrefalt{SORT,Table SORT} can prove very useful in this regard.
@p @item No two records in the table may have the same @syntax{KEY} field values.  If the table has multiple @syntax{KEY} definitions, then no two records in the table may have the same @i{combination} of @syntax{KEY} field values.
@end enumerate
@item If rule (A) is violated, the compiler will reject the @syntax{SEARCH ALL}.  If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a @syntax{SEARCH ALL} against the table will probably be incorrect.
@p @item The @term{conditional-expression-1} should involve the @syntax{KEY} field(s), using the search index (the table's @syntax{INDEXED BY} index name) as a subscript.
@p @item The function of the single, mandatory, @syntaxidx{WHEN} clause is to compare the key field(s) of the table, as indexed by the search index data item, against whatever literal and/or identifier values you are comparing the key field(s) to in the @term{conditional-expression-1} in order to locate the desired entry in the table.  The search index will be automatically varied in a manner designed to require the minimum number of tests.
@p @item The internal processing of the SEARCH ALL statement begins by setting internal "first" and "last" pointers to the 1st and last entry locations of the table.  Processing then proceeds as follows:
@enumerate A
@p @item The entry half-way between "first" and "last" is identified.  We'll call this the "current" entry, and will set its table entry location into @term{index-name-1}.
@p @item The @term{conditional-expression-1} is evaluated.  This comparison of the key(s) against the target literal/identifier values will have one of three possible outcomes:
@itemize @bullet
@p @item If the key(s) and value(s) match, @term{imperative-statement-2} (@pxref{Imperative Statement}) is executed, after which control falls through into the next statement following the @syntax{SEARCH ALL}.
@p @item If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the "current" to "last" range of the table, so a new "first" pointer value is set (it will be set to the "current" pointer).
@p @item If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the "first" to "current" range of the table, so a new "last" pointer value is set (it will be set to the "current" pointer).
@end itemize
@item If the new "first" and "last" pointers are different than the old "first" and "last" pointers, there's more left to be searched, so return to step (A) and continue.
@p @item If the new "first" and "last" pointers are the same as the old "first" and "last" pointers, the table has been exhausted and the entry being searched for cannot be found; @term{imperative-statement-1} is executed, after which control falls through into the next statement following the @syntax{SEARCH ALL}.  If there is no @syntax{AT END} clause coded, control simply falls into the next statement following the @syntax{SEARCH ALL}.
@end enumerate
@item The net effect of the above algorithm is that only a fraction of the number of elements in the table need ever be tested in order to decide whether or not a particular entry exists.  This is because the half the remaining entries in the table are discarded each time an entry is checked.
@p @item Computer scientists will compare the two techniques implemented by the @syntax{SEARCH} and @statement{SEARCH ALL}s as follows:
@p @item When searching a table with "n" entries, a sequential search will need an average of n/2 tests and a worst case of n tests in order to find an entry and n tests to identify that an entry doesn't exist.
@p @item When searching a table with "n" entries,  a binary search will need a worst-case of log2(n) tests in order to find an entry and log2(n) tests to identify that an entry doesn't exist (n = the number of entries in the table), where "log2" is the base-2 logarithm function.
@end enumerate
@* Here's a more practical view of the difference.  Let's say that a table has 1,000 entries in it.  With a sequential search, on average, you'll have to check 500 of them to find an entry and you'll have to look at all 1,000 of them to find that an entry doesn't exist.
@p With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer --- the number of digits a decimal number would have if expressed in the logarithm's number base).  In this case, we end up with 10 --- THAT is the worst-case number of tests required to find an entry or to identify that it doesn't exist.  That's quite an improvement!
@comment *********************************************************************
@comment ** 6.17.39 SET                                                     **
@comment *********************************************************************
@page
@newsubsection{6.17.39,SET}
@menu
* 6.17.39.1: SET ENVIRONMENT
* 6.17.39.2: SET Program-Pointer
* 6.17.39.3: SET ADDRESS
* 6.17.39.4: SET Index
* 6.17.39.5: SET UP/DOWN
* 6.17.39.6: SET Condition Name
* 6.17.39.7: SET Switch
* 6.17.39.8: SET ATTRIBUTE
@end menu
@comment *********************************************************************
@comment ** 6.17.39.1 SET ENVIRONMENT                                       **
@comment *********************************************************************
@newunit{6.17.39.1,SET ENVIRONMENT}
@diagram{SET ENVIRONMENT,PD-SET-1,PD-SET-1,None}@p The @statement{SET ENVIRONMENT} provides a straight-forward means of setting environment values from within a program.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The value of @term{literal-1} or @term{identifier-1} specifies the name of the environment variable to set.
@p @item The value of @term{literal-2} or @term{identifier-2} specifies the value to be assigned to the environment variable.
@p @item Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL "SYSTEM") but will not be known to the shell or console window that started the GnuCOBOL program.
@end enumerate
@* This is a much simpler and more readable means of setting environment variables than by using the @statementref{DISPLAY UPON ENVIRONMENT-NAME}.  For example, these two code sequences produce identical results:
@p @example
DISPLAY "VARNAME" UPON ENVIRONMENT-NAME
DISPLAY "VALUE" UPON ENVIRONMENT-VALUE

SET ENVIRONMENT "VARNAME" TO "VALUE"
@end example
@comment *********************************************************************
@comment ** 6.17.39.2 SET Program-Pointer                                   **
@comment *********************************************************************
@page
@newunit{6.17.39.2,SET Program-Pointer}
@diagram{SET Program-Pointer,PD-SET-2,PD-SET-2,None}@p The @statement{SET @term{Program-Pointer}} allows you to retrieve the address of a procedure division code module --- specifically the @syntax{PROGRAM-ID}, @syntax{FUNCTION-ID} or an entry-point established via the @statementref{ENTRY}.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item If you have used other versions of COBOL before (particularly mainframe implementations), you've possibly seen subroutine calls made passing a procedure name as an argument --- that is not possible in GnuCOBOL; instead, you need to know how to use this form of the @statement{SET}.
@p @item The @syntaxref{USAGE} of @term{program-pointer-1} must be @syntax{PROGRAM-POINTER}.
@p @item The @term{literal-1} or @term{identifier-1} value specified must name a primary entry-point name (@syntax{PROGRAM-ID} of a subroutine or @syntax{FUNCTION-ID} of a user-defined function) or an alternate entry-point defined via an @syntax{ENTRY} statement within a subprogram.
@p @item Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for.  For examples of @syntax{PROGRAM-POINTER}s at work, see the discussions of the @subpgmref{CBL_ERROR_PROC} and @subpgmref{CBL_EXIT_PROC}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.3 SET ADDRESS                                           **
@comment *********************************************************************
@page
@newunit{6.17.39.3,SET ADDRESS}
@diagram{SET ADDRESS,PD-SET-3,PD-SET-3,None}@p The @statement{SET ADDRESS} can be used to work with the addresses of data items rather than their contents.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item When the @syntaxidx{ADDRESS OF} clause is used @i{before} the @syntax{TO} you will be using this statement to alter the address of a linkage section or @syntaxref{BASED} data item.  Without that clause you will be assigning an address to one or more data items whose @syntaxref{USAGE} is @syntax{POINTER}.
@p @item When the @syntax{ADDRESS OF} clause is used @i{after} the @syntax{TO}, this statement will be identifying the address of @term{identifier-2} as the address to be assigned to @term{identifier-1} or stored in @term{pointer-name-1}.
@p @item If the @syntax{ADDRESS OF} clause is absent after the @syntax{TO}, the contents of @term{pointer-name-2} will serve as the address to be assigned.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.4 SET Index                                             **
@comment *********************************************************************
@page
@newunit{6.17.39.4,SET Index}
@diagram{SET Index,PD-SET-4,PD-SET-4,None}@p This statement assigns a value to a @syntax{USAGE INDEX} data item.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Either the @syntaxref{USAGE} of @term{index-name-1} should be @syntax{INDEX}, or @term{index-name-1} must be identified in a table @syntax{INDEXED BY} clause.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.5 SET UP/DOWN                                           **
@comment *********************************************************************
@page
@newunit{6.17.39.5,SET UP/DOWN}
@diagram{SET UP/DOWN,PD-SET-5,PD-SET-5,None}@p Use this statement to increment or decrement the value of an index or pointer by a specified amount.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item The @syntaxref{USAGE} of @term{identifier-1} must be @syntax{INDEX}, @syntax{POINTER} or @syntax{PROGRAM-POINTER}.
@p @item The typical usage when @term{identifier-1} is a @syntax{USAGE INDEX} data item is to increment it's value @syntax{UP} or @syntax{DOWN} by 1, since an index is usually being used to sequentially walk through the elements of a table.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.6 SET Condition Name                                    **
@comment *********************************************************************
@page
@newunit{6.17.39.6,SET Condition Name}
@diagram{SET Condition Name,PD-SET-6-Info,PD-SET-6-TeX,None}@p The @statement{SET @term{Condition Name}} provides one method of specifying the TRUE / FALSE value of a level-88 condition name.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item By setting the specified @term{condition-name-1}(s) to a TRUE or FALSE value, you will actually be assigning a value to the parent data item(s) to which the condition name data item(s) is(are) subordinate to.
@p @item When specifying @syntax{TRUE}, the value assigned to each parent data item will be the first value specified on the condition name's @syntax{VALUE} clause.
@p @item When specifying @syntax{FALSE}, the value assigned to each parent data item will be the value specified for the @syntax{FALSE} clause of the condition name's definition; if any @term{condition-name-1} occurrence lacks a @syntax{FALSE} clause, the @syntax{SET} statement will be rejected by the compiler.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.7 SET Switch                                            **
@comment *********************************************************************
@page
@newunit{6.17.39.7,SET Switch}
@diagram{SET Switch,PD-SET-7-Info,PD-SET-7-TeX,None}@p This form of the @statement{SET} is used to turn switches on or off.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Switches are defined using the @syntaxref{SPECIAL-NAMES} paragraph.
@p @item Switches may be tested via the @statementref{IF} and a Switch-Status Condition.  @xref{Switch-Status Conditions}, for more information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.39.8 SET ATTRIBUTE                                         **
@comment *********************************************************************
@page
@newunit{6.17.39.8,SET ATTRIBUTE}
@diagram{SET ATTRIBUTE,PD-SET-8,PD-SET-8,None}@p The @statement{SET ATTRIBUTE} may be used to modify one or more attributes of a screen section data item at run-time.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item When making an attribute change to @term{identifier-1}, the change will not become visible on the screen until the screen section data item containing @term{identifier-1} is next accepted (if @term{identifier-1} is an input field) or is next displayed (if @term{identifier-1} is not an input field).
@p @item The attributes shown in the syntax diagram are the only ones that may be altered by this statement.  @xref{Data Description Clauses}, for information on their usage.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.40 SORT                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.40,SORT}
@menu
* 6.17.40.1: File-Based SORT
* 6.17.40.2: Table SORT
@end menu
@comment *********************************************************************
@comment ** 6.17.40.1 File-Based SORT                                       **
@comment *********************************************************************
@newunit{6.17.40.1,File-Based SORT}
@diagram{File-Based SORT,PD-SORT-1-Info,PD-SORT-1-TeX,PD-DUPLICATES}@p This format of the @statement{SORT} is designed to sort large volumes of data according to one or more key fields.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{THRU} and @syntax{THROUGH} are interchangeable.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{sort-file-1} named on the @statement{SORT} must be defined using a sort description (@syntaxrefalt{SD,File/Sort-Description}).  This file is referred to in the remainder of this discussion as the "sort work file".
@p @item If specified, @term{file-name-1} and @term{file-name-2} must reference @syntaxref{ORGANIZATION LINE SEQUENTIAL} or @syntaxref{ORGANIZATION SEQUENTIAL} files.  These files must be defined using a file description (@syntaxrefalt{FD,File/Sort-Description}).  The same file(s) may be used for @term{file-name-1} and @term{file-name-2}.
@p @item The @term{identifier-1} @dots{} field(s) must be defined as field(s) within a record of @term{sort-file-1}.
@p @item A sort work file is never opened or closed.
@p @item The sorting process works in three stages --- the Input Stage, the Sort Stage and the Output Stage.
@p @item The following points pertain to the Input Stage:
@enumerate A
@p @item The data to be sorted is loaded into the sort work file either by copying the entire contents of the file(s) named on the @syntax{USING} clause (done automatically by the sort) or by utilizing an input procedure.
@p @item When @syntaxidx{USING} is specified, none of the @term{file-name-1} files may be open at the time the @statement{SORT} is executed.
@p @item When an input procedure is used, the procedure(s) specified on the @syntaxidx{INPUT PROCEDURE} clause will be invoked as if by a procedural @statementrefalt{PERFORM,Procedural PERFORM} with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Records will be loaded into the sort work file --- one at a time --- within the input procedure using the @statementref{RELEASE}.  This, by the way, is how you could sort the contents of relative or indexed files.
@p A @statementref{GO TO} that transfers control out of the input procedure will terminate the @statement{SORT} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an input procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the sort work file are lost.  You may, however, re-execute the @statement{SORT} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A SORT, OR RE-STARTING A PREVIOUSLY-CANCELLED SORT IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An input procedure should be terminated in the same way a procedural @statement{PERFORM} would be.
@p Neither a another file-based @statement{SORT} nor a @statement{MERGE} may be executed within the input procedure unless those statements utilize a different sort or merge work file.
@p @item Once the input procedure terminates, the input phase is complete.
@p @item As data is loaded into the sort work file, it is actually being buffered in dynamically-allocated memory.  Only if the amount of data to be sorted exceeds the amount of available sort memory (128 MB) will actual disk files be allocated and utilized.  There is a @envvarruntimeref{COB_SORT_MEMORY} that you may use to allocate more or less memory to the sorting process.
@end enumerate
@item The following points pertain to the Sort Stage:
@enumerate A
@p @item The sort will take place by arranging the data records in the sequence defined by the @syntax{KEY} specification(s) on the @statement{SORT} according to the @syntax{COLLATING SEQUENCE} specified on the @syntax{SORT} (if any) or --- if none was defined --- the @syntaxrefalt{PROGRAM COLLATING SEQUENCE,OBJECT-COMPUTER}.  Keys may be any supported data type and @syntaxref{USAGE} except for level-78 or level-88 data items.
@p @item For example, let's assume we're sorting a series of financial transactions.  The SORT statement might look like this:
@p @example
SORT Sort-File
    ASCENDING  KEY Transaction-Date
    ASCENDING  KEY Account-Number
    DESCENDING KEY Transaction-Amount
@end example
@* The effect of this statement will be to sort all transactions into ascending order of the date the transaction took place (oldest first, newest last).  Unless the business running this program is going out of business, there are most-likely many transactions for any given date.  Therefore, within each grouping of transactions all with the same date, transactions will be sub-sorted into ascending sequence of the account number the transactions apply to.  Since it's quite possible there might be multiple transactions for an account on any given date, a third level sub-sort will arrange all transactions for the same account on the same date into descending sequence of the actual amount of the transaction (largest first, smallest last).  If two or more transactions of $100.00 were recorded for account #12345 on the 31st of August 2009, those transactions will be retained in the order in which they were loaded into the sort work file.
@p @item  Should disk work files be necessary due to the amount of data being sorted, they will be automatically allocated to disk in a folder defined by the @envvarruntime{TMPDIR}, @envvarruntime{TMP} or @envvarruntimerefs{TEMP} (checked for existence in that sequence).  These disk files will be automatically purged upon @syntax{SORT} termination or program execution termination (normal or otherwise).
@end enumerate
@item The following points pertain to the Output Stage:
@enumerate A
@p @item Once the sort stage is complete, a copy of the sorted data will be written to each @term{file-name-2} if the @syntaxidx{GIVING} clause was specified.  None of the @term{file-name-2} files can be open at the time the sort is executed.
@p @item When an output procedure is used, the procedure(s) specified on the @syntaxidx{OUTPUT PROCEDURE} clause will be invoked as if by a procedural @statementrefalt{PERFORM,Procedural PERFORM} with no @syntax{VARYING}, @syntax{TIMES} or @syntax{UNTIL} options specified.  Records will be retrieved from the sort work file --- one at a time --- within the output procedure using the @statementref{RETURN}.
@p A @statementref{GO TO} that transfers control out of the output procedure will terminate the @statement{SORT} but allows the program to continue executing from the point where the @statement{GO TO} transferred control to.  Once an output procedure has been "aborted" using a @syntax{GO TO} it cannot be resumed, and the contents of the sort work file are lost.  You may, however, re-execute the @statement{SORT} itself.  USING A @statement{GO TO} TO PREMATURELY TERMINATE A SORT, OR RE-STARTING A PREVIOUSLY-CANCELLED SORT IS NOT CONSIDERED GOOD PROGRAMMING STYLE AND SHOULD BE AVOIDED.
@p An output procedure should be terminated in the same way a procedural @statement{PERFORM} would be.
@p Neither a another file-based @statement{SORT} nor a @statement{MERGE} may be executed within the output procedure unless those statements utilize a different sort or merge work file.
@p @item Once the output procedure terminates, the sort is complete.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.40.2 Table SORT                                            **
@comment *********************************************************************
@page
@newunit{6.17.40.2,Table SORT}
@diagram{Table SORT,PD-SORT-2,PD-SORT-2,PD-DUPLICATES}@p This format of the @statement{SORT} sorts relatively small quantities of data --- namely data contained in a data division table --- according to one or more key fields.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IN}, @syntax{IS}, @syntax{KEY}, @syntax{ON}, @syntax{ORDER}, @syntax{SEQUENCE} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item GnuCOBOL always behaves as if the @syntax{WITH DUPLICATES IN ORDER} clause is specified, even if it isn't.
@p While any COBOL implementation's sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.
@p Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.
@comment Semantic Specifications:
@p @item The @term{table-name-1} data item must be a table defined in any data division section @i{except} the report or screen sections.
@p @item The data within @term{table-name-1} will be sorted in-place (i.e. no sort file is required).
@p @item The sort will take place by rearranging the data in @term{table-name-1} into the sequence defined by the @syntax{KEY} specification(s) on the @statement{SORT}, according to the @syntax{COLLATING SEQUENCE} specified on the @syntax{SORT} (if any) or --- if none was defined --- the @syntaxrefalt{PROGRAM COLLATING SEQUENCE,OBJECT-COMPUTER}.  Keys may be any supported data type and @syntaxref{USAGE} except for level-78 or level-88 data items.
@p @item If you are sorting @term{table-name-1} for the purpose of preparing the table for use with a @statementref{SEARCH ALL}, care must be taken that the @syntax{KEY} specifications on the @syntax{SORT} agree with those in the table's definition.
@p @item Although the specification of one or more KEY clauses is optional, currently, a table sort with no @syntax{KEY} specification(s) made on the @statement{SORT} is unsupported by GnuCOBOL and will be rejected by the compiler.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.41 START                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.41,START}
@diagram{START,PD-START,PD-START,None}@p The @statement{START} defines the logical starting point within a relative or indexed file for subsequent sequential read operations.  It positions an internal logical record pointer to a particular record in the file, but does not actually transfer any of that record's data into the record buffer.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS}, @syntax{KEY}, @syntax{THAN} and @syntax{TO} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item To use this statement, @term{file-name-1} must be an @syntaxref{ORGANIZATION RELATIVE} or @syntaxref{ORGANIZATION INDEXED} file that must have been defined with an @syntax{ACCESS MODE DYNAMIC} or @syntax{ACCESS MODE SEQUENTIAL} in its @statementref{SELECT}.
@p @item At the time this statement is executed, @term{file-name-1} must be open in either @syntax{INPUT} or @syntaxrefalt{I-O,File OPEN Modes} mode.
@p @item If @term{file-name-1} is a relative file, @term{identifier-1} must be the defined @syntax{RELATIVE KEY} of the file.
@p @item If @term{file-name-1} is an indexed file, @term{identifier-1} must be the defined @syntax{RECORD KEY} of the file or any of the @syntax{ALTERNATE RECORD KEY} fields for the file.
@p @item If no @syntax{FIRST}, @syntax{LAST} or @syntax{KEY} clause is specified, @syntax{KEY IS EQUAL TO xxx} will be assumed, where "xxx" is the defined @syntax{RELATIVE KEY} of (if @term{file-name-1} is a relative file) or the defined @syntax{RECORD KEY} (if @term{file-name-1} is an indexed file).
@p @item After successful execution of a @statement{START}, the internal logical record pointer into the @term{file-name-1} data will be positioned to the record which satisfied the actual or implied @syntax{FIRST}, @syntax{LAST} or @syntax{KEY} clause specification, as follows:
@enumerate A
@p @item If @syntax{FIRST} was specified, the logical record pointer will point to the first record in the file.
@p @item If @syntax{LAST} was specified, the logical record pointer will point to the last record in the file.
@p @item If @syntax{KEY} was specified or implied, the logical record pointer will be specified to the @i{first} record satisfying the relation condition; to identify this record, the file's contents are searched in a first-to-last (in sequence of the key implied by the @syntax{KEY} clause), provided the relation is @syntax{EQUAL TO}, @syntax{GREATER THAN} or @syntax{GREATER THAN OR EQUAL TO} (or any of their syntactical equivalents).
@p @item If @syntax{KEY} was specified or implied, the logical record pointer will be specified to the @i{last} record satisfying the relation condition; to identify this record, the file's contents are searched in a last-to-first (in sequence of the key implied by the @syntax{KEY} clause), provided the relation is @syntax{LESS THAN}, @syntax{LESS THAN OR EQUAL TO} or @syntax{NOT GREATER THAN} (or any of their syntactical equivalents).
@end enumerate
@* The next sequential @statement{READ} will read the record that is pointed to by the logical record pointer.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used to detect and react to the failure or success, respectively, by detecting non-zero (typically 23 = key not found = record not found) and 00 file status codes, respectively.  @xref{File Status Codes}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.42 STOP                                                    **
@comment *********************************************************************
@page
@newsubsection{6.17.42,STOP}
@diagram{STOP,PD-STOP,PD-STOP,None}@p The @statement{STOP} suspends program execution.  Some options will allow program execution to resume while others return control to the operating system.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{STATUS} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntaxidx{RETURNING} and @syntaxidx{GIVING} are interchangeable.
@comment Semantic Specifications:
@p @item The @syntaxidx{RUN} clause halts the program without displaying any special message to that effect.
@p @item The @term{literal-3} clause displays the specified text on the @syntax{SYSOUT}/@syntax{STDOUT} device, waits for the user to press the Enter key and then --- once the key has been pressed --- allows the program to continue execution.
@p @item The optional @syntax{RETURNING} clause provides the opportunity to return a numeric value to the operating system (a "return code").  The manner in which the return code may be interrogated by the operating system varies, but Windows can use @syntax{%ERRORLEVEL%} to query the return code while Unix shells such as sh, bash and ksh can query the return code as @syntax{$?}.  Other Unix shells may have different ways to access return code values.
@p @item The @syntaxidx{STATUS} clause provides another means of returning a return code.  Using the @syntax{STATUS} clause is functionally equivalent to using the @syntax{RETURNING} clause.
@p @item Using the @syntax{STATUS} clause without a @term{literal-2} or @term{identifier-2} will return a return code of 0 if the @syntaxidx{NORMAL} keyword is used or a 1 if @syntaxidx{ERROR} was specified.
@p @item Your program will @i{always} return a return code, even if no @syntax{RETURNING} or @syntax{STATUS} clause is specified.  In the absence of the use of these clauses, the value in the @registerrefalt{RETURN-CODE,Special Registers} at the time the @statement{STOP} is executed will be used as the return code.
@p @item Any programmer-defined exit procedure (established via the @subpgmref{CBL_EXIT_PROC}) will be executed by @syntax{STOP RUN}, but not by @syntax{STOP @term{literal-3}}.
@p @item Valid return code values can be in the range -2147483648 to +2147483647.
@p @item The three code snippets below are all equivalent --- they show different ways in which a GnuCOBOL program may be coded to pass a return code value of 16 back to the operating system and then halt.
@p @example
STOP RUN RETURNING 16

MOVE 16 TO RETURN-CODE
STOP RUN

STOP RUN WITH ERROR STATUS 16
@end example
@end enumerate
@comment *********************************************************************
@comment ** 6.17.43 STRING                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.43,STRING}
@diagram{STRING,PD-STRING,PD-STRING,None}@p The @statement{STRING} is used to concatenate all or a part of one or more strings together, forming a new string.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{ON} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item All literals and identifiers (except for @term{identifier-4}) must be explicitly or implicitly defined with a @syntaxref{USAGE} of @syntax{DISPLAY}.   Any of the identifiers may be group items.
@p @item The @syntaxidx{POINTER} data item --- @term{identifier-4} --- must be a non-edited elementary integer numeric data item with a value greater than zero.
@p @item Each @term{literal-1} / @term{identifier-1} will be referred to as a source item.  The receiving data item is @term{identifier-3}.
@p @item The @statement{STRING}'s processing is based upon a @define{current character pointer}.  The initial value of the current character pointer will be the value of @term{identifier-4} at the time the @syntax{STRING} statement began execution.  If no @syntax{POINTER} clause is coded, a value of 1 (meaning "the 1st character position") will be assumed for the current character pointer's initial value.
@p @item For each source item, the contents of the sending item will be copied --- character-by-character --- into @term{identifier-3} at the character position specified by the current character pointer.  After each character is copied, the current character pointer will be incremented by 1 so that it points to the position within @term{identifier-3} where the @i{next} character should be copied.
@p @item The @syntaxidx{DELIMITED BY} clause specifies how much of each source item will be copied into @term{identifier-3}.  @syntax{DELIMITED BY SIZE} (the default if no @syntax{DELIMITED BY} clause is specified) causes the @i{entire} contents of the source item to be copied into @term{identifier-3}.
@p @item Using @syntax{DELIMITED BY @term{literal-2}} or @syntax{DELIMITED BY @term{identifier-2}} causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.
@p @item @syntax{STRING} processing will cease when one of the following occurs:
@enumerate A
@p @item The initial value of the current character pointer is less than 1 or greater than the number of characters in @term{identifier-3}, or@dots{}
@p @item The value of the current character pointer exceeds the size of @term{identifier-3} at the point the STRING statement wants to copy a character into @term{identifier-3}, or@dots{}
@p @item All sending items have been fully processed
@end enumerate
@item If event (A) occurs, @term{identifier-3} will remain unchanged.
@p @item The occurrence of either event (A) or (B) triggers what is referred to as an @define{overflow condition}.
@p @item The @term{identifier-3}) is neither automatically initialized (to spaces or any other value) at the start of a @syntax{STRING} statement nor will it be space-filled should the total number of sending item characters copied into it be less than its size.  You may explicitly initialize @term{identifier-3} yourself via the @syntaxref{INITIALIZE} or @syntaxref{MOVE} statements before executing the @syntax{STRING} if you wish.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses may be used to detect and react to the occurrence or not, respectively, of an overflow condition.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.44 SUBTRACT                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.44,SUBTRACT}
@menu
* 6.17.44.1: SUBTRACT FROM
* 6.17.44.2: SUBTRACT GIVING
* 6.17.44.3: SUBTRACT CORRESPONDING
@end menu
@comment *********************************************************************
@comment ** 6.17.44.1 SUBTRACT FROM                                         **
@comment *********************************************************************
@newunit{6.17.44.1,SUBTRACT FROM}
@diagram{SUBTRACT FROM,PD-SUBTRACT-1-Info,PD-SUBTRACT-1-TeX,None}@p This format of the @statement{SUBTRACT} generates the arithmetic sum of all arguments that appear before the @syntax{FROM} (@term{identifier-1} or @term{literal-1}) and subtracts that sum from each @term{identifier-2}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items.
@p @item @term{literal-1} must be a numeric literal.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.44.2 SUBTRACT GIVING                                       **
@comment *********************************************************************
@page
@newunit{6.17.44.2,SUBTRACT GIVING}
@diagram{SUBTRACT GIVING,PD-SUBTRACT-2-Info,PD-SUBTRACT-2-TeX,None}@p The @statement{SUBTRACT GIVING} generates the arithmetic sum of all arguments that appear before the @syntax{FROM} (@term{identifier-1} or @term{literal-1}), subtracts that sum from the contents of @term{identifier-2} and then replaces the contents of the identifiers listed after the @syntaxidx{GIVING} (@term{identifier-3}) with that result.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be numeric unedited data items.
@p @item @term{literal-1} must be a numeric literal.
@p @item @term{identifier-3} must be a numeric (edited or unedited) data item.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.44.3 SUBTRACT CORRESPONDING                                **
@comment *********************************************************************
@page
@newunit{6.17.44.3,SUBTRACT CORRESPONDING}
@diagram{SUBTRACT CORRESPONDING,PD-SUBTRACT-3,PD-SUBTRACT-3,None}@p The @statement{SUBTRACT CORRESPONDING} generates code equivalent to individual @syntax{SUBTRACT FROM} statements for corresponding matches of data items found subordinate to the two identifiers.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{IS} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item Both @term{identifier-1} and @term{identifier-2} must be group items.
@p @item @xref{CORRESPONDING}, for information on how corresponding matches will be found between @term{identifier-1} and @term{identifier-2}.
@p @item The optional @syntaxref{ROUNDED} clause available to each @term{identifier-2} will control how non-integer results will be saved.
@p @item The optional @syntax{ON SIZE ERROR} and @syntax{NOT ON SIZE ERROR} clauses may be used to detect and react to the failure or success, respectively, of an attempt to perform a calculation.  In this case, failure is defined as being an @term{identifier-2} with an insufficient number of digit positions available to the left of any implied decimal point.  @xref{ON SIZE ERROR + NOT ON SIZE ERROR}, for additional information.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.45 SUPPRESS                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.45,SUPPRESS}
@diagram{SUPPRESS,PD-SUPPRESS,PD-SUPPRESS,None}@p The @statement{SUPPRESS} causes the presentation of a report group to be suppressed.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved word @syntax{PRINTING} is optional and may be included, or not, at the discretion of the programmer.  The presence or absence of this word has no effect upon the program.
@comment Semantic Specifications:
@p @item This statement may only appear within a @syntax{USE BEFORE REPORTING} procedure (in @syntaxref{DECLARATIVES}).
@p @item @syntax{SUPPRESS} only prevents the presentation of the report group within whose @syntax{USE BEFORE REPORTING} procedure the statement occurs.
@p @item This statement must be executed each time presentation of the report group is to be suppressed.
@p @item When a report group's presentation is suppressed, none of the following operations for the report will take place:
@enumerate A
@p @item Actual presentation of the report group in question.
@p @item Processing of any @syntaxref{LINE} clauses within the report group in question.
@p @item Processing of the @syntaxref{NEXT GROUP} clause (if any) within the report group in question.
@p @item Any modification to the @registerrefalt{LINE-COUNTER,Special Registers}.
@p @item Any modification to the @register{PAGE-COUNTER}.
@end enumerate
@end enumerate
@comment *********************************************************************
@comment ** 6.17.46 TERMINATE                                               **
@comment *********************************************************************
@page
@newsubsection{6.17.46,TERMINATE}
@diagram{TERMINATE,PD-TERMINATE,PD-TERMINATE,None}@p The @statement{TERMINATE} causes the processing of the specified report(s) to be completed.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Each @term{report-name-1} must be the name of a report having an @syntaxrefalt{RD,REPORT SECTION} defined for it.
@p @item The specified report name(s) must be currently initiated (via @syntaxref{INITIATE}) and cannot yet have been terminated.
@p @item The @statement{TERMINATE} will present each @syntax{CONTROL FOOTING} (if any), in reverse sequence of the control hierarchy, starting with the most minor up to @syntax{FINAL} (if any).  During the presentation of these groups and the processing of any @syntax{USE BEFORE REPORTING} procedures for those groups, the prior set of control data item values will be available, as though a control break had been detected at the most major control data name.
@p @item During the presentation of the @syntax{CONTROL FOOTING} groups, any necessary @syntax{PAGE FOOTING} and @syntax{PAGE HEADING} groups will be presented as well.
@p @item Finally,the @syntax{REPORT FOOTING} group, if any, will be presented.
@p @item If an @syntax{INITIATE} is followed by a @syntax{TERMINATE} with no intervening @syntaxref{GENERATE} statements (all pertaining to the same report, of course), no report groups will be presented to the output file.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.47 TRANSFORM                                               **
@comment *********************************************************************
@page
@newsubsection{6.17.47,TRANSFORM}
@diagram{TRANSFORM,PD-TRANSFORM,PD-TRANSFORM,None}@p The @statement{TRANSFORM} scans a data item performing a series of mono-alphabetic substitutions, defined by the arguments before and after the @syntax{TO} clause.
@enumerate
@comment Syntactical Specifications:
@comment Semantic Specifications:
@p @item Both @term{literal-1} and/or @term{literal-2} must be alphanumeric literals.
@p @item All of @term{identifier-1}, @term{identifier-2} and @term{identifier-3} must either be group items or alphanumeric data items.  Numeric data items with a @syntaxref{USAGE} of @syntax{DISPLAY} are accepted, but will generate warning messages from the compiler.
@p @item The @syntax{TRANSFORM} statement will replace characters within @term{identifier-1} that are found in the string specified @i{before} the @syntax{TO} keyword with the corresponding characters from the string specified @i{after} the @syntax{TO} keyword.
@p @item This statement exists within GnuCOBOL to provide compatibility with COBOL programs written to pre-1985 standards.  The @statement{TRANSFORM} was made obsolete in the 1985 standard of COBOL, having been replaced by the @syntax{CONVERTING} clause of the @statementref{INSPECT}.  New programs should be coded to use @syntax{INSPECT CONVERTING} rather than @syntax{TRANSFORM}.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.48 UNLOCK                                                  **
@comment *********************************************************************
@page
@newsubsection{6.17.48,UNLOCK}
@diagram{UNLOCK,PD-UNLOCK,PD-UNLOCK,None}@p This statement synchronizes any as-yet unwritten file I/O buffers to the specified file (if any) and releases any record locks held for records belonging to @term{file-name-1}.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{RECORD} and @syntax{RECORDS} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item If @term{file-name-1} is a Sort/Merge work file, no action will be taken.
@p @item Not all GnuCOBOL implementations support locking.  Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated.  When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored.  There will be no compiler message issued.  Buffer syncing, if needed, will still occur.
@p @item @xref{Record Locking}, for additional information on record locking.
@end enumerate
@comment *********************************************************************
@comment ** 6.17.49 UNSTRING                                                **
@comment *********************************************************************
@page
@newsubsection{6.17.49,UNSTRING}
@diagram{UNSTRING,PD-UNSTRING,PD-UNSTRING,None}@p The @statement{UNSTRING} parses a string, extracting any number of sub strings from it.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{BY}, @syntax{IN} and @syntax{ON} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@comment Semantic Specifications:
@p @item @term{identifier-1} through @term{identifier-5} must be explicitly or implicitly defined with a @syntaxref{USAGE} of @syntax{DISPLAY}.   Any of those identifiers may be group items.
@p @item Both @term{literal-1} and @term{literal-2} must be alphanumeric literals.
@p @item Each of @term{identifier-6}, @term{identifier-7} and @term{identifier-8} must be elementary non-edited integer numeric items.
@p @item At the time the @statement{UNSTRING} begins execution, @term{identifier-7} must have a value greater than 0.
@p @item @term{identifier-1} will be referred to as the '@i{source string}' and each @term{identifier-4} will be referred to as a '@i{destination field}' in the following discussions.
@p @item  The @statement{UNSTRING}'s processing is based upon a '@i{current character pointer}', the initial value of which will be the value of @term{identifier-7} at the time the @syntax{UNSTRING} statement began execution.  If no @syntax{POINTER} clause is coded, a value of 1 (meaning "the 1st character position") will be assumed for the current character pointer's initial value.
@p @item The source string will be parsed into sub strings starting from the current character pointer position.  Sub strings are identified by using the various delimiter strings specified on the @syntaxidx{DELIMITED BY} clause as inter-sub string separators.
@p @item Using the @syntaxidx{ALL} option allows a delimiter sequence to be an arbitrarily long sequence of occurrences of the delimiter literal whereas its absence treats each occurrence as a separate delimiter.  When multiple delimiters are specified, they will be looked for in the source string in the sequence in which they are coded.
@p @item Two consecutive delimiter sequences will identify a null sub string.
@p @item Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length.  Both truncation and padding will be controlled by the presence or absence of a @syntaxref{JUSTIFIED} clause on the destination field.
@p @item Each destination field may have an optional @syntaxidx{DELIMITER} clause.  If a @syntax{DELIMITER} clause is specified, @term{identifier-5} will have the delimiter character string used to identify the sub string for the destination field moved into it.  If a destination field was not altered (because an insufficient number of sub strings were identified), @term{identifier-5} for that destination field will also be unchanged.
@p @item Each destination field may have an optional @syntaxidx{COUNT} clause.  If a @syntax{COUNT} clause is specified, @term{identifier-6} will have the size of the sub string (in characters) for the destination field moved into it.  If a destination field was not altered (because an insufficient number of sub strings were identified), @term{identifier-6} for that destination field will also be unchanged.
@p @item If a @syntax{TALLYING} clause is coded, @term{identifier-8} will be incremented by 1 each time a destination field is populated.
@p @item None of @term{identifier-4}, @term{identifier-5}, @term{identifier-6}, @term{identifier-7} or @term{identifier-8} are initialized by the @statement{UNSTRING}.  You need to do that yourself via a @syntaxref{MOVE} or @statementref{INITIALIZE}.
@p @item @syntax{UNSTRING} processing will cease when one of the following occurs:
@enumerate A
@p @item The initial value of the current character pointer is less than 1 or greater than the number of character positions in @term{identifier-1}, or@dots{}
@item All destination fields have been fully processed
@end enumerate
@p @item If event (A) occurs, none of the destination field contents (or the contents of their @syntax{DELIMITER} or @term{COUNT} identifiers) will be changed.
@p @item An '@i{overflow}' condition exists if either event (A) occurs, or if event (B) occurs with at least one character position in @term{identifier-1} not having been processed.
@p @item The optional @syntax{ON OVERFLOW} and @syntax{NOT ON OVERFLOW} clauses may be used to detect and react to the occurrence or not, respectively, of an overflow condition.  @xref{ON OVERFLOW + NOT ON OVERFLOW}, for additional information.
@end enumerate
@* The following sample program illustrates the @statement{UNSTRING} statement.
@p @example
IDENTIFICATION DIVISION.
PROGRAM-ID. DEMOUNSTRING.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  Full-Name                   PIC X(40).
01  Parsed-Info.
    05 Last-Name                PIC X(15).
    05 First-Name               PIC X(15).
    05 MI                       PIC X(1).
    05 Delim-LN                 PIC X(1).
    05 Delim-FN                 PIC X(1).
    05 Delim-MI                 PIC X(1).
    05 Count-LN                 BINARY-CHAR.
    05 Count-FN                 BINARY-CHAR.
    05 Count-MI                 BINARY-CHAR.
    05 Tallying-Ctr             BINARY-CHAR.
PROCEDURE DIVISION.
P1. PERFORM UNTIL EXIT
      DISPLAY "Enter Full Name (null quits):"
          WITH NO ADVANCING
      ACCEPT Full-Name
      IF Full-Name = SPACES
        EXIT PERFORM
      END-IF
      INITIALIZE Parsed-Info
      UNSTRING Full-Name
        DELIMITED BY ", "
                  OR ","
                  OR ALL SPACES
        INTO Last-Name
                 DELIMITER IN Delim-LN
                 COUNT IN Count-LN
             First-Name
                 DELIMITER IN Delim-FN
                 COUNT IN Count-FN
             MI
                 DELIMITER IN Delim-MI
                 COUNT IN Count-MI
        TALLYING Tallying-Ctr
    DISPLAY "First-Name=" First-Name
            " Delim='"    Delim-FN
            "' Count="    Count-FN
    DISPLAY "MI        =" MI "              "
            " Delim='"    Delim-MI
            "' Count="    Count-MI
    DISPLAY "Last-Name =" Last-Name
            " Delim='"    Delim-LN
            "' Count="    Count-LN
    DISPLAY "Tally=     " Tallying-Ctr
  END-PERFORM
  DISPLAY "Bye!"
  STOP RUN   .
@end example
@* The following is sample output from the program:
@p @example
Enter Full Name (null quits):Cutler, Gary L
First-Name=Gary            Delim=' ' Count=+004
MI        =L               Delim=' ' Count=+001
Last-Name =Cutler          Delim=',' Count=+006
Tally=     +003
Enter Full Name (null quits):Snoddgrass,Throckmorton,P
First-Name=Throckmorton    Delim=',' Count=+012
MI        =P               Delim=' ' Count=+001
Last-Name =Snoddgrass      Delim=',' Count=+010
Tally=     +003
Enter Full Name (null quits):Munster   Herman
First-Name=Herman          Delim=' ' Count=+006
MI        =                Delim=' ' Count=+000
Last-Name =Munster         Delim=' ' Count=+007
Tally=     +002
Enter Full Name (null quits):
Bye!
@end example
@comment *********************************************************************
@comment ** 6.17.50 WRITE                                                   **
@comment *********************************************************************
@page
@newsubsection{6.17.50,WRITE}
@diagram{WRITE,PD-WRITE,PD-WRITE,None}@p The @statement{WRITE} writes a new record to an open file.
@enumerate
@comment Syntactical Specifications:
@p @item The reserved words @syntax{ADVANCING}, @syntax{AT}, @syntax{KEY}, @syntax{LINE}, @syntax{LINES} and @syntax{WITH} are optional and may be included, or not, at the discretion of the programmer.  The presence or absence of these words has no effect upon the program.
@p @item The reserved words @syntax{END-OF-PAGE} and @syntax{EOP} are interchangeable.
@comment Semantic Specifications:
@p @item The @term{record-name-1} specified on the statement must be defined as an 01-level record subordinate to the File Description (@syntaxrefalt{FD,File/Sort-Description}) of a file that is currently open for @syntaxrefalt{OUTPUT,File OPEN Modes}, @syntax{EXTEND} or @syntax{I-O}.
@p @item The optional @syntaxidx{FROM} clause will cause @term{literal-1} or @term{identifier-1} to be automatically moved into @term{record-name-1} prior to writing @term{record-name-1}'s contents to the appropriate file.  If this clause is not specified, it is the programmer's responsibility to populate @term{record-name-1} with the desired data prior to executing the @syntax{WRITE}.
@p @item The optional @syntax{LOCK} options may be used to manually control access to the just-written record by other programs while this program is running.  @xref{Record Locking}, to review the various record locking behaviour.
@p @item The optional @syntax{INVALID KEY} and @syntax{NOT INVALID KEY} clauses may be used when writing to relative or indexed files to detect and react to the failure (non-zero file status code) or success (00 file status code), respectively, of the statement.  @xref{File Status Codes}, for additional information.
@p @item When @syntax{WRITE} is used against an @syntaxref{ORGANIZATION LINE SEQUENTIAL} file, with or without the @syntaxref{LINE ADVANCING} option, an end-of-record delimiter character sequence will be written to the file to signify where one record ends and the next record begins.  This delimiter sequence will be either of the following:
@itemize @bullet
@p @item A line-terminator sequence consisting of an ASCII carriage-return/line-feed character sequence (X'0D0A') if you are running a MinGW or native Windows build of GnuCOBOL
@p @item A line-terminator sequence consisting of an ASCII line-feed character (X'0A') if you are running a Cygwin, Linux, Unix or OSX build of GnuCOBOL
@end itemize
@item The following points pertain to the use (or not) of the @syntax{ADVANCING} clause:
@enumerate A
@p @item Using this clause with any organization other than @syntax{ORGANIZATION LINE SEQUENTIAL} will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file (@syntaxref{ORGANIZATION SEQUENTIAL}).
@p @item If no @syntax{ADVANCING} clause is specified on a @syntax{WRITE} to a line-advancing file, @syntax{AFTER ADVANCING 1 LINE} will be assumed; on other than line-advancing files, @syntax{BEFORE ADVANCING 1 LINE} will be assumed.
@p @item When @syntaxidx{BEFORE ADVANCING} is used (or implied), the record is written to the file before the @syntax{ADVANCING} action writes line-terminator characters to the file.
@p @item If @syntaxidx{AFTER ADVANCING} is used (or implied), the @syntax{ADVANCING} action writes line-terminator characters to the file and then the record data is written to the file.
@p @item The @syntax{ADVANCING n LINES} clause will introduce the specified number of line-terminator character sequences into the file either before the written record (@syntax{AFTER ADVANCING}) or after the written record (@syntax{BEFORE ADVANCING}).
@item  If the @syntaxrefalt{LINAGE,File/Sort-Description} clause is @i{absent} from the file's @syntax{FD}:
@enumerate a
@p @item The @syntaxidx{ADVANCING PAGE} clause will introduce an ASCII formfeed character into the file either before the written record (@syntax{AFTER PAGE}) or after the written record (@syntax{BEFORE PAGE}).
@p @item Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with "full page" situations and the like are the complete responsibility of the programmer.
@end enumerate
@item  If the LINAGE clause is @i{present} in the file's @syntax{FD}:
@enumerate a
@p @item The @syntax{ADVANCING PAGE} clause will introduce the appropriate number of line-terminator character sequences into the file either before the written record (@syntax{AFTER ADVANCING}) or after the written record (@syntax{BEFORE ADVANCING}) so as to force the printer to automatically advance to a new sheet of paper when the file prints.  No formfeed characters will be generated when @syntax{LINAGE} is specified --- instead, it is assumed that the printer to which the report will be printed will be loaded with special forms that conform to the specifications defined by the @syntax{LINAGE} clause.
@p @item  Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with "full page" situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the @registerrefalt{LINAGE-COUNTER,Special Registers} and the @syntaxidx{END-OF-PAGE} clause to deal with page formatting issues.
@p @item The @syntax{AT END-OF-PAGE} clause will be triggered, thus executing @term{imperative-statement-1} (@pxref{Imperative Statement}), if the @statement{WRITE} introduces a data line or line-feed character into the file at a line position within the Page Footer area defined by the @syntax{LINAGE} clause.  The @syntax{NOT AT END-OF-PAGE} clause will be triggered (thus executing @term{imperative-statement-2}) if no end-of-page condition occurred during the @syntax{WRITE}.
@end enumerate
@end enumerate
@end enumerate
@iftex
@sp 3
@center ------------------------------------------------------------
@center End of Chapter 6 --- PROCEDURE DIVISION
@end iftex

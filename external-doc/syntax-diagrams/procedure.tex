\chapter{Procedure division}

\section{Concepts}

\subsection{Exceptions}

\begin{itemize}
\item EC-ALL

\item EC-ARGUMENT
  \begin{itemize}
  \item EC-ARGUMENT-FUNCTION
  \item EC-ARGUMENT-IMP
  \end{itemize}
\item EC-BOUND
  \begin{itemize}
  \item EC-BOUND-IMP
  \item EC-BOUND-ODO
  \item EC-BOUND-OVERFLOW
  \item EC-BOUND-PTR
  \item EC-BOUND-REF-MOD
  \item EC-BOUND-SET
  \item EC-BOUND-SUBSCRIPT
  \item EC-BOUND-TABLE-LIMIT
  \end{itemize}

\item EC-DATA
  \begin{itemize}
  \item EC-DATA-CONVERSION
  \item EC-DATA-IMP
  \item EC-DATA-INCOMPATIBLE
  \item EC-DATA-OVERFLOW
  \item EC-DATA-PTR-NULL
  \end{itemize}

\item EC-FLOW
  \begin{itemize}
  \item EC-FLOW-GLOBAL-EXIT
  \item EC-FLOW-GLOBAL-GOBACK
  \item EC-FLOW-IMP
  \item EC-FLOW-RELEASE
  \item EC-FLOW-REPORT
  \item EC-FLOW-RETURN
  \item EC-FLOW-SEARCH
  \item EC-FLOW-USE
  \end{itemize}

\item EC-FUNCTION
  \begin{itemize}
  \item EC-FUNCTION-PTR-INVALID
  \item EC-FUNCTION-PTR-NULL
  \end{itemize}

\item EC-I-O
  \begin{itemize}
  \item EC-I-O-AT-END
  \item EC-I-O-EOP
  \item EC-I-O-EOP-OVERFLOW
  \item EC-I-O-FILE-SHARING
  \item EC-I-O-IMP
  \item EC-I-O-INVALID-KEY
  \item EC-I-O-LINAGE
  \item EC-I-O-LOGIC-ERROR
  \item EC-I-O-PERMANENT-ERROR
  \item EC-I-O-RECORD-OPERATION
  \end{itemize}

\item EC-IMP
  \begin{itemize}
  \item \gnucobol{EC-IMP-ACCEPT}
  \item \gnucobol{EC-IMP-DISPLAY}
  \item \gnucobol{EC-IMP-FEATURE-DISABLED}
  \item \gnucobol{EC-IMP-FEATURE-MISSING}
  \item \gnucobol{EC-IMP-UTC-UNKNOWN}
  \end{itemize}

\item \gnucobol{EC-JSON}
  \begin{itemize}
  \item \gnucobol{EC-JSON-IMP}
  \end{itemize}
  
\item EC-LOCALE
  \begin{itemize}
  \item EC-LOCALE-IMP
  \item EC-LOCALE-INCOMPATIBLE
  \item EC-LOCALE-INVALID
  \item EC-LOCALE-INVALID-PTR
  \item EC-LOCALE-MISSING
  \item EC-LOCALE-SIZE
  \end{itemize}

\item EC-OO
  \begin{itemize}
  \item EC-OO-CONFORMANCE
  \item EC-OO-EXCEPTION
  \item EC-OO-FINALIZABLE
  \item EC-OO-IMP
  \item EC-OO-METHOD
  \item EC-OO-NULL
  \item EC-OO-RESOURCE
  \item EC-OO-UNIVERSAL
  \end{itemize}

\item EC-ORDER
  \begin{itemize}
  \item EC-ORDER-IMP
  \item EC-ORDER-NOT-SUPPORTED
  \end{itemize}

\item EC-OVERFLOW
  \begin{itemize}
  \item EC-OVERFLOW-IMP
  \item EC-OVERFLOW-STRING
  \item EC-OVERFLOW-UNSTRING
  \end{itemize}

\item EC-PROGRAM
  \begin{itemize}
  \item EC-PROGRAM-ARG-MISMATCH
  \item EC-PROGRAM-ARG-OMITTED
  \item EC-PROGRAM-CANCEL-ACTIVE
  \item EC-PROGRAM-IMP
  \item EC-PROGRAM-NOT-FOUND
  \item EC-PROGRAM-PTR-NULL
  \item EC-PROGRAM-RECURSIVE-CALL
  \item EC-PROGRAM-RESOURCES
  \end{itemize}

\item EC-RAISING
  \begin{itemize}
  \item EC-RAISING-IMP
  \item EC-RAISING-NOT-SPECIFIED
  \end{itemize}

\item EC-RANGE
  \begin{itemize}
  \item EC-RANGE-IMP
  \item EC-RANGE-INDEX
  \item EC-RANGE-INSPECT-SIZE
  \item EC-RANGE-INVALID
  \item EC-RANGE-PERFORM-VARYING
  \item EC-RANGE-PTR
  \item EC-RANGE-SEARCH-INDEX
  \item EC-RANGE-SEARCH-NO-MATCH
  \end{itemize}

\item EC-REPORT
  \begin{itemize}
  \item EC-REPORT-ACTIVE
  \item EC-REPORT-COLUMN-OVERLAP
  \item EC-REPORT-FILE-MODE
  \item EC-REPORT-IMP
  \item EC-REPORT-INACTIVE
  \item EC-REPORT-LINE-OVERLAP
  \item EC-REPORT-NOT-TERMINATED
  \item EC-REPORT-PAGE-LIMIT
  \item EC-REPORT-PAGE-WIDTH
  \item EC-REPORT-SUM-SIZE
  \item EC-REPORT-VARYING
  \end{itemize}

\item EC-SCREEN
  \begin{itemize}
  \item EC-SCREEN-FIELD-OVERLAP
  \item EC-SCREEN-IMP
  \item EC-SCREEN-ITEM-TRUNCATED
  \item EC-SCREEN-LINE-NUMBER
  \item EC-SCREEN-STARTING-COLUMN
  \end{itemize}

\item EC-SIZE
  \begin{itemize}
  \item EC-SIZE-ADDRESS
  \item EC-SIZE-EXPONENTIATION
  \item EC-SIZE-IMP
  \item EC-SIZE-OVERFLOW
  \item EC-SIZE-TRUNCATION
  \item EC-SIZE-UNDERFLOW
  \item EC-SIZE-ZERO-DIVIDE
  \end{itemize}

\item EC-SORT-MERGE
  \begin{itemize}
  \item EC-SORT-MERGE-ACTIVE
  \item EC-SORT-MERGE-FILE-OPEN
  \item EC-SORT-MERGE-IMP
  \item EC-SORT-MERGE-RELEASE
  \item EC-SORT-MERGE-RETURN
  \item EC-SORT-MERGE-SEQUENCE
  \end{itemize}

\item EC-STORAGE
  \begin{itemize}
  \item EC-STORAGE-IMP
  \item EC-STORAGE-NOT-ALLOC
  \item EC-STORAGE-NOT-AVAIL
  \end{itemize}

\item EC-USER

\item EC-VALIDATE
  \begin{itemize}
  \item EC-VALIDATE-CONTENT
  \item EC-VALIDATE-FORMAT
  \item EC-VALIDATE-IMP
  \item EC-VALIDATE-RELATION
  \item EC-VALIDATE-VARYING
  \end{itemize}

\item EC-XML
  \begin{itemize}
  \item EC-XML-CODESET
  \item EC-XML-CODESET-CONVERSION
  \item EC-XML-COUNT
  \item EC-XML-DOCUMENT-TYPE
  \item EC-XML-IMPLICIT-CLOSE
  \item EC-XML-INVALID
  \item EC-XML-NAMESPACE
  \item EC-XML-STACKED-OPEN
  \item EC-XML-RANGE
  \end{itemize}
\end{itemize}

\section{Procedure division header}

\begin{syntax}
  \key{PROCEDURE} \key{DIVISION}
  \miscext{
    \begin{0-1}
      \metaelement{call-convention-phrase}
    \end{0-1}
  }
  \miscext{
    \begin{0-1}
      \metaelement{linkage-phrase}
    \end{0-1}
  }
  \begin{0-1}
    \defdmetaelement{using-chaining-clause}
  \end{0-1}
  \begin{0-1}
    \key{RETURNING}
    \begin{1=}
      \identifier \\
      \gnucobol{\key{OMITTED}}
    \end{1=}
  \end{0-1}.\newline
  \begin{0-1}
    \defdmetaelement{declaratives}
  \end{0-1}\newline
  \begin{0-1}
    \metaelement{section-name-2} \key{SECTION}. \\
    \metaelement{paragraph-name-2}. \\
    \imperativestatement .
  \end{0-1} \ldots
\end{syntax}

where \defnmetaelement{using-chaining-clause} is

\begin{syntax}
  \begin{1=}
    \key{USING} \\
    \miscext{\key{CHAINING}}
  \end{1=}

  \begin{1=}
    BY
    \begin{1=}
      \key{REFERENCE} \\
      \pending{\key{VALUE}}
    \end{1=}
    \miscext{
      \begin{0-1}
        \defdmetaelement{param-size}
      \end{0-1}
    }
    \begin{0-1}
      \key{OPTIONAL}
    \end{0-1}
    \identifier
    \miscext{
      \pending{
        \begin{0-1}
          \defdmetaelement{memory-size}
        \end{0-1}
      }
    }
  \end{1=}\ldots
\end{syntax}

where \defnmetaelement{param-size} is

\begin{syntax}[\miscextcolour]
  \begin{0-1}
    \begin{0-1}
      \key{UNSIGNED}
    \end{0-1}
    \key{SIZE} IS
    \begin{1=}
      \key{AUTO} \\
      \integer
    \end{1=} \\

    \key{SIZE} IS \key{DEFAULT}
  \end{0-1}
\end{syntax}

where \defnmetaelement{memory-size} is

\begin{syntax}[\miscextcolour]
  \pending{
    WITH \key{MEMORY} \key{SIZE} IS
    \begin{0-1}
      \identifier \\
      \literal
    \end{0-1}
  }
\end{syntax}

where \defnmetaelement{declaratives} is

\begin{syntax}
  \key{DECLARATIVES}.\newline
  \begin{0-1}
    \metaelement{section-name-1} \key{SECTION}.
    \metaelement{use-statement}
    \begin{0-1}
      \metaelement{paragraph-name-2}. \\
      \imperativestatement .
    \end{0-1} \ldots
  \end{0-1}\ldots\newline
  \key{END} \key{DECLARATIVES}.
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{Common phrases}

\subsection{Call-convention phrase}

\begin{syntax}[\miscextcolour]
  \begin{0-1}
    \key{C} \\
    \key{EXTERN} \\
    \key{PASCAL} \\
    \key{STATIC} \\
    \key{STDCALL} \\
    \mnemonicname
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\subsection{LINKAGE phrase}

\begin{syntax}[\miscextcolour]
  \key{WITH}
  \begin{0-1}
    \key{C} \\
    \key{PASCAL} \\
    \key{STDCALL}
    
  \end{0-1}
  \key{LINKAGE}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\subsection{RETRY phrase}

\begin{syntax}
  \pending{
    \key{RETRY}
    \begin{1=}
      \gnucobol{FOR} \arithmeticexpression \key{TIMES} \\
      FOR \arithmeticexpression \key{SECONDS} \\
      \key{FOREVER}
    \end{1=}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\subsection{ROUNDED phrase}

\begin{syntax}
  \key{ROUNDED}
  \begin{0-1}
    \key{MODE} IS
    \begin{1=}
      \key{AWAY-FROM-ZERO} \\
      \key{NEAREST-AWAY-FROM-ZERO} \\
      \key{NEAREST-EVEN} \\
      \key{NEAREST-TOWARD-ZERO} \\
      \key{PROHIBITED} \\
      \key{TOWARD-GREATER} \\
      \key{TOWARD-LESSER} \\
      \key{TRUNCATION}
    \end{1=}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}


\subsection{SIZE phrase}

\begin{syntax}[\gnucobolcolour]
  \begin{1=}
    \key{SIZE} IS \key{AUTO} \\
    \key{SIZE} IS \key{DEFAULT} \\
    \key{SIZE} IS \integer \\
    \key{UNSIGNED} \key{SIZE} IS \key{AUTO} \\
    \key{UNSIGNED} \key{SIZE} IS \integer
  \end{1=}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ACCEPT statement}

The ACCEPT statement transfers data provided by the user or the operating system to the specified data item.

\format{device}
\begin{syntax}
  \key{ACCEPT}
  \begin{1=}
    \identifier \\
    \miscext{\key{OMITTED}}
  \end{1=}
  \begin{0-1}
    \key{FROM} \mnemonicname
  \end{0-1}
  \begin{0-1}
    \key{END-ACCEPT}
  \end{0-1}
\end{syntax}

\format{screen}
\begin{syntax}
  \key{ACCEPT}
  \begin{1=}
    \miscext{
      \begin{0-1}
        \defdmetaelement{position-specifier}
      \end{0-1}
    }
    \identifier \\
    \miscext{\key{OMITTED}}
  \end{1=}

  \begin{0+}
    \begin{1=}
      \begin{1+}
        AT \key{LINE} NUMBER
        \begin{1=}
          \identifier \\
          \integer
        \end{1=} \\

        AT
        \begin{1=}
          \key{COLUMN} \\
          \key{COL} \\
          \miscext{\key{POSITION}} \\
          \miscext{\key{POS}}
        \end{1=}
        NUMBER
        \begin{1=}
          \identifier \\
          \integer
        \end{1=}
      \end{1+} \\

      \miscext{
        \key{AT}
        \begin{1=}
          \identifier \\
          \integer
        \end{1=}
      }
    \end{1=} \\

    \miscext{\key{FROM} \key{CRT}} \\
    \miscext{\key{MODE} IS \key{BLOCK}} \\
    \miscext{\defdmetaelement{accept-appearance-attribute-clauses}} \\
    \miscext{\defdmetaelement{accept-attribute-clauses}}
  \end{0+}


  \begin{0+}
    ON
    \begin{1=}
      \key{EXCEPTION} \\
      \miscext{\key{ESCAPE}}
    \end{1=}
    \miscext{
      \pending{
        \begin{0-1}
          \identifier
        \end{0-1}
      }
    }
    \imperativestatement \\

    \key{NOT} ON
    \begin{1=}
      \key{EXCEPTION} \\
      \miscext{\key{ESCAPE}}
    \end{1=}
    \miscext{
      \pending{
        \begin{0-1}
          \identifier
        \end{0-1}
      }
    }
    \imperativestatement \\
  \end{0+}

  \begin{0-1}
    \key{END-ACCEPT}
  \end{0-1}
\end{syntax}

where \defnmetaelement{position-specifier} is

\begin{syntax}[\miscextcolour]
  \begin{1=}
    (\ \defdmetaelement{position-specifier-num}\ ,\ \defdmetaelement{position-specifier-num}\ ) \\
    (\ ,\ \defdmetaelement{position-specifier-num}\ ) \\
    (\ \defdmetaelement{position-specifier-num}\ ,\ )
  \end{1=}
\end{syntax}

where \defnmetaelement{position-specifier-num} is

\begin{syntax}[\miscextcolour]
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \begin{0-1}
    \begin{1=}
      + \\
      -
    \end{1=}
    \literal
  \end{0-1}
\end{syntax}

where \defnmetaelement{accept-appearance-attribute-clauses} is

\begin{syntax}[\miscextcolour]
  WITH
  \miscext{
    \begin{0-1}
      \key{NO}
    \end{0-1}
  }
  \begin{1=}
    \key{BELL} \\
    \key{BEEP}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{BLINK} \\
    \key{BLINKING}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{HIGHLIGHT} \\
    \key{HIGH} \\
    \key{BOLD} \\
    \key{LOWLIGHT} \\
    \key{LOW}
  \end{1=} \\

  \pending{WITH \key{STANDARD}} \\

  \pending{WITH \key{BACKGROUND-HIGH}} \\

  \pending{WITH \key{BACKGROUND-STANDARD}} \\

  \pending{WITH \key{BACKGROUND-LOW}} \\

  WITH \key{LEFTLINE} \\

  WITH \key{OVERLINE} \\

  WITH \key{PROMPT}
  \begin{0-1}
    \key{CHARACTER} IS
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0-1} \\

  WITH
  \begin{1=}
    \key{REVERSE-VIDEO} \\
    \key{REVERSED} \\
    \key{REVERSE}
  \end{1=} \\

  \pending{WITH \key{SAME}} \\

  WITH PROTECTED \key{SIZE} IS
  \begin{1=}
    \identifier \\
    \integer
  \end{1=} \\

  WITH
  \begin{1=}
    \key{UNDERLINE} \\
    \key{UNDERLINED}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{FOREGROUND-COLOR} \\
    \key{FOREGROUND-COLOUR}
  \end{1=}
  IS
  \begin{1=}
    \identifier \\
    \integer
  \end{1=} \\

  WITH
  \begin{1=}
    \key{BACKGROUND-COLOR} \\
    \key{BACKGROUND-COLOUR}
  \end{1=}
  IS
  \begin{1=}
    \identifier \\
    \integer
  \end{1=} \\

  \pending{
    WITH
    \begin{1=}
      \key{COLOR} \\
      \key{COLOUR}
    \end{1=}
    IS
    \begin{1=}
      \identifier \\
      \integer
    \end{1=}
  } \\

  WITH \key{SCROLL}
  \begin{1=}
    UP \\
    \key{DOWN}
  \end{1=}
  \begin{0-1}
    \begin{1=}
      \identifier \\
      \integer
    \end{1=}
    \begin{1=}
      \key{LINE} \\
      \key{LINES}
    \end{1=}
  \end{0-1}
\end{syntax}

where \defnmetaelement{accept-attribute-clauses} is

\begin{syntax}[\miscextcolour]
  WITH
  \begin{1=}
    \key{AUTO} \\
    \key{TAB}
  \end{1=} \\

  \pending{
    WITH CONTROL \key{KEY} IN \identifier
  }

  WITH
  \begin{1=}
    \key{CONVERSION} \\
    \key{CONVERT}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{FULL} \\
    \key{LENGTH-CHECK} \\
  \end{1=} \\

  WITH
  \begin{1=}
    \key{LOWER} \\
    \key{UPPER}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{NO-ECHO} \\
    \key{NO} \key{ECHO} \\
    \key{OFF}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{REQUIRED} \\
    \key{EMPTY-CHECK}
  \end{1=} \\

  WITH \key{SECURE} \\

  WITH
  \begin{0-1}
    \key{NO}
  \end{0-1}
  \begin{1=}
    \key{DEFAULT} \\
    \key{UPDATE}
  \end{1=} \\

  \begin{1=}
    \key{WITH}
    % TIME-OUT is context-sensitive, so WITH is required.
    \begin{1=}
      \key{TIMEOUT} \\
      \key{TIME-OUT} \\
    \end{1=}
    AFTER \\
    BEFORE \key{TIME}
  \end{1=}
  \begin{1=}
    \identifier \\
    \integer
  \end{1=}
\end{syntax}

% Shouldn't all the clauses except AT LINE/COLUMN be miscext?

\format{temporal}
\begin{syntax}
  \key{ACCEPT} \identifier \key{FROM}
  \begin{1=}
    \key{DATE}
    \begin{0-1}
      \key{YYYYMMDD}
    \end{0-1} \\

    \key{DAY}
    \begin{0-1}
      \key{YYYYDDD}
    \end{0-1} \\

    \key{DAY-OF-WEEK} \\
    \key{TIME} \\
  \end{1=}
\end{syntax}

\format{environment}
\begin{syntax}[\miscextcolour]
  \key{ACCEPT} \identifier \key{FROM}
  \begin{1=}
    \key{ARGUMENT-NUMBER} \\

    \begin{1=}
      \key{COLUMNS} \\
      \key{COLS}
    \end{1=} \\

    \key{COMMAND-LINE} \\
    \key{ESCAPE} KEY \\
    \key{EXCEPTION} \key{STATUS} \\
    \pending{\key{INPUT} \key{STATUS}} \\

    \begin{1=}
      \key{LINES} \\
      \key{LINE} \key{NUMBER}
    \end{1=} \\

    \pending{\key{TERMINAL-INFO}} \\
    \pending{\key{SYSTEM-INFO}} \\
    \key{USER} \key{NAME} \\
    \key{WORD}
  \end{1=}
\end{syntax}

\format{environment-exception}
\begin{syntax}[\miscextcolour]
  \begin{minipage}[!h]{1.0\linewidth}
    \key{ACCEPT} \identifier \key{FROM}
    \begin{1=}
      \key{ARGUMENT-VALUE} \\
      \key{ENVIRONMENT}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=} \\
      \key{ENVIRONMENT-VALUE} \\
    \end{1=}

    \begin{0+}
      ON
      \begin{1=}
        \key{EXCEPTION} \\
        \key{ESCAPE}
      \end{1=}
      \pending{
        \begin{0-1}
          \identifier
        \end{0-1}
      }
      \imperativestatement \\

      \key{NOT} ON
      \begin{1=}
        \key{EXCEPTION} \\
        \key{ESCAPE}
      \end{1=}
      \pending{
        \begin{0-1}
          \identifier
        \end{0-1}
      }
      \imperativestatement \\
    \end{0+}
  \end{minipage}
\end{syntax}

\format{message}
\begin{syntax}[\deletedcolour]
  \pending{\key{ACCEPT} \cdname MESSAGE \key{COUNT}}
\end{syntax}

\format{from screen}
\begin{syntax}[\miscextcolour]
  \pending{
    \key{ACCEPT} \identifier \key{FROM} \key{SCREEN}

    \begin{1=}
      \begin{1=}
        \begin{1+}
          AT \key{LINE} NUMBER
          \begin{1=}
            \identifier \\
            \integer
          \end{1=} \\

          AT
          \begin{1=}
            \key{COLUMN} \\
            \key{COL} \\
            \miscext{\key{POSITION}} \\
            \miscext{\key{POS}}
          \end{1=}
          NUMBER
          \begin{1=}
            \identifier \\
            \integer
          \end{1=}
        \end{1+} \\

        \miscext{
          \key{AT}
          \begin{1=}
            \identifier \\
            \integer
          \end{1=}
        }
      \end{1=} \\

      \key{SIZE} IS
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{1=}\ldots
  }
\end{syntax}

\subsubsection{Syntax rules}

\paragraph{Format 2}
\begin{enumerate}
\item Position specifiers may not be used with any of the ON EXCEPTION clauses.
\end{enumerate}

\subsubsection{General rules}

\section{ADD statement}

The ADD statement adds two or more numbers and stores the result.

\format{simple}
\begin{syntax}
  \key{ADD}
  \begin{1=}
    \identifier \\
    \literal \\
  \end{1=} \ldots
  \key{TO}
  \begin{1=}
    \identifier
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-ADD}
  \end{0-1}
\end{syntax}

\format{giving}
\begin{syntax}
  \key{ADD}
  \begin{1=}
    \identifier \\
    \literal \\
  \end{1=} \ldots
  \begin{0-1}
    \key{TO}
    \begin{0-1}
      \identifier
    \end{0-1} \ldots
  \end{0-1}

  \key{GIVING}
  \begin{1=}
    \identifier
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-ADD}
  \end{0-1}
\end{syntax}

\format{corresponding}
\begin{syntax}
  \key{ADD}
  \begin{1=}
    \key{CORRESPONDING} \\
    \key{CORR}
  \end{1=}
  \identifier \key{TO} \identifier
  \begin{0-1}
    \metaelement{rounded-phrase}
  \end{0-1}

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-ADD}
  \end{0-1}
\end{syntax}

\format{table}
\begin{syntax}
  \pending{
    \key{ADD} \key{TABLE} \identifier \key{TO} \identifier
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  }

  \pending{
    \begin{0-1}
      \key{FROM} INDEX \integer \key{TO} \integer
    \end{0-1}
  }

  \pending{
    \begin{0-1}
      \key{DESTINATION} INDEX \integer
    \end{0-1}
  }

  \pending{
    \begin{0+}
      ON \key{SIZE} \key{ERROR} \imperativestatement \\
      \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
    \end{0+}
  }

  \pending{
    \begin{0-1}
      \key{END-ADD}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ALLOCATE statement}

The ALLOCATE statement requests memory from the operating system for a BASED data item or to be referenced by a data-pointer.

\begin{syntax}
  \key{ALLOCATE}
  \begin{1=}
    \identifier
    \begin{0-1}
      \key{INITIALIZED}
    \end{0-1} \\
    \arithmeticexpression
    \begin{0-1}
      \key{INITIALIZED}
      \gnucobol{
        \begin{0-1}
          \key{TO}
          \begin{1=}
            \identifier \\
            \literal
          \end{1=}
        \end{0-1}
      }
    \end{0-1}
  \end{1=}

  \miscext{
    \pending{
      \begin{0-1}
        \key{LOC}
        \begin{1=}
          24 \\
          31
        \end{1=}
      \end{0-1}
    }
  }

  \begin{0-1}
    \key{RETURNING} \identifier
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ALTER statement}

The ALTER statement changes the target of a GO TO statement. Its use is strongly discouraged and commonly proscribed.

\begin{syntax}[\deletedcolour]
    \key{ALTER}
    \begin{1=}
      \procedurename TO PROCEED \key{TO} \procedurename
    \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{CALL statement}

The CALL statement transfers execution to another program, optionally with arguments and storing a return value.

\begin{syntax}
  \key{CALL}

  \miscext{
    \begin{0-1}
      \metaelement{call-convention-phrase}
    \end{0-1}
    \begin{0-1}
      \pending{IN \key{THREAD}}
    \end{0-1}
    \begin{0-1}
      \metaelement{linkage-phrase}
    \end{0-1}
  }

  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal \\
      \functionname
    \end{1=} \\

    \begin{0-1}
      \begin{1=}
        \identifier \\
        \literal \\
        \functionname
      \end{1=}
      \key{AS}
    \end{0-1}
    \begin{1=}
      \pending{\key{NESTED}} \\
      \metaelement{program-prototype-name}
    \end{1=}
  \end{1=}

  \miscext{
    \begin{0-1}
      \pending{\key{HANDLE} IN \identifier}
    \end{0-1}
  }

  \begin{0-1}
    \key{USING}
    \begin{1=}
      \begin{0-1}
        BY
        \begin{1=}
          \key{REFERENCE} \\
          \key{CONTENT} \\
          \key{VALUE}
        \end{1=}
      \end{0-1}
      \begin{1=}
        \key{OMITTED} \\

        \gnucobol{
          \begin{0-1}
            size-phrase
          \end{0-1}
        }
        \begin{1=}
          \identifier \\
          \literal
        \end{1=}
      \end{1=}
    \end{1=}\ldots
  \end{0-1}

  \begin{0-1}
    \begin{1=}
      \key{RETURNING} \\
      \miscext{\key{GIVING}}
    \end{1=}
    \begin{1=}
      \miscext{INTO} \identifier \\
      \key{ADDRESS} OF \identifier \\
      \gnucobol{\key{NOTHING}} \\
      \miscext{\key{NULL}} \\ % TO-DO: Check this is not GnuCOBOL-only.
      \miscext{\key{OMITTED}} \\ % TO-DO: Check this is not GnuCOBOL-only.
    \end{1=}
  \end{0-1}

  \begin{0+}
    ON
    \begin{1=}
      \key{EXCEPTION} \\
      \archaic{\key{OVERFLOW}}
    \end{1=}
    \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-CALL}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{CANCEL statement}

The CANCEL statement unloads a program from the operating system memory. This has the effect of freeing all the program's working-storage items and closing all files the program left open.

\begin{syntax}
  \key{CANCEL}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{CLOSE statement}

The CLOSE statement prevents the program from accessing or modifying an open file. It first processes all pending writes for the file and releases all locks still held in the file.

\format{file}
\begin{syntax}
  \key{CLOSE}
  \begin{1=}
    \filename
    \begin{0-1}
      \begin{1=}
        \key{REEL} \\
        \key{UNIT}
      \end{1=}
      \begin{0-1}
        FOR \key{REMOVAL}
      \end{0-1} \\

      WITH \key{NO} \key{REWIND} \\
      WITH \key{LOCK}
    \end{0-1}
  \end{1=} \ldots
\end{syntax}

\format{window}
\begin{syntax}[\miscextcolour]
  \pending{
    \key{CLOSE} \key{WINDOW} \identifier
    \begin{0-1}
      WITH \key{NO} \key{DISPLAY}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{COMMIT statement}

The COMMIT statement forces all pending file writes to be processed.

\begin{syntax}[\miscextcolour]
  \key{COMMIT}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{COMPUTE statement}

The COMPUTE statement evaluates an arithmetic expression and stores the result.

\begin{syntax}
  \key{COMPUTE}
  \begin{1=}
    \identifier
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots
  \begin{1=}
    = \\
    \miscext{\key{EQUAL}} \\
    \miscext{\key{EQUALS}}
  \end{1=}
  \arithmeticexpression

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-COMPUTE}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{CONTINUE statement}

The plain format of the CONTINUE statement has no effect on program execution. The after format of the CONTINUE statement pauses execution for a specified length of time.

\format{plain}
\begin{syntax}
  \key{CONTINUE}
\end{syntax}

\format{after}
\begin{syntax}
  \key{CONTINUE} \key{AFTER} \expression \key{SECONDS}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{DELETE statement}

The DELETE statement removes a record from a file or removes an entire file.

\format{record}
\begin{syntax}
  \key{DELETE} \filename RECORD

  \begin{0-1}
    \metaelement{retry-phrase}
  \end{0-1}

  \begin{0+}
    \key{INVALID} KEY \imperativestatement \\
    \key{NOT} \key{INVALID} KEY \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-DELETE}
  \end{0-1}
\end{syntax}

\format{file}
\begin{syntax}[\miscextcolour]
  \key{DELETE} \key{FILE}
  \begin{1=}
    \filename
  \end{1=} \ldots
  \gnucobol{
    \begin{0-1}
      \key{END-DELETE}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{DESTROY statement}

\begin{syntax}[\miscextcolour]
  \pending{
    \key{DESTROY}
    \begin{1=}
      \key{ALL} CONTROLS \\
      \identifier\ldots
    \end{1=}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{DISABLE statement}

The DISABLE statement prevents the program from modifying or accessing an enabled communication descriptor.

\begin{syntax}[\deletedcolour]
  \pending{
    \key{DISABLE}
    \begin{0-1}
      \key{INPUT} TERMINAL \\
      \key{OUTPUT} \\
      \key{I-O} \key{TERMINAL} \\
      \miscext{\key{TERMINAL}}
    \end{0-1}
    \cdname
    \begin{0-1}
      WITH \key{KEY}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{DISPLAY statement}

The DISPLAY statement displays data to a user or sends data to the operating system.

\format{device}
\begin{syntax}
  \key{DISPLAY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=} \ldots
  \begin{0+}
    \key{UPON} \mnemonicname \\
    WITH \key{NO} \key{ADVANCING}
  \end{0+}

  \begin{0+}
    ON \key{EXCEPTION} \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement \\
  \end{0+}

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{environment}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{UPON}
  \begin{1=}
    \key{ARGUMENT-NUMBER} \\
    \key{COMMAND-LINE} \\
    \key{ENVIRONMENT-NAME} \\
    \key{ENVIRONMENT-VALUE} \\
  \end{1=}

  \begin{0+}
    ON \key{EXCEPTION} \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement \\
  \end{0+}

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{screen}
\begin{syntax}
  \key{DISPLAY}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \miscext{\literal} \\
      \miscext{\key{OMITTED}}
    \end{1=}

    \begin{0+}
      \defdmetaelement{position-clauses} \\

      \miscext{
        \key{UPON}
        \begin{1=}
          \key{CRT} \\
          \key{CRT-UNDER}
        \end{1=}
      } \\

      \miscext{\key{MODE} IS \key{BLOCK}} \\
      \miscext{\defdmetaelement{display-appearance-attribute-clauses}}
    \end{0+}
  \end{1=} \miscext{\ldots}

  \begin{0+}
    ON \key{EXCEPTION} \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement \\
  \end{0+}

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{Microsoft screen}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY}
  \begin{1=}
    \key{ERASE} \\

    \defdmetaelement{disp-position-specifier}
    \begin{1=}
      \identifier \\
      \literal \\
      \key{ERASE}
    \end{1=}\ldots
  \end{1=}

  \begin{0-1}
    \key{WITH}
    \begin{1=}
      \defdmetaelement{display-appearance-attribute-clauses}
    \end{1=}\ldots
  \end{0-1}

  \gnucobol{
    \begin{0-1}
      \key{END-DISPLAY}
    \end{0-1}
  }
\end{syntax}

\format{ordinary window}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY}
  \begin{1=}
    \key{WINDOW} \\
    \key{SUBWINDOW}
  \end{1=}
  \begin{0-1}
    \key{UPON} \identifier
  \end{0-1}

  \begin{1=}
    \key{POP-UP} AREA IS \identifier \\

    \key{HANDLE}
    \begin{0-1}
      IS \\
      IN
    \end{0-1}
    \identifier \\

    \key{LINES} \integer \\

    \key{TITLE} IS
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    WITH \key{NO}
    \begin{0-1}
      \key{SCROLL} \\
      \key{WRAP}
    \end{0-1} \\

    \begin{0-1}
      \key{SHADOW} \\
      \key{BOXED}
    \end{0-1} \\

    \defdmetaelement{position-clauses} \\
    \defdmetaelement{display-appearance-attribute-clauses}
  \end{1=}\ldots

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{floating window}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY} \key{FLOATING}
  \begin{0-1}
    \key{GRAPHICAL}
  \end{0-1}
  \key{WINDOW}
  \begin{0-1}
    \key{UPON} \identifier
  \end{0-1}

  \begin{1=}
    \key{POP-UP} AREA IS \identifier \\

    \key{HANDLE}
    \begin{0-1}
      IS \\
      IN
    \end{0-1}
    \identifier \\

    \key{LINES} \integer \\

    \key{TITLE} IS
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    WITH \key{NO}
    \begin{0-1}
      \key{SCROLL} \\
      \key{WRAP}
    \end{0-1} \\

    \begin{0-1}
      \key{SHADOW} \\
      \key{BOXED}
    \end{0-1} \\

    \defdmetaelement{position-clauses} \\
    \defdmetaelement{display-appearance-attribute-clauses}
  \end{1=}\ldots

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{special window}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY}
  \begin{1=}
    \key{INITIAL} \\
    \key{STANDARD} \\
    \key{INDEPENDENT}
  \end{1=}
  \begin{0-1}
    \key{GRAPHICAL}
  \end{0-1}
  \key{WINDOW}
  \begin{0-1}
    \key{UPON} \identifier
  \end{0-1}

  \begin{1=}
    \key{POP-UP} AREA IS \identifier \\

    \key{HANDLE}
    \begin{0-1}
      IS \\
      IN
    \end{0-1}
    \identifier \\

    \key{LINES} \integer \\

    \key{TITLE} IS
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    WITH \key{NO}
    \begin{0-1}
      \key{SCROLL} \\
      \key{WRAP}
    \end{0-1} \\

    \begin{0-1}
      \key{SHADOW} \\
      \key{BOXED}
    \end{0-1} \\

    \defdmetaelement{position-clauses} \\
    \defdmetaelement{display-appearance-attribute-clauses}
  \end{1=}\ldots

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

\format{message box}
\begin{syntax}[\miscextcolour]
  \key{DISPLAY} \key{MESSAGE} BOX
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}\ldots

  \begin{0-1}
    \key{TITLE}
    \begin{0-1}
      IS \\
      =
    \end{0-1}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    \key{TYPE}
    \begin{0-1}
      IS \\
      =
    \end{0-1}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    \key{ICON}
    \begin{0-1}
      IS \\
      =
    \end{0-1}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    \key{DEFAULT}
    \begin{0-1}
      IS \\
      =
    \end{0-1}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    \begin{1=}
      \key{RETURNING} \\
      \key{GIVING}
    \end{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\
  \end{0-1}\ldots

  \begin{0-1}
    \key{END-DISPLAY}
  \end{0-1}
\end{syntax}

where \defnmetaelement{position-clauses} is

\begin{syntax}
  \begin{1=}
    \begin{1+}
      \key{LINE} NUMBER
      \begin{1=}
        \identifier \\
        \literal
      \end{1=} \\

      \key{AT}
      \begin{1=}
        \key{COLUMN} \\
        \key{COL} \\
        \miscext{\key{POSITION}} \\
        \miscext{\key{POS}}
      \end{1=}
      NUMBER
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{1+} \\


    \miscext{
      \key{AT}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    }
  \end{1=}
\end{syntax}

where \defnmetaelement{display-appearance-attribute-clauses} is

\begin{syntax}[\miscextcolour]
  WITH
  \begin{1=}
    \key{BELL} \\
    \key{BEEP} \\
  \end{1=} \\

  WITH \key{BLANK}
  \begin{1=}
    \key{LINE} \\
    \key{SCREEN}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{BLINK} \\
    \key{BLINKING}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{CONVERSION} \\
    \key{CONVERT}
  \end{1=} \\

  WITH \key{ERASE}
  \begin{1=}
    \key{EOL} \\
    \key{EOS} \\

    \begin{0-1}
      \miscext{TO} \key{END} OF
    \end{0-1}
    \begin{1=}
      \key{LINE} \\
      \key{SCREEN}
    \end{1=}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{HIGHLIGHT} \\
    \key{HIGH} \\
    \key{BOLD} \\
    \key{LOWLIGHT} \\
    \key{LOW}
  \end{1=} \\

  \pending{WITH \key{STANDARD}} \\
  \pending{WITH \key{BACKGROUND-HIGH}} \\
  \pending{WITH \key{BACKGROUND-STANDARD}} \\
  \pending{WITH \key{BACKGROUND-LOW}} \\

  WITH \key{OVERLINE} \\

  WITH
  \begin{1=}
    \key{REVERSE-VIDEO} \\
    \key{REVERSED} \\
    \key{REVERSE}
  \end{1=} \\

  \pending{WITH \key{SAME}} \\

  WITH \key{SIZE} IS
  \begin{1=}
    \identifier \\
    \literal
  \end{1=} \\

  WITH
  \begin{1=}
    \key{UNDERLINE} \\
    \key{UNDERLINED}
  \end{1=} \\

  WITH
  \begin{1=}
    \key{FOREGROUND-COLOR} \\
    \key{FOREGROUND-COLOUR}
  \end{1=}
  \begin{0-1}
    IS \\
    =
  \end{0-1}
  \begin{1=}
    \identifier \\
    \integer
  \end{1=} \\

  WITH
  \begin{1=}
    \key{BACKGROUND-COLOR} \\
    \key{BACKGROUND-COLOUR}
  \end{1=}
  \begin{0-1}
    IS \\
    =
  \end{0-1}
  \begin{1=}
    \identifier \\
    \integer
  \end{1=} \\

  \pending{
    WITH
    \begin{1=}
      \key{COLOR} \\
      \key{COLOUR}
    \end{1=}
    IS
    \begin{1=}
      \identifier \\
      \integer
    \end{1=}
  } \\

  WITH \key{SCROLL}
  \begin{1=}
    UP \\
    \key{DOWN}
  \end{1=}
  \begin{0-1}
    \begin{1=}
      \identifier \\
      \integer
    \end{1=}
    \begin{1=}
      \key{LINE} \\
      \key{LINES}
    \end{1=}
  \end{0-1}
\end{syntax}

where \defnmetaelement{disp-position-specifier} is

\begin{syntax}[\miscextcolour]
  \begin{1=}
    (\ \defdmetaelement{disp-position-specifier-num}\ ,\ \defdmetaelement{disp-position-specifier-num}\ ) \\
    (\ ,\ \defdmetaelement{disp-position-specifier-num}\ ) \\
    (\ \defdmetaelement{disp-position-specifier-num}\ ,\ )
  \end{1=}
\end{syntax}

where \defnmetaelement{disp-position-specifier-num} is

\begin{syntax}[\miscextcolour]
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \begin{0-1}
    \begin{1=}
      + \\
      -
    \end{1=}
    \literal
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{DIVIDE statement}

The DIVIDE statement divides one or more numbers by another and stores the results.

\format{into}
\begin{syntax}
  \key{DIVIDE}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{INTO}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-DIVIDE}
  \end{0-1}
\end{syntax}

\format{giving}
\begin{syntax}
  \key{DIVIDE}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \begin{1=}
    \key{BY} \\
    \key{INTO}
  \end{1=}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}

  \key{GIVING}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=}
  \ldots

  \begin{0-1}
    \key{REMAINDER}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0-1}

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-DIVIDE}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ENABLE statement}

The ENABLE statement allows the program to access and modify a communication descriptor.

\begin{syntax}[\deletedcolour]
  \pending{
    \key{ENABLE}
    \begin{0-1}
      \key{INPUT} TERMINAL \\
      \key{OUTPUT} \\
      \key{I-O} \key{TERMINAL} \\
      \miscext{\key{TERMINAL}}
    \end{0-1}
    \cdname
    \begin{0-1}
      WITH \key{KEY}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ENTRY statement}

The ENTRY statement indicates an alternative point of entry into the program.

\begin{syntax}[\miscextcolour]
  \key{ENTRY} 
  \begin{0-1}
    \metaelement{call-convention-phrase}
  \end{0-1}
  \literal
  
  \begin{0-1}
    \metaelement{linkage-phrase}
  \end{0-1}

  \begin{0-1}
    \key{USING}

    \begin{1=}
      \begin{0-1}
        BY
        \begin{1=}
          \key{REFERENCE} \\
          \gnucobol{\key{CONTENT}} \\
          \key{VALUE}
        \end{1=}
      \end{0-1}

      \begin{1=}
        \gnucobol{\key{OMITTED}} \\

        \begin{1=}
          \gnucobol{
            \begin{0-1}
              size-phrase
            \end{0-1}
          }
          \begin{1=}
            \identifier \\
            \literal
          \end{1=}
        \end{1=}
      \end{1=}\ldots
    \end{1=}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{EVALUATE statement}

The EVALUATE statement evaluates one or more conditions and execute the statements corresponding to the first true condition.

\begin{syntax}
  \key{EVALUATE}
  \begin{1=}
    \expression \\
    \key{TRUE} \\
    \key{FALSE}
  \end{1=}
  \begin{0-1}
    \key{ALSO}
    \begin{1=}
      \expression \\
      \key{TRUE} \\
      \key{FALSE}
    \end{1=}
  \end{0-1} \ldots

  \begin{1=}
    \key{WHEN}
    \defdmetaelement{selection-object}
    \begin{0-1}
      \key{ALSO} \defdmetaelement{selection-object}
    \end{0-1}\ldots\ {}
    \imperativestatement
  \end{1=} \ldots

  \begin{0-1}
    \key{WHEN} \key{OTHER} \imperativestatement
  \end{0-1}

  \begin{0-1}
    \key{END-EVALUATE}
  \end{0-1}
\end{syntax}

where \defnmetaelement{selection-object} is

\begin{syntax}
  \begin{1=}
    \metaelement{partial-expression-1}
    \begin{0-1}
      \begin{1=}
        \key{THROUGH} \\
        \key{THRU}
      \end{1=}
      \expression
    \end{0-1} \\

    \key{ANY} \\
    \key{TRUE} \\
    \key{FALSE}
  \end{1=}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{EXIT statement}

The EXIT statement indicates the end of a path of execution.

\begin{syntax}
  \key{EXIT}
  \begin{0-1}
    \key{FUNCTION} \\
    \key{PARAGRAPH} \\

    \key{PERFORM}
    \begin{0-1}
      \key{CYCLE}
    \end{0-1} \\

    \key{PROGRAM}
    \miscext{
      \begin{0-1}
        \begin{1=}
          \key{RETURNING} \\
          \key{GIVING}
        \end{1=}
      \end{0-1}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    } \\

    \key{SECTION} \\
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{FREE statement}

The FREE statement returns memory to the operating system.

\begin{syntax}
  \key{FREE}
  \begin{1=}
    \identifier
  \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{GENERATE statement}

The GENERATE statement a specified report entry.

\begin{syntax}
  \key{GENERATE} \reportname
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{GO TO statement}

The GO TO statement transfer execution to another part of the program.

\begin{syntax}
  \key{GO} TO
  \begin{1=}
    \procedurename
  \end{1=} \ldots
  \begin{0-1}
    \key{DEPENDING} ON \identifier
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{GOBACK statement}

The GOBACK statement terminates execution in the program, returning control to the calling program or, if no such program exists, to the operating system.

\begin{syntax}
  \key{GOBACK}
  \begin{0-1}
    \begin{1=}
      \key{RETURNING} \\
      \miscext{\key{GIVING}}
    \end{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{IF statement}

The IF statement evaluates a condition and executes statements depending on whether the condition was true or false.

\begin{syntax}
  \key{IF} \metaelement{condition} THEN
  \begin{1=}
    \imperativestatement \\
    \key{ELSE} \imperativestatement
  \end{1=} \ldots

  \begin{0-1}
    \key{END-IF}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{INITIALIZE statement}

The INITIALIZE statement sets data items to their default values.

\begin{syntax}
  \begin{1=}
    \key{INITIALIZE} \\
    \miscext{\key{INITIALISE}}
  \end{1=}
  \begin{1=}
    \identifier \\
    \metaelement{basic-literal-1}
  \end{1=} \ldots
  \begin{0-1}
    WITH \key{FILLER}
  \end{0-1}

  \begin{0-1}
    \begin{1=}
      \key{ALL} \\
      \key{ALPHABETIC} \\
      \key{ALPHANUMERIC} \\
      \key{ALPHANUMERIC-EDITED} \\
      \key{NATIONAL} \\
      \key{NATIONAL-EDITED} \\
      \key{NUMERIC} \\
      \key{NUMERIC-EDITED}
    \end{1=}
    TO \key{VALUE}
  \end{0-1}

  \begin{0-1}
    \key{REPLACING}
    \begin{1=}
      \begin{1=}
        \key{ALPHABETIC} \\
        \key{ALPHANUMERIC} \\
        \key{ALPHANUMERIC-EDITED} \\
        \key{NATIONAL} \\
        \key{NATIONAL-EDITED} \\
        \key{NUMERIC} \\
        \key{NUMERIC-EDITED}
      \end{1=}
      DATA \key{BY}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{1=} \ldots
  \end{0-1}

  \begin{0-1}
    THEN TO \key{DEFAULT}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{INITIATE statement}

The INITIATE statement allows the program to begin generating the specified report.

\begin{syntax}
  \key{INITIATE}
  \begin{1=}
    \reportname
  \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{INQUIRE statement}

\format{control}
\begin{syntax}[\miscextcolour]
  \key{INQUIRE}
  \begin{1=}
    \identifier \\
    \key{CONTROL}
  \end{1=}
  \begin{1=}
    \begin{1=}
      \metaelement{control-property} \\
      \key{LAYOUT-DATA}
    \end{1=}
    \begin{0-1}
      IN \\
      =
    \end{0-1}
    \identifier
  \end{1=} \ldots
\end{syntax}

\format{window}
\begin{syntax}[\miscextcolour]
  \key{INQUIRE}
  \begin{1=}
    \identifier \\

    \key{WINDOW}
    \begin{0-1}
      \identifier
    \end{0-1}
  \end{1=}
  \begin{1=}
    \begin{1=}
      \key{LAYOUT-MANAGER} \\
      \key{SIZE} \\
      \key{TITLE}
    \end{1=}
    \begin{0-1}
      IN \\
      =
    \end{0-1}
    \identifier
  \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{INSPECT statement}

The INSPECT statement counts the number of occurrences of a character string, replaces occurrences or both.

\begin{syntax}
  \key{INSPECT}
  \begin{1=}
    \identifier \\
    \literal \\
    \functionname
  \end{1=}
  \begin{1=}
    \defdmetaelement{tallying-phrase}
    \begin{0-1}
      \defdmetaelement{replacing-phrase}
    \end{0-1} \\

    \defdmetaelement{replacing-phrase} \\
    \defdmetaelement{converting-phrase}
  \end{1=}
\end{syntax}

where \defnmetaelement{tallying-phrase} is

\begin{syntax}
  \key{TALLYING}
  \begin{1=}
    \begin{1=}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
      \key{FOR}
      \begin{1=}
        \key{CHARACTERS} \\

        \begin{1=}
          \key{ALL} \\
          \key{LEADING} \\
          \key{TRAILING}
        \end{1=}
        \begin{1=}
          \identifier \\
          \literal
        \end{1=}
      \end{1=}
    \end{1=}\ldots
    \begin{0-1}
      \defdmetaelement{before-after-phrase}
    \end{0-1}
  \end{1=} \ldots
\end{syntax}

where \defnmetaelement{replacing-phrase} is

\begin{syntax}
  \key{REPLACING}
  \begin{1=}
    \begin{1=}
      \key{CHARACTERS} \\

      \begin{0-1}
        \key{ALL} \\
        \key{LEADING} \\
        \key{FIRST} \\
        \key{TRAILING}
      \end{0-1}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{1=}
    \key{BY}
    \begin{1=}
      \identifier \\
      \literal \\
    \end{1=}
    \begin{0-1}
      \defdmetaelement{before-after-phrase}
    \end{0-1} \\
  \end{1=} \ldots
\end{syntax}

where \defnmetaelement{converting-phrase} is

\begin{syntax}
  \key{CONVERTING}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{TO}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \begin{0-1}
    \defdmetaelement{before-after-phrase}
  \end{0-1}
\end{syntax}

where \defnmetaelement{before-after-phrase} is

\begin{syntax}
  \begin{0+}
    \key{BEFORE} INITIAL
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    \key{AFTER} INITIAL
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0+}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{JSON GENERATE statement}

The JSON GENERATE statement converts a JSON record based on the structure and content of the input data item.

\begin{syntax}[\miscextcolour]
  \key{JSON} \key{GENERATE} \identifier \key{FROM} \identifier

  \begin{0-1}
    \key{COUNT} IN \identifier
  \end{0-1}

  \begin{0-1}
    \key{NAME} OF
    \begin{1=}
      \identifier IS \literal
    \end{1=}\dots
  \end{0-1}

  \begin{0-1}
    \key{SUPPRESS}
    \begin{1=}
      \identifier
    \end{1=} \dots
  \end{0-1}

  \begin{0+}
    ON \key{EXCEPTION} \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-JSON}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{JSON PARSE statement}

The JSON PARSE statement starts an event-driven JSON parser; the processing procedure is performed as each component of the JSON document is identified in order.

\pending{
  \begin{syntax}[\miscextcolour]
    \key{JSON} \key{PARSE} \identifier \key{INTO} \identifier

    \begin{0-1}
      WITH \key{DETAIL}
    \end{0-1}

    \begin{0-1}
      \key{NAME} OF
      \begin{1=}
        \identifier IS \literal
      \end{1=}\dots
    \end{0-1}

    \begin{0-1}
      \key{SUPPRESS}
      \begin{1=}
        \identifier
      \end{1=} \dots
    \end{0-1}

    \begin{0+}
      ON \key{EXCEPTION} \imperativestatement \\
      \key{NOT} ON \key{EXCEPTION} \imperativestatement
    \end{0+}

    \begin{0-1}
      \key{END-JSON}
    \end{0-1}
  \end{syntax}
}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{MERGE statement}

The MERGE statement reads multiple files with the same record desciption, combines their records and sorts them.

\begin{syntax}
  \key{MERGE} \identifier
  \begin{0-1}
    ON
    \begin{1=}
      \key{ASCENDING} \\
      \key{DESCENDING}
    \end{1=}
    KEY
    \begin{0-1}
      \identifier
    \end{0-1}\ldots
  \end{0-1} \ldots

  \begin{0-1}
    WITH \key{DUPLICATES}
    \begin{0-1}
      IN \key{ORDER}
    \end{0-1}
  \end{0-1}

  \begin{0-1}
    COLLATING \key{SEQUENCE} IS
    \begin{1=}
      IS \metaelement{alphanumeric-collating-sequence}
      \pending{
        \begin{0-1}
          \metaelement{national-collating-sequence}
        \end{0-1}
      } \\

      \begin{1+}
        FOR \key{ALPHANUMERIC} IS \metaelement{alphanumeric-collating-sequence} \\
        \pending{FOR \key{NATIONAL} IS \metaelement{national-collating-sequence}}
      \end{1+}
    \end{1=}
  \end{0-1}

  \begin{0-1}
    \key{USING}
    \begin{1=}
      \filename
    \end{1=}\ldots
  \end{0-1}

  \begin{0-1}
    \key{GIVING}
    \begin{1=}
      \filename
    \end{1=}\ldots \\

    \key{OUTPUT} \key{PROCEDURE} IS
    \procedurename
    \begin{0-1}
      \begin{1=}
        \key{THROUGH} \\
        \key{THRU}
      \end{1=}
      \procedurename
    \end{0-1}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{MODIFY statement}


\format{control}
\begin{syntax}[\miscextcolour]
  \key{MODIFY}
  \begin{1=}
    \identifier \\
    \key{CONTROL}
  \end{1=}
  \begin{1=}
    \metaelement{control-attributes}
  \end{1=} \ldots

  \begin{0-1}
    \key{END-MODIFY}
  \end{0-1}
\end{syntax}

\format{window}
\begin{syntax}[\miscextcolour]
  \key{MODIFY}
  \begin{1=}
    \identifier \\

    \key{WINDOW}
    \begin{0-1}
      \identifier
    \end{0-1}
  \end{1=}
  \begin{1=}
    \begin{1=}
      \key{LAYOUT-MANAGER} \\
      \key{SIZE} \\
      \key{TITLE}
    \end{1=}
    \begin{0-1}
      IN \\
      =
    \end{0-1}
    \identifier
  \end{1=} \ldots


  \begin{0-1}
    \key{END-MODIFY}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{MOVE statement}

The MOVE statement sets the value of one or more data items.

\begin{syntax}
  \key{MOVE}
  \begin{0-1}
    \key{CORRESPONDING} \\
    \key{CORR}
  \end{0-1}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{TO}
  \begin{1=}
    \identifier
  \end{1=} \ldots
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{MULTIPLY statement}

The MULTIPLY statement multiplies multiple numbers and stores the result.

\format{simple}
\begin{syntax}
  \key{MULTIPLY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{BY}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-MULTIPLY}
  \end{0-1}
\end{syntax}

\format{giving}
\begin{syntax}
  \key{MULTIPLY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{BY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}

  \key{GIVING}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-MULTIPLY}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{NEXT SENTENCE statement}

The NEXT SENTENCE statement transfers execution to the first statement following the current sentence.

\begin{syntax}[\archaiccolour]
    \key{NEXT} \key{SENTENCE}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{OPEN statement}

The OPEN statement allows the program to access or modify specified files.

\begin{syntax}
  \key{OPEN}
  \begin{1=}
    \defdmetaelement{open-body}
  \end{1=}\ldots
\end{syntax}

where \defnmetaelement{open-body} is

\begin{syntax}
  \miscext{
    \begin{0-1}
      \key{EXCLUSIVE}
    \end{0-1}
  }
  \begin{1=}
    \key{INPUT} \\
    \key{OUTPUT} \\
    \key{I-O} \\
    \key{EXTEND}
  \end{1=}
  \begin{0-1}
    \defdmetaelement{sharing-mode}
  \end{0-1}
  \begin{0-1}
    \metaelement{retry-phrase}
  \end{0-1}
  \begin{1=}
    \filename
  \end{1=}\ldots
  \begin{0-1}
    \defdmetaelement{open-options}
  \end{0-1}
\end{syntax}

where \defnmetaelement{sharing-mode} is

\begin{syntax}
  \key{SHARING} WITH
  \begin{1=}
    \key{ALL} OTHER \\
    \key{NO} OTHER \\
    \key{READ} \key{ONLY}
  \end{1=}
\end{syntax}

where \defnmetaelement{open-options} is

\begin{syntax}
  \miscext{
    \begin{0-1}
      \begin{0-1}
        FOR \\
        WITH
      \end{0-1}
      \begin{1=}
        \key{LOCK} \\
        \pending{\key{MASS-UPDATE}} \\
        \pending{\key{BULK-ADDITION}}
      \end{1=} \\

      \key{ALLOWING}
      \begin{1=}
        \key{ALL} \\
        \key{READERS} \\
        \key{UPDATERS} \\
        \key{WRITERS} \\
        \key{NO} OTHERS
      \end{1=}
    \end{0-1}
  }
  \begin{0-1}
    WITH \key{NO} \key{REWIND} \\
    \deleted{\key{REVERSED}}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{PERFORM statement}

The PERFORM statement executes the specified procedures or statements one or more times.

\format{procedure}
\begin{syntax}
  \key{PERFORM}
  \miscext{
    \begin{0-1}
      \pending{IN \key{THREAD}}
    \end{0-1}
  }
  \procedurename
  \begin{0-1}
    \begin{1=}
      \key{THROUGH} \\
      \key{THRU}
    \end{1=}
    \procedurename
  \end{0-1}

  \miscext{
    \begin{0-1}
      \pending{\key{HANDLE} IN \identifier}
    \end{0-1}
  }
  \begin{0-1}
    \gnucobol{\key{FOREVER}} \\
    \defdmetaelement{times-phrase} \\
    \defdmetaelement{until-phrase} \\
    \defdmetaelement{varying-phrase}
  \end{0-1}
\end{syntax}

\format{inline}
\begin{syntax}
  \key{PERFORM}
  \miscext{
    \begin{0-1}
      \pending{IN \key{THREAD}}
    \end{0-1}
  }
  \begin{0-1}
    \gnucobol{\key{FOREVER}} \\
    \defdmetaelement{times-phrase} \\
    \defdmetaelement{until-phrase} \\
    \defdmetaelement{varying-phrase}
  \end{0-1}
  \miscext{
    \begin{0-1}
      \pending{\key{HANDLE} IN \identifier}
    \end{0-1}
  }

  \imperativestatement

  \begin{0-1}
    \key{END-PERFORM}
  \end{0-1}
\end{syntax}

where \defnmetaelement{times-phrase} is

\begin{syntax}
  \begin{1=}
    \identifier \\
    \literal \\
    \functionname
  \end{1=}
  \key{TIMES} \\
\end{syntax}

where \defnmetaelement{until-phrase} is

\begin{syntax}
  \begin{0-1}
    WITH \key{TEST}
    \begin{1=}
      \key{BEFORE} \\
      \key{AFTER} \\
    \end{1=}
  \end{0-1}
  \key{UNTIL}
  \begin{1=}
    \condition \\
    \gnucobol{\key{EXIT}}
  \end{1=} \\
\end{syntax}

and where \defnmetaelement{varying-phrase} is

\begin{syntax}
  \begin{0-1}
    WITH \key{TEST}
    \begin{1=}
      \key{BEFORE} \\
      \key{AFTER} \\
    \end{1=}
  \end{0-1}

  \key{VARYING} \identifier \key{FROM}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \begin{0-1}
    \key{BY}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0-1}
  \key{UNTIL}
  \condition

  \begin{0-1}
    \key{AFTER} \identifier \key{FROM}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \key{BY}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}

    \key{UNTIL}
    \condition
  \end{0-1} \ldots
\end{syntax}

% TO-DO: Improve

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{PURGE statement}

The PURGE statement

\begin{syntax}[\deletedcolour]
  \pending{\key{PURGE} \cdname}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{RAISE statement}

The PURGE statement

\pending{
  \begin{syntax}
    \key{RAISE}
    \begin{1=}
      \key{EXCEPTION} \metaelement{exception-name} \\
      \identifier
    \end{1=}
  \end{syntax}
}
\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{READ statement}

The READ statement transfer data from a file to the file's record or to a data item.

\begin{syntax}
  \key{READ} \filename
  \begin{0-1}
    \key{NEXT} \\
    \key{PREVIOUS}
  \end{0-1}
  RECORD
  \begin{0-1}
    \key{INTO} \identifier
  \end{0-1}

  \begin{0-1}
    \begin{1=}
      \key{IGNORING} \key{LOCK} \\
      \miscext{WITH \key{IGNORE} \key{LOCK}}
    \end{1=} \\

    \begin{0-1}
      \pending{\key{ADVANCING} ON \key{LOCK}} \\
      \pending{\metaelement{retry-phrase}}
    \end{0-1}
    \begin{0-1}
      WITH
      \begin{1=}
        \begin{0-1}
          \key{NO} \\
          \miscext{\key{KEPT}}
        \end{0-1}
        \key{LOCK} \\

        \miscext{\key{WAIT}}
      \end{1=}
    \end{0-1}
  \end{0-1}

  \begin{0-1}
    \key{KEY} IS \identifier
  \end{0-1}

  \begin{0-1}
    \begin{1+}
      \key{INVALID} \key{KEY} \imperativestatement \\
      \key{NOT} \key{INVALID} \key{KEY} \imperativestatement
    \end{1+} \\

    \begin{1+}
      AT \key{END} \imperativestatement \\
      \key{NOT} AT \key{END} \imperativestatement
    \end{1+}
  \end{0-1}

  \begin{0-1}
    \key{END-READ}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{READY statement}

The READY TRACE statement causes the name of procedures reached by execution to be displayed.

\begin{syntax}[\miscextcolour]
  \key{READY} \key{TRACE}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{RECEIVE statement}

The RECEIVE statement transfers data from a communication descriptor to a data item.

\begin{syntax}[\deletedcolour]
  \pending{
    \key{RECEIVE} \cdname
    \begin{1=}
      \key{MESSAGE} \\
      \key{SEGMENT}
    \end{1=}
    \key{INTO} \identifier
  }

  \pending{
    \begin{0+}
      WITH \key{DATA} \imperativestatement \\
      \key{NO} \key{DATA} \imperativestatement
    \end{0+}
  }

  \pending{
    \begin{0-1}
      \key{END-RECEIVE}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{RELEASE statement}

The RELEASE statement provides a record for sorting.

\begin{syntax}
  \key{RELEASE} \identifier
  \begin{0-1}
    \key{FROM}
    \begin{1=}
      \identifier \\
      \literal \\
      \metaelement{function-call-1}
    \end{1=}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{RESET statement}

The RESET TRACE stops the names of procedures reached by execution being displayed.

\begin{syntax}[\miscextcolour]
  \key{RESET} \key{TRACE}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{RETURN statement}

The RETURN statement retrieves records from the sorting process in order.

\begin{syntax}
  \key{RETURN} \filename RECORD
  \begin{0-1}
    \key{INTO} \identifier
  \end{0-1}

  AT \key{END} \imperativestatement

  \begin{0-1}
    \key{NOT} AT \key{END} \imperativestatement
  \end{0-1}

  \begin{0-1}
    \key{END-RETURN}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{REWRITE statement}

The REWRITE statement replaces an existing record in the file with one provided by the program.

\begin{syntax}
  \key{REWRITE}
  \begin{1=}
    \recordname
    \begin{0-1}
      \key{FROM}
      \begin{1=}
        \identifier \\
        \literal \\
        \functionname
      \end{1=}
    \end{0-1} \\

    \key{FILE} \filename \key{FROM}
    \begin{1=}
      \identifier \\
      \literal \\
      \functionname
    \end{1=}
  \end{1=}

  \begin{0-1}
    \pending{\metaelement{retry-phrase}}
  \end{0-1}

  \begin{0-1}
    WITH
    \begin{0-1}
      \key{NO}
    \end{0-1}
    \key{LOCK}
  \end{0-1}

  \begin{0+}
    \key{INVALID} \key{KEY} \imperativestatement \\
    \key{NOT} \key{INVALID} \key{KEY} \imperativestatement
  \end{0+} \\

  \begin{0-1}
    \key{END-REWRITE}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{ROLLBACK statement}

The ROLLBACK statement deletes any pending file writes.

\begin{syntax}[\miscextcolour]
  \key{ROLLBACK}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SEARCH statement}

The SEARCH statement iterates through a table to find a record satisfying a condition.

\format{simple}
\begin{syntax}
  \key{SEARCH} \identifier
  \begin{0-1}
    \key{VARYING} \identifier
  \end{0-1}

  \begin{0-1}
    AT \key{END} \imperativestatement
  \end{0-1}

  \begin{1=}
    \key{WHEN} \condition \imperativestatement
  \end{1=} \ldots

  \begin{0-1}
    \key{END-SEARCH}
  \end{0-1}
\end{syntax}

\format{all}
\begin{syntax}
  \key{SEARCH} \key{ALL} \identifier

  \begin{0-1}
    AT \key{END} \imperativestatement
  \end{0-1}

  \key{WHEN} \expression \imperativestatement

  \begin{0-1}
    \key{END-SEARCH}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SEND statement}

The SEND statement provides data to a communication descriptor.

\format{from}
\begin{syntax}[\deletedcolour]
  \pending{
    \key{SEND} \cdname \key{FROM} \identifier
  }
\end{syntax}

\format{with indicator}
\begin{syntax}[\deletedcolour]
  \pending{
    \key{SEND} \cdname
    \begin{0-1}
      \key{FROM} \identifier
    \end{0-1}
    WITH
    \begin{1=}
      \identifier \\
      \key{ESI} \\
      \key{EMI} \\
      \key{EGI}
    \end{1=}
  }

  \begin{0-1}
    \begin{1=}
      \key{BEFORE} \\
      \key{AFTER}
    \end{1=}
    ADVANCING
    \begin{1=}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
      \begin{0-1}
        \key{LINE} \\
        \key{LINES}
      \end{0-1} \\

      \mnemonicname \\

      \key{PAGE}
    \end{1=}
  \end{0-1}

  \pending{
    \begin{0-1}
      \key{REPLACING} LINE
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SET statement}

The SET statement sets the value or properties of a data item.

\format{simple}
\begin{syntax}
  \key{SET} \identifier \key{TO}
  \begin{1=}
    \identifier \\
    \literal \\
    \arithmeticexpression
  \end{1=}
\end{syntax}

\format{entry}
\begin{syntax}[\gnucobolcolour]
  \key{SET} \identifier \key{TO} \key{ENTRY}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
\end{syntax}

\format{environment}
\begin{syntax}[\miscextcolour]
  \key{SET} \key{ENVIRONMENT}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{TO}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
\end{syntax}

\format{attribute}
\begin{syntax}
  \key{SET} \identifier \key{ATTRIBUTE}
  \begin{1=}
    \begin{1=}
      \begin{1=}
        \key{BELL} \\
        \miscext{\key{BEEP}}
      \end{1=} \\

      \key{BLINK} \\
      \key{HIGHLIGHT} \\
      \key{LOWLIGHT} \\
      \key{REVERSE-VIDEO} \\
      \key{UNDERLINE} \\
      \key{LEFTLINE} \\
      \key{OVERLINE}
    \end{1=}
    \begin{1=}
      \key{ON} \\
      \key{OFF}
    \end{1=}
  \end{1=}\ldots
\end{syntax}

\format{arithmetic}
\begin{syntax}
  \key{SET}
  \begin{1=}
    \cobolindexname
  \end{1=}\ldots
  \begin{1=}
    \key{UP} \\
    \key{DOWN}
  \end{1=}
  \key{BY}
  \arithmeticexpression
\end{syntax}

\format{on\slash{}off}
\begin{syntax}
  \key{SET}
  \begin{1=}
    \begin{1=}
      \mnemonicname
    \end{1=}\ldots
    \key{TO}
    \begin{1=}
      \key{ON} \\
      \key{OFF}
    \end{1=}
  \end{1=} \ldots
\end{syntax}

\format{true\slash{}false}
\begin{syntax}
  \key{SET}
  \begin{1=}
    \begin{1=}
      \conditionname
    \end{1=}\ldots
    \key{TO}
    \begin{1=}
      \key{TRUE} \\
      \key{FALSE}
    \end{1=}
  \end{1=} \ldots
\end{syntax}

\format{exception}
\begin{syntax}
  \key{SET} \key{LAST} \key{EXCEPTION} \key{TO} \key{OFF}
\end{syntax}

\format{thread}
\begin{syntax}[\miscextcolour]
  \pending{
    \key{SET} \key{THREAD}
    \begin{0-1}
      \identifier
    \end{0-1}
    \key{PRIORITY} \key{TO}
    \begin{1=}
      \identifier \\
      \integer
    \end{1=}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SORT statement}

The SORT statement sorts the record of a file or a table.

\begin{syntax}
  \key{SORT} \identifier
  \begin{0-1}
    ON
    \begin{1=}
      \key{ASCENDING} \\
      \key{DESCENDING}
    \end{1=}
    KEY
    \begin{0-1}
      \identifier
    \end{0-1}\ldots
  \end{0-1} \ldots

  \begin{0-1}
    WITH \key{DUPLICATES}
    \begin{0-1}
      IN \key{ORDER}
    \end{0-1}
  \end{0-1}

  \begin{0-1}
    COLLATING \key{SEQUENCE} IS
    \begin{1=}
      IS \metaelement{alphanumeric-collating-sequence}
      \pending{
        \begin{0-1}
          \metaelement{national-collating-sequence}
        \end{0-1}
      } \\

      \begin{1+}
        FOR \key{ALPHANUMERIC} IS \metaelement{alphanumeric-collating-sequence} \\
        \pending{FOR \key{NATIONAL} IS \metaelement{national-collating-sequence}}
      \end{1+}
    \end{1=}
  \end{0-1}

  \begin{0-1}
    \key{USING}
    \begin{1=}
      \filename
    \end{1=}\ldots \\

    \key{INPUT} \key{PROCEDURE} IS
    \procedurename
    \begin{0-1}
      \begin{1=}
        \key{THROUGH} \\
        \key{THRU}
      \end{1=}
      \procedurename
    \end{0-1}
  \end{0-1}

  \begin{0-1}
    \key{GIVING}
    \begin{1=}
      \filename
    \end{1=}\ldots \\

    \key{OUTPUT} \key{PROCEDURE} IS
    \procedurename
    \begin{0-1}
      \begin{1=}
        \key{THROUGH} \\
        \key{THRU}
      \end{1=}
      \procedurename
    \end{0-1}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{START statement}

The START statement changes the record currently being considered. It may also change the order in which records are accessed.

\begin{syntax}
  \key{START} \filename
  \begin{0-1}
    \key{FIRST} \\

    \key{KEY} IS \metaelement{relational-operator} \identifier \\

    \key{LAST}
  \end{0-1}

  \begin{0-1}
    WITH
    \begin{1=}
      \key{SIZE} \\
      \gnucobol{\key{LENGTH}}
    \end{1=}
    \arithmeticexpression
  \end{0-1}

  \begin{0+}
    \key{INVALID} KEY \imperativestatement \\
    \key{NOT} \key{INVALID} KEY \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-START}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{STOP statement}

The STOP statement terminates the run unit and returns control to the operating system.

\format{standard}

\begin{syntax}
  \key{STOP} \key{RUN}
  \begin{0-1}
    \begin{1=}
      \key{RETURNING} \\
      \miscext{\key{GIVING}}
    \end{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=} \\

    WITH
    \begin{1=}
      \key{ERROR} \\
      \key{NORMAL}
    \end{1=}
    STATUS
    \begin{0-1}
      \identifier \\
      \literal
    \end{0-1}
  \end{0-1}
\end{syntax}

\format{literal}

\begin{syntax}[\deletedcolour]
  \key{STOP} \literal
\end{syntax}

\format{identifier}

\begin{syntax}[\miscextcolour]
  \key{STOP} \identifier
\end{syntax}

\format{ACUCOBOL}

\begin{syntax}[\miscextcolour]
  \key{STOP} \key{RUN}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
\end{syntax}

\format{thread}

\begin{syntax}[\miscextcolour]
  \pending{
    \key{STOP} \key{THREAD}
    \begin{0-1}
      \identifier
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{STRING statement}

The STRING statement appends multiples character strings and stores the result.

\begin{syntax}
  \key{STRING}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}

    \begin{0-1}
      \key{DELIMITED} BY
      \begin{1=}
        \key{SIZE} \\
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}
  \end{1=} \ldots\ {}
  \key{INTO} \identifier

  \begin{0-1}
    WITH \key{POINTER} IS \identifier
  \end{0-1}

  \begin{0+}
    ON \key{OVERFLOW} \imperativestatement \\
    \key{NOT} ON \key{OVERFLOW} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-STRING}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SUBTRACT statement}

The SUBTRACT statement subtracts one set of numbers from another set of numbers and stores the results.

\format{simple}
\begin{syntax}
  \key{SUBTRACT}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=} \ldots
  \key{FROM}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-SUBTRACT}
  \end{0-1}
\end{syntax}

\format{giving}
\begin{syntax}
  \key{SUBTRACT}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=} \ldots
  \key{FROM}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}

  \key{GIVING}
  \begin{1=}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  \end{1=} \ldots

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-SUBTRACT}
  \end{0-1}
\end{syntax}

\format{corresponding}
\begin{syntax}
  \key{SUBTRACT}
  \begin{1=}
    \key{CORR} \\
    \key{CORRESPONDING}
  \end{1=}
  \identifier{} \key{FROM} \identifier
  \begin{0-1}
    \metaelement{rounded-phrase}
  \end{0-1}

  \begin{0+}
    ON \key{SIZE} \key{ERROR} \imperativestatement \\
    \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-SUBTRACT}
  \end{0-1}
\end{syntax}

\format{table}
\begin{syntax}
  \pending{
    \key{SUBTRACT} \key{TABLE} \identifier \key{TO} \identifier
    \begin{0-1}
      \metaelement{rounded-phrase}
    \end{0-1}
  }

  \pending{
    \begin{0-1}
      \key{FROM} INDEX \integer \key{TO} \integer
    \end{0-1}
  }

  \pending{
    \begin{0-1}
      \key{DESTINATION} INDEX \integer
    \end{0-1}
  }

  \pending{
    \begin{0+}
      ON \key{SIZE} \key{ERROR} \imperativestatement \\
      \key{NOT} ON \key{SIZE} \key{ERROR} \imperativestatement
    \end{0+}
  }

  \pending{
    \begin{0-1}
      \key{END-SUBTRACT}
    \end{0-1}
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{SUPPRESS statement}

The SUPPRESS statement suppresses the writing of a report group.

\begin{syntax}
  \key{SUPPRESS} PRINTING
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{TERMINATE statement}

The TERMINATE statement prevents further writing of a report.

\begin{syntax}
  \pending{
    \key{TERMINATE}
    \begin{1=}
      \reportname
    \end{1=} \ldots
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{TRANSFORM statement}

The TRANSFORM statement replaces instances of character with another character.

\begin{syntax}[\deletedcolour]
  \key{TRANSFORM} \identifier \key{FROM}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
  \key{TO}
  \begin{1=}
    \identifier \\
    \literal
  \end{1=}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{UNLOCK statement}

The UNLOCK statement releases all currently held locks on a file.

\begin{syntax}
  \key{UNLOCK} \filename
  \begin{0-1}
    RECORD \\
    RECORDS
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{UNSTRING statement}

The UNSTRING statement extracts substrings from a string and copies the substrings to specified data items.

\begin{syntax}
  \key{UNSTRING}
  \begin{1=}
    \identifier \\
    \miscext{\literal}
  \end{1=}

  \begin{0-1}
    \key{DELIMITED} BY
    \begin{0-1}
      \key{ALL}
    \end{0-1}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{1=}
      \key{OR}
      \begin{0-1}
        \key{ALL}
      \end{0-1}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{1=} \ldots
  \end{0-1}

  \key{INTO}
  \begin{1=}
    \identifier
    \begin{0-1}
      \key{DELIMITER} IN \identifier
    \end{0-1}
    \begin{0-1}
      \key{COUNT} IN \identifier
    \end{0-1}
  \end{1=} \ldots

  \begin{0-1}
    WITH \key{POINTER} IS \identifier
  \end{0-1}

  \begin{0-1}
    \key{TALLYING} IN \identifier
  \end{0-1}

  \begin{0+}
    ON \key{OVERFLOW} \imperativestatement \\
    \key{NOT} ON \key{OVERFLOW} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-UNSTRING}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{USE statement}

The USE statement indicates when a declarative should be executed.

\format{file exception}
\begin{syntax}
  \key{USE}
  \begin{0-1}
    \key{GLOBAL}
  \end{0-1}
  AFTER STANDARD
  \begin{1=}
    \key{EXCEPTION} \\
    \key{ERROR}
  \end{1=}
  PROCEDURE ON

  \begin{1=}
    \begin{1=}
      \filename
    \end{1=} \ldots
    \begin{0+}
      \key{INPUT} \\
      \key{OUTPUT} \\
      \key{I-O} \\
      \key{EXTEND}
    \end{0+} \ldots
  \end{1=}
\end{syntax}

\format{debugging}
\begin{syntax}[\deletedcolour]
  \key{USE} FOR \key{DEBUGGING} ON
  \begin{1=}
    \procedurename \\
    \key{ALL} \key{PROCEDURES} \\
    \key{ALL} REFERENCES OF \identifier
  \end{1=} \ldots
\end{syntax}

\format{start\slash{}end}
\begin{syntax}[\miscextcolour]
  \pending{
    \key{USE} AT \key{PROGRAM}
    \begin{1=}
      \key{START} \\
      \key{END}
    \end{1=}
  }
\end{syntax}

\format{reporting}
\begin{syntax}
  \key{USE}
  \begin{0-1}
    \key{GLOBAL}
  \end{0-1}
  \key{BEFORE} \key{REPORTING} \identifier
\end{syntax}

\format{exception}
\begin{syntax}
  \pending{
    \key{USE}
    \begin{1=}
      \key{EXCEPTION} \metaelement{exception-name}
      \begin{0-1}
        \key{FILE} \filename
      \end{0-1}\dots
    \end{1=}\dots
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{VALIDATE statement}

The VALIDATE statement performs various validation tasks for a data item.

\begin{syntax}
  \pending{
    \key{VALIDATE}
    \begin{1=}
      \identifier
    \end{1=} \dots
  }
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{WRITE statement}

The WRITE statement provides a new record to the file.

\format{sequential}
\begin{syntax}
  \key{WRITE}
  \begin{1=}
    \recordname
    \begin{0-1}
      \key{FROM}
      \begin{1=}
        \identifier \\
        \literal \\
        \functionname
      \end{1=}
    \end{0-1} \\

    \key{FILE} \filename \key{FROM}
    \begin{1=}
      \identifier \\
      \literal \\
      \functionname
    \end{1=}
  \end{1=}

  \begin{0-1}
    \begin{1=}
      \key{BEFORE} \\
      \key{AFTER}
    \end{1=}
    ADVANCING
    \begin{1=}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
      \begin{0-1}
        \key{LINE} \\
        \key{LINES}
      \end{0-1} \\

      \mnemonicname \\

      \key{PAGE}
    \end{1=}
  \end{0-1}

  \begin{0-1}
    \pending{\metaelement{retry-phrase}}
  \end{0-1}
  \begin{0-1}
    WITH
    \begin{0-1}
      \key{NO}
    \end{0-1}
    \key{LOCK}
  \end{0-1}

  \begin{0+}
    AT
    \begin{1=}
      \key{END-OF-PAGE} \\
      \key{EOP}
    \end{1=}
    \imperativestatement \\

    \key{NOT} AT
    \begin{1=}
      \key{END-OF-PAGE} \\
      \key{EOP}
    \end{1=}
    \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-WRITE}
  \end{0-1}
\end{syntax}

\format{random}
\begin{syntax}
  \key{WRITE}
  \begin{1=}
    \recordname
    \begin{0-1}
      \key{FROM}
      \begin{1=}
        \identifier \\
        \literal \\
        \functionname
      \end{1=}
    \end{0-1} \\

    \key{FILE} \filename \key{FROM}
    \begin{1=}
      \identifier \\
      \literal \\
      \functionname
    \end{1=}
  \end{1=}

  \begin{0-1}
    \begin{1=}
      \key{BEFORE} \\
      \key{AFTER}
    \end{1=}
    ADVANCING
    \begin{1=}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
      \begin{0-1}
        \key{LINE} \\
        \key{LINES}
      \end{0-1} \\

      \mnemonicname \\

      \key{PAGE}
    \end{1=}
  \end{0-1}

  \begin{0-1}
    \pending{\metaelement{retry-phrase}}
  \end{0-1}
  \begin{0-1}
    WITH
    \begin{0-1}
      \key{NO}
    \end{0-1}
    \key{LOCK}
  \end{0-1}

  \begin{0+}
    \key{INVALID} \key{KEY} \imperativestatement \\
    \key{NOT} \key{INVALID} \key{KEY} \imperativestatement
  \end{0+} \\

  \begin{0-1}
    \key{END-WRITE}
  \end{0-1}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}


\section{XML GENERATE statement}

The XML GENERATE statement creates an XML document based on the structure and content of the input data item.

\begin{syntax}[\miscextcolour]
  \key{XML} \key{GENERATE} \identifier \key{FROM} \identifier

  \begin{0-1}
    \key{COUNT} IN \identifier
  \end{0-1}

  \begin{0-1}
    WITH \key{ENCODING}
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
  \end{0-1}

  \begin{0-1}
    WITH \key{XML-DECLARATION}
  \end{0-1}

  \begin{0-1}
    WITH \key{ATTRIBUTES}
  \end{0-1}

  \begin{0-1}
    \key{NAMESPACE} IS
    \begin{1=}
      \identifier \\
      \literal
    \end{1=}
    \begin{0-1}
      \key{NAMESPACE-PREFIX} IS
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}
  \end{0-1}

  \begin{0-1}
    \key{NAME} OF
    \begin{1=}
      \identifier IS \literal
    \end{1=}\dots
  \end{0-1}

  \begin{0-1}
    \key{TYPE} OF
    \begin{1=}
      \identifier IS
      \begin{1=}
        \key{ATTRIBUTE} \\
        \key{ELEMENT} \\
        \key{CONTENT}
      \end{1=}
    \end{1=}\dots
  \end{0-1}

  \begin{0-1}
    SUPPRESS
    \begin{1=}
      \identifier \\

      \key{EVERY}
      \begin{1=}
        \begin{1=}
          \key{NUMERIC} \\
          \key{NONNUMERIC}
        \end{1=}
        \begin{0-1}
          \key{ATTRIBUTE} \\
          \key{ELEMENT} \\
          \key{CONTENT}
        \end{0-1} \\

        \begin{1=}
          \key{ATTRIBUTE} \\
          \key{ELEMENT} \\
          \key{CONTENT}
        \end{1=}
      \end{1=} \\

      \key{WHEN}
      \begin{0-1}
        \defdmetaelement{non-quote-alnum-fig-const}
        \key{OR}
      \end{0-1}\ldots\
      \defdmetaelement{non-quote-alnum-fig-const}
    \end{1=}\ldots
  \end{0-1}

  \begin{0+}
    ON \key{EXCEPTION} \imperativestatement \\
    \key{NOT} ON \key{EXCEPTION} \imperativestatement
  \end{0+}

  \begin{0-1}
    \key{END-XML}
  \end{0-1}
\end{syntax}

where \defnmetaelement{non-quote-alnum-fig-const} is

\begin{syntax}
  \begin{1=}
    ZERO \\
    ZEROES \\
    ZEROS \\
    SPACE \\
    SPACES \\
    HIGH-VALUE \\
    HIGH-VALUES \\
    LOW-VALUE \\
    LOW-VALUES
  \end{1=}
\end{syntax}

\subsubsection{Syntax rules}

\subsubsection{General rules}

\section{XML PARSE statement}

The XML PARSE statement starts an event-driven XML parser; the processing procedure is performed as each component of the XML document is identified in order.

\pending{
  \begin{syntax}[\miscextcolour]
    \key{XML} \key{PARSE} \identifier

    \begin{0-1}
      WITH \key{ENCODING}
      \begin{1=}
        \identifier \\
        \literal
      \end{1=}
    \end{0-1}

    \begin{0-1}
      \key{RETURNING} \key{NATIONAL}
    \end{0-1}

    \begin{0-1}
      \key{VALIDATING} WITH \identifier
    \end{0-1}

    \key{PROCESSING} \key{PROCEDURE} IS \procedurename
    \begin{0-1}
      \begin{1=}
        \key{THROUGH} \\
        \key{THRU}
      \end{1=}
      \procedurename
    \end{0-1}

    \begin{0+}
      ON \key{EXCEPTION} \imperativestatement \\
      \key{NOT} ON \key{EXCEPTION} \imperativestatement
    \end{0+}

    \begin{0-1}
      \key{END-XML}
    \end{0-1}
  \end{syntax}
}

\subsubsection{Syntax rules}

\subsubsection{General rules}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "grammar.tex"
%%% End:
